use std::all
use std::linear_memory

obj Encoder {
  ptr: i32,
  pos: i32,
}

type MiniJson = Array<MiniJson> | String

impl Encoder
  fn ensure_capacity(self, add: i32) -> void
    let required = self.ptr + self.pos + add
    let current_bytes = linear_memory::size() * 65536
    if required >= current_bytes then:
      let needed = required - current_bytes
      // compute pages to grow
      let pages = (needed / 65536) + 1
      linear_memory::grow(pages)

  fn write_u8(&self, value: i32) -> void
    self.ensure_capacity(1)
    binaryen
      func: store8
      namespace: i32
      args: `(BnrConst(0), BnrConst(0), self.ptr + self.pos, value)
    self.pos = self.pos + 1

  pub fn encode_number(&self, value: i32) -> void
    if value >= 0 and value < 128 then:
      // positive fixint
      self.write_u8(value)
    else:
      // uint 32
      self.write_u8(206)
      self.write_u8(shift_ru(value, 24))
      self.write_u8(bit_and(shift_ru(value, 16), 255))
      self.write_u8(bit_and(shift_ru(value, 8), 255))
      self.write_u8(bit_and(value, 255))

  pub fn encode_string(&self, value: String) -> void
    let len = value.length
    if len < 32 then:
      // fixstr
      self.write_u8(160 + len)
    elif: len < 256 then:
      // str 8
      self.write_u8(217)
      self.write_u8(len)
    elif: len < 65536 then:
      // str 16
      self.write_u8(218)
      self.write_u8(shift_ru(len, 8))
      self.write_u8(bit_and(len, 255))
    else:
      // str 32
      self.write_u8(219)
      self.write_u8(shift_ru(len, 24))
      self.write_u8(bit_and(shift_ru(len, 16), 255))
      self.write_u8(bit_and(shift_ru(len, 8), 255))
      self.write_u8(bit_and(len, 255))

    var i = 0
    while i < len do:
      self.write_u8(value.char_code_at(i))
      i = i + 1

  pub fn encode_array(&self, value: Array<MiniJson>) -> void
    let len = value.length
    if len < 16 then:
      self.write_u8(144 + len)
    elif: len < 65536 then:
      self.write_u8(220)
      self.write_u8(shift_ru(len, 8))
      self.write_u8(bit_and(len, 255))
    else:
      self.write_u8(221)
      self.write_u8(shift_ru(len, 24))
      self.write_u8(bit_and(shift_ru(len, 16), 255))
      self.write_u8(bit_and(shift_ru(len, 8), 255))
      self.write_u8(bit_and(len, 255))

    value.each<MiniJson> item =>
      item.match(json)
        String:
          self.encode_string(json)
        Array<MiniJson>:
          self.encode_array(json)


pub fn encode_json(value: i32, ptr: i32) -> i32
  if linear_memory::size() == 0 then:
    linear_memory::grow(1)
  let &enc = Encoder { ptr: ptr, pos: 0 }
  enc.encode_number(value)
  enc.pos

pub fn encode_json(value: String, ptr: i32) -> i32
  if linear_memory::size() == 0 then:
    linear_memory::grow(1)
  let &enc = Encoder { ptr: ptr, pos: 0 }
  enc.encode_string(value)
  enc.pos

pub fn encode_json(value: Array<MiniJson>) -> i32
  if linear_memory::size() == 0 then:
    linear_memory::grow(1)
  let &enc = Encoder { ptr: 0, pos: 0 }
  enc.encode_array(value)
  enc.pos
