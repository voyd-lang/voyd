use macros::all
use array::all
use operators::all
use optional::all
use string::all
use iter::all

pub obj Map<T> {
  buckets: Array<Array<{ key: String, value: T }>>
}

obj MapIterator<T> {
  map: Map<T>,
  bucket_index: i32,
  item_index: i32
}

pub fn new_map<T>() -> Map<T>
  let buckets = new_array<Array<{ key: String, value: T }>>({ with_size: 16 })

  var i = 0
  while i < 16 do:
    buckets.push(new_array<{ key: String, value: T }>({ with_size: 4 }))
    i = i + 1

  Map<T> { buckets: buckets }

impl<T> Iterator<{ key: String, value: T }> for MapIterator<T>
  fn next(&self) -> Optional<{ key: String, value: T }>
    if self.bucket_index >= self.map.buckets.length then:
      None {}
    else:
      self.map.buckets.get(self.bucket_index).match(bucket)
        Some<Array<{ key: String, value: T }>>:
          if self.item_index >= bucket.value.length then:
            self.bucket_index = self.bucket_index + 1
            self.item_index = 0
            self.next()
          else:
            let r = bucket.value.get(self.item_index)
            self.item_index = self.item_index + 1
            match(r)
              Some<{ key: String, value: T }>:
                r
              None:
                self.next()
        None:
          self.bucket_index = self.bucket_index + 1
          self.next()

impl<T> Iterable<{ key: String, value: T }> for Map<T>
  fn iterate(self) -> Iterator<{ key: String, value: T }>
    MapIterator<T> { map: self, bucket_index: 0, item_index: 0 }

impl<T> Map<T>
  pub fn init(buckets: Array<Array<{ key: String, value: T }>>) -> Map<T>
    Map<T> { buckets: buckets }

  fn hash(self, key: String) -> i32
    var hash_value = 0
    var i = 0
    while i < key.length do:
      hash_value = (hash_value * 31 + key.char_code_at(i)) % self.buckets.length
      i = i + 1
    hash_value

  fn get_bucket_by_key(self, key: String) -> Optional<Array<{ key: String, value: T }>>
    let index = self.hash(key)
    self.buckets.get(index)

  fn get_index_of_item_in_bucket(bucket: Array<{ key: String, value: T }>, key: String) -> i32
    var i = 0
    var index = -1
    while i < bucket.length do:
      bucket.get(i).match(v)
        Some<{ key: String, value: T }>:
          if v.value.key == key then:
            index = i
            break
          0
        None:
          0
      i = i + 1
    index

  pub fn set(self, key: String, value: T) -> Map<T>
    self.get_bucket_by_key(key).match(bucket)
      Some<Array<{ key: String, value: T }>>:
        add_to_bucket(bucket.value, key, value)
        self
      None:
        let new_bucket = new_array<{ key: String, value: T }>({ with_size: 1 })
        new_bucket.set(0, { key: key, value: value })
        let index = self.hash(key)
        self.buckets.set(index, new_bucket)
        self

  fn add_to_bucket(
    bucket: Array<{ key: String, value: T }>,
    key: String,
    value: T
  )
    let index = get_index_of_item_in_bucket(bucket, key)

    if index < 0 then:
      bucket.push({ key: key, value: value })
    else:
      bucket.set(index, { key: key, value: value })

  pub fn get(self, key: String) -> Optional<T>
    self.get_bucket_by_key(key).match(bucket)
      Some<Array<{ key: String, value: T }>>:
        let index = get_index_of_item_in_bucket(bucket.value, key)
        if index < 0 then:
          None {}
        else:
          bucket.value.get(index).match(v)
            Some<{ key: String, value: T }>:
              Some<T> { value: v.value.value }
            None:
              None {}
      None: None {}

  pub fn delete(self, key: String) -> Map<T>
    self.get_bucket_by_key(key).match(bucket)
      Some<Array<{ key: String, value: T }>>:
        let index = get_index_of_item_in_bucket(bucket.value, key)
        if index < 0 then:
          self
        else:
          bucket.value.remove(index)
          self
      None: self

  pub fn has(self, key: String) -> bool
    self.get_bucket_by_key(key).match(bucket)
      Some<Array<{ key: String, value: T }>>:
        get_index_of_item_in_bucket(bucket.value, key) >= 0
      None: false
