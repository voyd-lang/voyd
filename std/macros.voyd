export
  macro pub()
    // handle syntax like "pub fn me" and "pub fn(me)"
    if body.length == 1 and body.extract(0).is_list() then:
      syntax_template export block(~~body)
    else:
      syntax_template export block(~body)

pub macro `()
  syntax_template syntax_template ~~body

pub macro let()
  define equals_expr body.extract(0)
  ` define ~(equals_expr.extract(1)) ~(equals_expr.extract(2))

pub macro var()
  define equals_expr body.extract(0)
  ` define_mut ~(equals_expr.extract(1)) ~(equals_expr.extract(2))

// Extracts typed parameters from a list where index 0 is fn name, and offset_index+ are labeled_expr
macro_let extract_parameters = (definitions) =>
  `(parameters).concat definitions.slice(1)

pub macro fn()
  let first = body.extract(0)
  let is_equals = first.extract(0) == '='
  let definitions =
    if is_equals then:
      first.extract(1)
    else:
      first
  let identifier_list =
    if definitions.extract(0) == ':' then:
      definitions.extract(1)
    else:
      if definitions.extract(0) == '->' then:
        definitions.extract(1)
      else:
        definitions
  let return_type =
    if definitions.extract(0) == ':' then:
      definitions.slice(2, 3)
    else:
      if definitions.extract(0) == '->' then:
        definitions.slice(2, 3)
      else: `()
  let identifier = identifier_list.extract(0)
  let params = extract_parameters(identifier_list)
  let expressions =
    if is_equals then:
      first.slice(2)
    else:
      body.slice(1)
  `(
    define_function,
    ~identifier,
    ~params,
    (return_type ~~return_type),
    ~~expressions
  )

pub macro binaryen_gc_call(func, args, return_type)
  ` binaryen func: ~func namespace: gc args: ~args return_type: ~return_type

pub macro bin_type_to_heap_type(type)
  ` binaryen_gc_call(modBinaryenTypeToHeapType, list(BnrType<~type>))

pub macro ify()
  let cond = body.get(0)
  // Note: we call it main_then to avoid preventing the then in body.argsWithLabel(then) from being turned into a list. Need a better way to pass a label then passing an identifier that may or may not be bound to a var
  let main_then = body.argWithLabel(then)
  let elifs = body.argsWithLabel(elif)
  let thens = body.argsWithLabel(then).slice(1)
  let main_else = body.optionalArgWithLabel(else)

  let result =
    if cond.calls('is') then:
      let l = cond.get(1)
      let r = cond.get(2)
      let match = ` ~l.match(~r: ~main_then)

      if main_else then:
        let elseExpr = ` else: ~main_else
        match.push(elseExpr)

      match
    else: // TODO: Add support for elifs to functional macro runtime
      if cond.calls(':=') then:
        let l = cond.get(1)
        let r = cond.get(2)
        let default = if main_else then: main_else else: ` block(void)
        l.mark_moved()
        `
          ~r.match
            Some:
              let ~l = ~r.value
              ~main_then
            else: ~default
      else:
        let expr = ` cond(case: ~cond, do: ~main_then))
        elifs.map (elif, index) =>
          let elifThen = thens.get(index)
          let case = ` case: ~elif
          expr.push(case)
          let do = ` do: ~elifThen
          expr.push(do)
        if main_else then: expr.push(`(default: ~main_else))
  result
