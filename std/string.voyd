use macros::all
use fixed_array::all
use operators::all
use iter::all
use optional::all

pub obj String {
  storage: FixedArray<i32>,
  count: i32
}

obj StringIterator {
  str: String,
  index: i32
}

pub fn new_string(opts: { from: FixedArray<i32> }) -> String
  String {
    storage: opts.from,
    count: opts.from.length<i32>()
  }

impl String
  fn resize(self) -> String
    let new_storage = new_fixed_array<i32>(self.storage.length<i32>() * 2)
    new_storage.copy<i32>({
      from: self.storage,
      to_index: 0,
      from_index: 0,
      count: self.storage.length<i32>()
    })
    self.storage = new_storage
    self

  pub fn length(self) -> i32
    self.count

  pub fn char_code_at(self, index: i32) -> i32
    let computed_index = compute_index(index, self.count)
    if computed_index >= self.count then:
      -1
    else:
      self.storage.get<i32>(computed_index)

  pub fn push(self, char: i32) -> String
    if self.count >= self.storage.length<i32>() then:
      self.resize().push(char)
    else:
      self.storage.set<i32>(self.count, char)
      self.count = self.count + 1
      self

  pub fn '+'(self, other: String) -> String
    let new_length = self.count + other.count
    let new_storage = new_fixed_array<i32>(new_length)
    new_storage.copy<i32>({
      from: self.storage,
      to_index: 0,
      from_index: 0,
      count: self.count
    })
    new_storage.copy<i32>({
      from: other.storage,
      to_index: self.count,
      from_index: 0,
      count: other.count
    })
    String { storage: new_storage, count: new_length }

  pub fn slice(self, start: i32, end: i32) -> String
    let computed_start = compute_index(start, self.count)
    let computed_end = compute_index(end, self.count)
    if (computed_start >= self.count) or (computed_end >= self.count) or (computed_start >= computed_end) then:
      String { storage: new_fixed_array<i32>(4), count: 0 }
    else:
      let new_length = computed_end - computed_start
      let new_storage = new_fixed_array<i32>(new_length)
      new_storage.copy<i32>({
        from: self.storage,
        to_index: 0,
        from_index: computed_start,
        count: new_length
      })
      String { storage: new_storage, count: new_length }

pub fn new_string_iterator(str: String) -> StringIterator
  StringIterator { str: str, index: 0 }

pub fn read_next_char(iterator: StringIterator) -> i32
  if iterator.index >= iterator.str.length then:
    -1
  else:
    let char = iterator.str.char_code_at(iterator.index)
    iterator.index = iterator.index + 1
    char

impl Iterator<i32> for StringIterator
  fn next(self) -> Optional<i32>
    if self.index >= self.str.length then:
      None {}
    else:
      let char = self.str.char_code_at(self.index)
      self.index = self.index + 1
      Some<i32> { value: char }

impl Iterable<i32> for String
  fn iterate(self) -> Iterator<i32>
    new_string_iterator(self)

pub fn '=='(a: String, b: String) -> bool
  if a.length != b.length then:
    false
  else:
    var i = 0
    var result = true
    while i < a.length do:
      if a.char_code_at(i) != b.char_code_at(i) then:
        result = false
        break
      i = i + 1
    result

fn compute_index(index: i32, length: i32) -> i32
  if index < 0 then: length + index else: index
