obj Array<T> {
  storage: FixedArray<T>
}
obj Some<T> {
  value: T
}
obj None {}
type Option<T> = Some<T> | None

pub fn new_array<T>({ from source: FixedArray<T> }) -> Array<T>
  Array<T> { storage: source }

impl<T> Array<T>
  pub fn get(self, index: i32) -> Option<T>
    if index < 0 or index >= __array_len(self.storage) then:
      None {}
    else:
      Some { value: __array_get(self.storage, index) }

pub fn main() -> i32
  let a = [1, 2, 3]
  let r = a.get(1)
  r.match()
    Some<i32>: r.value
    None: -1
