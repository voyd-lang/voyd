use std::optional::types::{ Optional, Some, None }
use std::optional::fns::{ some, none }
use std::dict::Dict
use std::array::new_array_unchecked
use std::range::Range
use std::string::type::new_string

fn optional_i32_or(value: Optional<i32>, fallback: i32) -> i32
  match(value)
    Some<i32> { value }:
      value
    None:
      fallback

pub fn read_index() -> i32
  let arr = [10, 20, 30]
  optional_i32_or(arr[1], -1)

pub fn write_index() -> i32
  let ~arr = [10, 20, 30]
  arr[1] = 99
  optional_i32_or(arr[1], -1)

pub fn slice_exclusive() -> i32
  let arr = [1, 2, 3, 4]
  let slice = arr[1..3]
  optional_i32_or(slice.get(0), 0) + optional_i32_or(slice.get(1), 0)

pub fn slice_inclusive() -> i32
  let arr = [1, 2, 3, 4]
  let slice = arr[1..=2]
  optional_i32_or(slice.get(0), 0) + optional_i32_or(slice.get(1), 0)

pub fn slice_left_unbounded() -> i32
  let arr = [1, 2, 3, 4]
  let slice = arr[..2]
  optional_i32_or(slice.get(0), 0) + optional_i32_or(slice.get(1), 0)

pub fn slice_left_unbounded_inclusive() -> i32
  let arr = [1, 2, 3, 4]
  let slice = arr[..=1]
  optional_i32_or(slice.get(0), 0) + optional_i32_or(slice.get(1), 0)

pub fn slice_right_unbounded() -> i32
  let arr = [1, 2, 3, 4]
  let slice = arr[2..]
  optional_i32_or(slice.get(0), 0) + optional_i32_or(slice.get(1), 0)

pub fn slice_full_unbounded() -> i32
  let arr = [1, 2, 3, 4]
  let slice = arr[..]
  slice.len()

pub fn map_roundtrip() -> i32
  let ~map = Dict<String, i32>::init()
  map["x"] = 7
  optional_i32_or(map["x"], -1)

pub fn write_oob() -> i32
  let ~arr = [1, 2, 3]
  arr[9] = 1
  0
