obj Foo {
  a: i32
}

obj Bar: Foo {
  a: i32,
  b: i32
}

obj Baz: Foo {
  a: i32,
  b: i32
}

type AB = Foo & {
  b: i32
}

fn cross_ab(ab1: AB, ab2: AB)
  ab1.a + ab2.b

pub fn test_nominal_intersections()
  let bar = Bar {
    a: 10,
    b: 20
  }

  let baz = Baz {
    a: 5,
    b: 15
  }

  cross_ab(bar, baz)

type Vec1 = { x: i32, y: i32 }
type Vec2 = { y: i32, z: i32 }
type Vec3 = Vec1 & Vec2

fn sum_vec3(v: Vec3) -> i32
  v.x + v.y + v.z

pub fn test_structural_intersections()
  sum_vec3({ x: 1, y: 2, z: 3 })

trait Image
  fn draw(self) -> Rgb

trait Movable
  fn move(~self, x: i32, y: i32) -> void
  fn coords(self) -> (i32, i32)

type MoveableImage = Movable & Image

obj Rgb {
  r: i32,
  g: i32,
  b: i32
}

obj Shape {
  image: Rgb,
  x: i32,
  y: i32
}

impl Image for Shape
  fn draw(self) -> Rgb
    self.image

impl Movable for Shape
  fn move(~self, x: i32, y: i32) -> void
    self.x = self.x + x
    self.y = self.y + y

  fn coords(self) -> (i32, i32)
    (self.x, self.y)

fn work(~shape: MoveableImage)
  shape.move(10, 15)
  let (x, y) = shape.coords()
  let color = shape.draw()
  x + y + color.r + color.g + color.b

pub fn test_trait_intersections()
  let ~shape = Shape {
    image: Rgb { r: 255, g: 128, b: 64 },
    x: 1,
    y: 2
  }
  work(~shape)

type XYMovable = { x: i32, y: i32 } & Movable

fn sum_xy_movable(~v: XYMovable) -> i32
  v.move(1, 2)
  let (x, y) = v.coords()
  x * 100 + y

pub fn test_structural_trait_intersection() -> i32
  let ~shape = Shape {
    image: Rgb { r: 1, g: 2, b: 3 },
    x: 5,
    y: 6
  }
  sum_xy_movable(~shape)

type FooMovableB = Foo & { b: i32 } & Movable

impl Movable for Bar
  fn move(~self, x: i32, y: i32) -> void
    self.a = self.a + x
    self.b = self.b + y

  fn coords(self) -> (i32, i32)
    (self.a, self.b)

fn sum_foo_movable_b(~v: FooMovableB) -> i32
  v.move(1, 2)
  let (a, b) = v.coords()
  v.a + v.b + a + b

pub fn test_nominal_structural_trait_intersection() -> i32
  let ~bar = Bar { a: 3, b: 4 }
  sum_foo_movable_b(~bar)
