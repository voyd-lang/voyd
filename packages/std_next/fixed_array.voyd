use optional::all
use iter::all

pub fn new_fixed_array<T>(size: i32) -> FixedArray<T>
  __array_new(size)

pub fn set<T>(arr: FixedArray<T>, index: i32, value: T) -> FixedArray<T>
  __array_set(arr, index, value)
  arr

pub fn copy<T>(dest_array: FixedArray<T>, opts: {
  from: FixedArray<T>,
  to_index: i32,
  from_index: i32,
  count: i32
}) -> FixedArray<T>
  __array_copy(dest_array, opts)
  dest_array

pub fn length<T>(arr: FixedArray<T>) -> i32
  __array_len(arr)

obj FixedArrayIterator<T> {
  index: i32,
  array: FixedArray<T>
}

impl<T> Iterator<T> for FixedArrayIterator<T>
  fn next(self) -> Optional<T>
    if self.index >= self.array.length<T>() then:
      None {}
    else:
      let value = self.array.get<T>(self.index)
      self.index = self.index + 1
      Some<T> { value: value }

impl<T> Iterable<T> for FixedArray<T>
  fn iterate(self) -> Iterator<T>
    FixedArrayIterator<T> { index: 0, array: self }
