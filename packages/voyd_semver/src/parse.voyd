use std::optional::all
use std::string::types::String
use std::string::fns::new_string
use self::scanner::parse_non_negative_segment

type Ver = { major: i32, minor: i32, patch: i32 }

pub fn parse(input: String): () -> Optional<Ver>
  match(input.split(once_codepoint: 46))
    Some<(String, String)> { value: major_and_rest }:
      parse_minor_and_patch(major_and_rest.0, major_and_rest.1)
    None:
      none<Ver>()

fn parse_minor_and_patch(major_text: String, remainder: String): () -> Optional<Ver>
  match(remainder.split(once_codepoint: 46))
    Some<(String, String)> { value: minor_and_patch }:
      parse_segments(major_text, minor_and_patch.0, minor_and_patch.1)
    None:
      none<Ver>()

fn parse_segments(
  major_text: String,
  minor_text: String,
  patch_text: String
): () -> Optional<Ver>
  match(parse_non_negative_segment(major_text))
    Some { value: major }:
      parse_minor(major, minor_text, patch_text)
    None:
      none<Ver>()

fn parse_minor(major: i32, minor_text: String, patch_text: String): () -> Optional<Ver>
  match(parse_non_negative_segment(minor_text))
    Some { value: minor }:
      parse_patch(major, minor, patch_text)
    None:
      none<Ver>()

fn parse_patch(major: i32, minor: i32, patch_text: String): () -> Optional<Ver>
  match(parse_non_negative_segment(patch_text))
    Some { value: patch }:
      some(Ver { major, minor, patch })
    None:
      none<Ver>()
