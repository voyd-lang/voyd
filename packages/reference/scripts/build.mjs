import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const referenceRoot = path.resolve(__dirname, "..");
const distDir = path.join(referenceRoot, "dist");

const args = new Set(process.argv.slice(2));
const shouldWatch = args.has("--watch");
const checkOnly = args.has("--check");

const ignoredDirs = new Set(["dist", "node_modules", ".turbo"]);

function walkMarkdownFiles(dir) {
  /** @type {string[]} */
  const out = [];
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    if (entry.name.startsWith(".")) continue;
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      if (ignoredDirs.has(entry.name)) continue;
      out.push(...walkMarkdownFiles(fullPath));
      continue;
    }
    if (entry.isFile() && entry.name.endsWith(".md")) out.push(fullPath);
  }
  return out;
}

function slugFromFile(filePath) {
  const rel = path.relative(referenceRoot, filePath).replaceAll(path.sep, "/");
  if (!rel.endsWith(".md")) throw new Error(`Expected markdown file: ${rel}`);
  const withoutExt = rel.slice(0, -3);
  if (withoutExt === "README") return "";
  if (withoutExt.endsWith("/README")) return withoutExt.slice(0, -"/README".length);
  return withoutExt;
}

function titleFromMarkdown(markdown, fallback) {
  const m = markdown.match(/^#\s+(.+)\s*$/m);
  return (m?.[1] ?? fallback).trim();
}

function buildReference() {
  const mdFiles = walkMarkdownFiles(referenceRoot);

  const docs = mdFiles
    .map((filePath) => {
      const slug = slugFromFile(filePath);
      const body = fs.readFileSync(filePath, "utf8");
      const title = titleFromMarkdown(body, slug || "Documentation");
      return { slug, title, body };
    })
    .sort((a, b) => {
      if (a.slug === "") return -1;
      if (b.slug === "") return 1;
      return a.slug.localeCompare(b.slug);
    });

  const docsBySlug = Object.fromEntries(docs.map((d) => [d.slug, d]));
  const nav = docs.map(({ slug, title }) => ({ slug, title }));

  const js = [
    "// This file is generated by packages/reference/scripts/build.mjs",
    "",
    `export const referenceDocs = ${JSON.stringify(docsBySlug, null, 2)};`,
    "",
    `export const referenceNav = ${JSON.stringify(nav, null, 2)};`,
    "",
    "export function getReferenceDoc(slug) {",
    "  return referenceDocs[slug] ?? null;",
    "}",
    "",
    "export default referenceNav;",
    "",
  ].join("\n");

  const dts = [
    "// This file is generated by packages/reference/scripts/build.mjs",
    "",
    "export type ReferenceDoc = {",
    "  slug: string;",
    "  title: string;",
    "  body: string;",
    "};",
    "",
    "export declare const referenceDocs: Record<string, ReferenceDoc>;",
    "export declare const referenceNav: Array<Pick<ReferenceDoc, \"slug\" | \"title\">>;",
    "export declare function getReferenceDoc(slug: string): ReferenceDoc | null;",
    "declare const _default: typeof referenceNav;",
    "export default _default;",
    "",
  ].join("\n");

  if (checkOnly) {
    const expectedJsPath = path.join(distDir, "index.js");
    const expectedDtsPath = path.join(distDir, "index.d.ts");

    const existingJs = fs.existsSync(expectedJsPath)
      ? fs.readFileSync(expectedJsPath, "utf8")
      : "";
    const existingDts = fs.existsSync(expectedDtsPath)
      ? fs.readFileSync(expectedDtsPath, "utf8")
      : "";

    if (existingJs !== js || existingDts !== dts) {
      throw new Error(
        "packages/reference dist is out of date. Run `npm -w @voyd/reference run build`."
      );
    }
    return;
  }

  fs.mkdirSync(distDir, { recursive: true });
  fs.writeFileSync(path.join(distDir, "index.js"), js);
  fs.writeFileSync(path.join(distDir, "index.d.ts"), dts);
}

function main() {
  buildReference();

  if (!shouldWatch) return;

  // Coalesce bursts of file events into a single rebuild.
  let timer = null;
  const rebuild = () => {
    try {
      buildReference();
      process.stdout.write("[reference] rebuilt\n");
    } catch (err) {
      process.stderr.write(String(err?.stack ?? err) + "\n");
    }
  };

  fs.watch(referenceRoot, { recursive: true }, (_event, filename) => {
    if (!filename) return;
    if (filename.includes(`${path.sep}dist${path.sep}`)) return;
    if (!filename.endsWith(".md")) return;
    if (timer) clearTimeout(timer);
    timer = setTimeout(rebuild, 50);
  });

  process.stdout.write("[reference] watching...\n");
}

main();
