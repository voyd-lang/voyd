use std::test::assertions::all
use std::traits::ord::{ Ordering, Less, Equal, Greater }

fn array_of_2(a: i32, b: i32) -> Array<i32>
  let ~out = Array<i32>::with_capacity(2)
  out.push(a)
  out.push(b)
  out

fn array_of_3(a: i32, b: i32, c: i32) -> Array<i32>
  let ~out = Array<i32>::with_capacity(3)
  out.push(a)
  out.push(b)
  out.push(c)
  out

fn array_of_4(a: i32, b: i32, c: i32, d: i32) -> Array<i32>
  let ~out = Array<i32>::with_capacity(4)
  out.push(a)
  out.push(b)
  out.push(c)
  out.push(d)
  out

fn array_of_5(a: i32, b: i32, c: i32, d: i32, e: i32) -> Array<i32>
  let ~out = Array<i32>::with_capacity(5)
  out.push(a)
  out.push(b)
  out.push(c)
  out.push(d)
  out.push(e)
  out

fn optional_i32_or(value: Optional<i32>, fallback: i32) -> i32
  match(value)
    Some<i32> { value }:
      value
    None:
      fallback

test "array new from fixed array preserves length":
  var fixed = new_fixed_array<i32>(2)
  fixed = __array_set(fixed, 0, 4)
  fixed = __array_set(fixed, 1, 9)

  let arr = Array<i32>::from(fixed)
  match(arr)
    Some<Array<i32>> { value }:
      assert(value.len(), eq: 2)
      match(value.first())
        Some<i32> { value }:
          assert(value, eq: 4)
        None:
          assert(false)
      match(value.last())
        Some<i32> { value }:
          assert(value, eq: 9)
        None:
          assert(false)
    None:
      assert(false)

test "array from null ref source returns none":
  let fixed = new_fixed_array<FixedArray<i32>>(1)
  let arr = Array<FixedArray<i32>>::from(fixed)
  match(arr)
    Some:
      assert(false)
    None:
      assert(true)

test "array read-only helpers":
  let arr = array_of_3(7, 9, 11)
  assert(arr.len(), eq: 3)
  assert(arr.capacity() >= 3, eq: true)
  assert(arr.is_empty(), eq: false)
  assert(arr.contains(9), eq: true)
  assert(arr.contains(8), eq: false)
  assert(arr.find_index(11), eq: 2)
  assert(arr.find_index(99), eq: -1)

  match(arr.get(0))
    Some<i32> { value }:
      assert(value, eq: 7)
    None:
      assert(false)

  match(arr.get(-1))
    Some<i32> { value }:
      assert(value, eq: 11)
    None:
      assert(false)

  match(arr.get(9))
    Some<i32>:
      assert(false)
    None:
      assert(true)

test "array subscript read and range forms":
  let arr = array_of_4(1, 2, 3, 4)
  assert(optional_i32_or(arr[1], -1), eq: 2)
  assert(optional_i32_or(arr[-1], -1), eq: 4)

  let exclusive = arr[1..3]
  assert(exclusive.len(), eq: 2)
  assert(optional_i32_or(exclusive.get(0), -1), eq: 2)
  assert(optional_i32_or(exclusive.get(1), -1), eq: 3)

  let inclusive = arr[1..=2]
  assert(inclusive.len(), eq: 2)
  assert(optional_i32_or(inclusive.get(0), -1), eq: 2)
  assert(optional_i32_or(inclusive.get(1), -1), eq: 3)

  let left_unbounded = arr[..2]
  assert(left_unbounded.len(), eq: 2)
  assert(optional_i32_or(left_unbounded.get(0), -1), eq: 1)
  assert(optional_i32_or(left_unbounded.get(1), -1), eq: 2)

  let left_unbounded_inclusive = arr[..=1]
  assert(left_unbounded_inclusive.len(), eq: 2)
  assert(optional_i32_or(left_unbounded_inclusive.get(0), -1), eq: 1)
  assert(optional_i32_or(left_unbounded_inclusive.get(1), -1), eq: 2)

  let right_unbounded = arr[2..]
  assert(right_unbounded.len(), eq: 2)
  assert(optional_i32_or(right_unbounded.get(0), -1), eq: 3)
  assert(optional_i32_or(right_unbounded.get(1), -1), eq: 4)

  let full = arr[..]
  assert(full.len(), eq: 4)
  assert(optional_i32_or(full.get(0), -1), eq: 1)
  assert(optional_i32_or(full.get(3), -1), eq: 4)

test "array higher-order helpers":
  let arr = array_of_3(1, 2, 3)

  let mapped = arr.map<i32>(v => v * 2)
  assert(mapped.len(), eq: 3)
  assert(optional_i32_or(mapped.get(0), -1), eq: 2)
  assert(optional_i32_or(mapped.get(2), -1), eq: 6)

  let filtered = arr.filter((v: i32) -> bool => v > 1)
  assert(filtered.len(), eq: 2)
  assert(optional_i32_or(filtered.get(0), -1), eq: 2)
  assert(optional_i32_or(filtered.get(1), -1), eq: 3)

  let reduced = arr.reduce<i32>(0, step: (acc: i32, v: i32) -> i32 => acc + v)
  assert(reduced, eq: 6)

  let found = arr.find((v: i32) -> bool => v == 2)
  assert(optional_i32_or(found, -1), eq: 2)

  assert(arr.any((v: i32) -> bool => v == 3), eq: true)
  assert(arr.all((v: i32) -> bool => v > 0), eq: true)
  assert(arr.all((v: i32) -> bool => v > 1), eq: false)

test "array slice enumerate concat and fixed array conversion":
  let arr = array_of_3(3, 4, 5)
  let sliced = arr.slice(from: 1, to: 3)
  assert(sliced.len(), eq: 2)
  assert(optional_i32_or(sliced.get(0), -1), eq: 4)
  assert(optional_i32_or(sliced.get(1), -1), eq: 5)

  let entries = arr.enumerate()
  assert(entries.len(), eq: 3)
  match(entries.get(1))
    Some<(i32, i32)> { value }:
      assert(value.0, eq: 1)
      assert(value.1, eq: 4)
    None:
      assert(false)

  let concatenated = arr.concat(array_of_2(6, 7))
  assert(concatenated.len(), eq: 5)
  assert(optional_i32_or(concatenated.get(3), -1), eq: 6)

  let fixed = arr.to_fixed_array()
  assert(__array_len(fixed), eq: 3)
  assert(__array_get(fixed, 2), eq: 5)

  let raw = arr.raw_storage()
  assert(__array_get(raw, 0), eq: 3)

test "array mutating clear reserve push pop":
  let ~arr = Array<i32>::with_capacity(1)
  arr.reserve(4)
  assert(arr.capacity() >= 4, eq: true)

  arr.push(1)
  arr.push(2)
  assert(arr.len(), eq: 2)

  let popped = arr.pop()
  assert(optional_i32_or(popped, -1), eq: 2)
  assert(arr.len(), eq: 1)

  arr.clear()
  assert(arr.len(), eq: 0)
  assert(arr.is_empty(), eq: true)

test "array mutating insert and remove":
  let ~arr = array_of_2(10, 30)
  arr.insert(20, at: 1)
  assert(arr.len(), eq: 3)
  assert(optional_i32_or(arr.get(1), -1), eq: 20)

  let removed = arr.remove(-1)
  assert(optional_i32_or(removed, -1), eq: 30)
  assert(arr.len(), eq: 2)
  assert(optional_i32_or(arr.get(1), -1), eq: 20)

test "array mutating replace":
  let ~arr = array_of_3(10, 20, 30)
  assert(arr.replace(1, with: 99), eq: true)
  assert(optional_i32_or(arr.get(1), -1), eq: 99)
  assert(arr.replace(9, with: 1), eq: false)
  assert(arr.replace(-9, with: 1), eq: false)

test "array subscript write":
  let ~arr = array_of_3(10, 20, 30)
  arr[1] = 99
  assert(optional_i32_or(arr[1], -1), eq: 99)

test "array mutating sort":
  let ~arr = array_of_3(3, 1, 2)
  arr.sort((left: i32, right: i32) -> i32 =>
    if left < right: -1
    left > right: 1
    else: 0
  )
  assert(optional_i32_or(arr.get(0), -1), eq: 1)
  assert(optional_i32_or(arr.get(1), -1), eq: 2)
  assert(optional_i32_or(arr.get(2), -1), eq: 3)

test "array mutating extend and splice":
  let ~arr = array_of_3(1, 2, 5)
  arr.extend(array_of_2(8, 9))
  assert(arr.len(), eq: 5)
  assert(optional_i32_or(arr.get(4), -1), eq: 9)

  let removed = arr.splice(at: 1, removing: 3, inserting: array_of_2(3, 4))

  assert(removed.len(), eq: 3)
  assert(optional_i32_or(removed.get(0), -1), eq: 2)
  assert(optional_i32_or(removed.get(2), -1), eq: 8)

  assert(arr.len(), eq: 4)
  assert(optional_i32_or(arr.get(0), -1), eq: 1)
  assert(optional_i32_or(arr.get(1), -1), eq: 3)
  assert(optional_i32_or(arr.get(2), -1), eq: 4)
  assert(optional_i32_or(arr.get(3), -1), eq: 9)

test "array non-mutating mirrors":
  let arr = array_of_3(1, 2, 3)

  let cleared = arr.cleared()
  assert(cleared.len(), eq: 0)
  assert(arr.len(), eq: 3)

  let reserved = arr.reserved(10)
  let min_reserved = arr.len() + 10
  assert(reserved.capacity() >= min_reserved, eq: true)

  let pushed = arr.pushed(4)
  assert(arr.len(), eq: 3)
  assert(pushed.len(), eq: 4)
  assert(optional_i32_or(pushed.last(), -1), eq: 4)

  let popped = arr.popped()
  assert(popped.array.len(), eq: 2)
  assert(optional_i32_or(popped.value, -1), eq: 3)

  let inserted = arr.inserted(9, at: 1)
  assert(inserted.len(), eq: 4)
  assert(optional_i32_or(inserted.get(1), -1), eq: 9)

  let removed = arr.removed(0)
  assert(removed.len(), eq: 2)
  assert(optional_i32_or(removed.first(), -1), eq: 2)

  let extended = arr.extended(array_of_2(4, 5))
  assert(extended.len(), eq: 5)

  let spliced = arr.spliced(at: 1, removing: 1, inserting: array_of_2(8, 9))
  assert(spliced.len(), eq: 4)
  assert(optional_i32_or(spliced.get(0), -1), eq: 1)
  assert(optional_i32_or(spliced.get(1), -1), eq: 8)

  let sorted = arr.sorted((left: i32, right: i32) -> i32 =>
    if left < right: -1
    left > right: 1
    else: 0
  )
  assert(optional_i32_or(arr.get(0), -1), eq: 1)
  assert(optional_i32_or(sorted.get(0), -1), eq: 1)

test "array sorted does not mutate source":
  let arr = array_of_3(3, 1, 2)
  let sorted = arr.sorted((left: i32, right: i32) -> i32 =>
    if left < right: -1
    left > right: 1
    else: 0
  )
  assert(optional_i32_or(arr.get(0), -1), eq: 3)
  assert(optional_i32_or(sorted.get(0), -1), eq: 1)

test "array copy-on-write keeps copies isolated":
  let ~base = array_of_2(1, 2)
  let ~copy = base.copied()

  copy.push(3)
  assert(base.len(), eq: 2)
  assert(copy.len(), eq: 3)
  assert(optional_i32_or(base.last(), -1), eq: 2)
  assert(optional_i32_or(copy.last(), -1), eq: 3)

  base.push(4)
  assert(base.len(), eq: 3)
  assert(copy.len(), eq: 3)
  assert(optional_i32_or(base.last(), -1), eq: 4)
  assert(optional_i32_or(copy.last(), -1), eq: 3)

test "array reverse pairs and utility helpers":
  let source = array_of_4(1, 2, 3, 4)
  let reversed = source.reversed()
  assert(optional_i32_or(reversed.get(0), -1), eq: 4)
  assert(optional_i32_or(source.get(0), -1), eq: 1)

  let ~mut = source.copied()
  mut.reverse()
  assert(optional_i32_or(mut.get(0), -1), eq: 4)

  let taken = source.take(2)
  assert(taken.len(), eq: 2)
  assert(optional_i32_or(taken.get(1), -1), eq: 2)

  let dropped = source.drop(2)
  assert(dropped.len(), eq: 2)
  assert(optional_i32_or(dropped.get(0), -1), eq: 3)

  let chunks = array_of_5(1, 2, 3, 4, 5).chunk(of: 2)
  assert(chunks.len(), eq: 3)
  match(chunks.get(0))
    Some<Array<i32>> { value }:
      assert(value.len(), eq: 2)
      assert(optional_i32_or(value.get(1), -1), eq: 2)
    None:
      assert(false)

  let windows = source.window(3)
  assert(windows.len(), eq: 2)
  match(windows.get(1))
    Some<Array<i32>> { value }:
      assert(optional_i32_or(value.get(0), -1), eq: 2)
      assert(optional_i32_or(value.get(2), -1), eq: 4)
    None:
      assert(false)

  let paired = source.zip(array_of_2(9, 8))
  assert(paired.len(), eq: 2)
  match(paired.get(0))
    Some<(i32, i32)> { value }:
      assert(value.0, eq: 1)
      assert(value.1, eq: 9)
    None:
      assert(false)

  let expanded = array_of_2(1, 2).flat_map<i32>((v: i32) -> Array<i32> =>
    array_of_2(v, v + 10)
  )
  assert(expanded.len(), eq: 4)
  assert(optional_i32_or(expanded.get(3), -1), eq: 12)

  let folded = source.fold((left: i32, right: i32) -> i32 => left + right)
  assert(optional_i32_or(folded, -1), eq: 10)

  let found_index = source.find_index_where((v: i32) -> bool => v == 3)
  assert(found_index, eq: 2)

  let partitioned = source.partition((v: i32) -> bool => v > 2)
  assert(partitioned.0.len(), eq: 2)
  assert(partitioned.1.len(), eq: 2)

test "array default sort and sorted overloads":
  let ~mut = array_of_4(4, 1, 3, 2)
  mut.sort()
  assert(optional_i32_or(mut.get(0), -1), eq: 1)
  assert(optional_i32_or(mut.get(3), -1), eq: 4)

  let sorted = array_of_3(5, 2, 4).sorted()
  assert(optional_i32_or(sorted.get(0), -1), eq: 2)
  assert(optional_i32_or(sorted.get(2), -1), eq: 5)

test "array labeled overloads and predicates":
  let source = array_of_4(3, 1, 4, 2)
  assert(optional_i32_or(source.get(at: 0), -1), eq: 3)
  assert(source.at(at: 1), eq: 1)
  assert(source.contains(value: 4), eq: true)
  assert(source.contains(where: (value: i32) -> bool => value > 3), eq: true)
  assert(source.any(where: (value: i32) -> bool => value == 2), eq: true)
  assert(source.all(where: (value: i32) -> bool => value > 0), eq: true)

  let found = source.find(where: (value: i32) -> bool => value == 4)
  assert(optional_i32_or(found, -1), eq: 4)
  match(source.find_index(value: 2))
    Some<i32> { value }:
      assert(value, eq: 3)
    None:
      assert(false)
  match(source.find_index(where: (value: i32) -> bool => value == 9))
    Some<i32>:
      assert(false)
    None:
      assert(true)

test "array sorted by ordering comparator":
  let source = array_of_4(3, 1, 4, 2)
  let sorted = source.sorted(by: (left: i32, right: i32) -> Ordering =>
    if left < right: Less {}
    left > right: Greater {}
    else: Equal {}
  )
  assert(optional_i32_or(sorted.get(0), -1), eq: 1)
  assert(optional_i32_or(source.get(0), -1), eq: 3)

test "array sort by ordering comparator":
  let source = array_of_4(3, 1, 4, 2)
  let ~mut = source.copied()
  mut.sort(by: (left: i32, right: i32) -> Ordering =>
    if left < right: Less {}
    left > right: Greater {}
    else: Equal {}
  )
  assert(optional_i32_or(mut.get(0), -1), eq: 1)

test "array extend array overload":
  let source = array_of_4(3, 1, 4, 2)
  let ~extend_target = Array<i32>::init()
  extend_target.extend(source)
  assert(extend_target.len(), eq: source.len())
