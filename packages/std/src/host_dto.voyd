use std::dict::Dict
use std::msgpack::MsgPack
use std::msgpack::self as msgpack
use std::optional::types::all
use std::string::type::{ String, new_string }

pub obj HostDto {
  payload: Dict<String, MsgPack>
}

impl HostDto
  api fn init() -> HostDto
    HostDto { payload: Dict<String, MsgPack>::init() }

  api fn unpack(payload: MsgPack) -> HostDto
    HostDto { payload: msgpack::unpack_map(payload) }

  api fn pack(self) -> MsgPack
    msgpack::make_map(self.payload)

  api fn set(self, key: String, value: MsgPack) -> HostDto
    let ~next = self.payload
    next.set(key: key, value: value)
    HostDto { payload: next }

  api fn read_msgpack(self, key: String) -> MsgPack
    match(self.payload.get(key: key))
      Some<MsgPack> { value }:
        value
      None:
        msgpack::make_null()

  api fn read_bool(self, key: String) -> bool
    msgpack::unpack_bool(self.read_msgpack(key))

  api fn read_i32(self, key: String) -> i32
    msgpack::unpack_i32(self.read_msgpack(key))

  api fn read_string(self, key: String) -> String
    msgpack::unpack_string(self.read_msgpack(key))
