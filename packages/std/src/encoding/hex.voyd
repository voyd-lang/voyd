//! Lower-case hexadecimal encode/decode helpers.

use std::array::Array
use std::bytes::ByteBuffer
use std::bytes::Bytes
use std::encoding::ascii::ascii_string_from
use std::encoding::errors::DecodeError
use std::math::div_rem
use std::optional::types::all
use std::result::types::{ Result, Ok, Err }
use std::string::{ String, StringSlice, new_string }

/// Encodes bytes as lower-case hexadecimal.
///
/// Params:
/// - `bytes`: Raw bytes to encode.
///
/// Returns an ASCII hex string that is always lower-case.
///
/// Example:
/// ```voyd
/// use std::encoding::hex
/// use std::bytes::ByteBuffer
///
/// let source = ByteBuffer::from_utf8("ok")
/// let encoded = hex::encode(source.as_bytes())
/// ```
pub fn encode(bytes: Bytes) -> String
  let source = bytes.to_array()
  if source.is_empty():
    return String::init()

  let ~out = Array<i32>::with_capacity(source.len() * 2)
  var index = 0
  while index < source.len() do:
    let value = source.at(index)
    out.push(hex_digit_to_ascii(div_rem(value, 16).0))
    out.push(hex_digit_to_ascii(div_rem(value, 16).1))
    index = index + 1

  ascii_string_from(out)

/// Decodes a hexadecimal string into bytes.
pub fn decode(s: String) -> Result<Bytes, DecodeError>
  decode(s.as_slice())

/// Decodes a hexadecimal string into bytes.
///
/// Params:
/// - `s`: Hex text using two digits per byte.
///
/// Returns:
/// - `Ok<Bytes>` for valid hex input.
/// - `Err<DecodeError>` when the length is odd or any character is not hex.
///
/// Example:
/// ```voyd
/// use std::encoding::hex
///
/// let decoded = hex::decode("766f7964".as_slice())
/// ```
pub fn decode(s: StringSlice) -> Result<Bytes, DecodeError>
  let source = s.to_string().to_utf8()
  let source_len = source.len()
  if source_len == 0:
    return Ok<Bytes> { value: ByteBuffer::init().as_bytes() }
  if div_rem(source_len, 2).1 != 0:
    return decode_error("hex input length must be even")

  let ~buffer = ByteBuffer::with_capacity(source_len / 2)
  var index = 0
  while index < source_len do:
    let high = hex_ascii_to_digit(source.at(index))
    let low = hex_ascii_to_digit(source.at(index + 1))

    match(high)
      Some<i32> { value: high_value }:
        match(low)
          Some<i32> { value: low_value }:
            buffer.push(high_value * 16 + low_value)
          None:
            return decode_error("hex input contains invalid characters")
      None:
        return decode_error("hex input contains invalid characters")
    index = index + 2

  Ok<Bytes> { value: buffer.as_bytes() }

fn decode_error<T>(message: String) -> Result<T, DecodeError>
  Err<DecodeError> { error: DecodeError { message: message } }

fn hex_ascii_to_digit(value: i32) -> Option<i32>
  if value >= 48 and value <= 57:
    return Some<i32> { value: value - 48 }
  if value >= 65 and value <= 70:
    return Some<i32> { value: value - 55 }
  if value >= 97 and value <= 102:
    return Some<i32> { value: value - 87 }
  None {}

fn hex_digit_to_ascii(value: i32) -> i32
  if value <= 9:
    return 48 + value
  97 + (value - 10)
