use std::array::Array
use std::fixed_array::fns::{ new_fixed_array }
use std::optional::types::all
use std::string::fns::all
use std::string::types::all
use std::subscript::{ SubscriptRead, SubscriptWrite }
use std::test::assertions::all

pub obj MapEntry<T> {
  api key: String,
  api value: T
}

pub obj Map<T> {
  buckets: FixedArray<Array<MapEntry<T>>>,
  count: i32
}

obj BucketSetResult<T> {
  api bucket: Array<MapEntry<T>>,
  api inserted: bool
}

obj BucketDeleteResult<T> {
  api bucket: Array<MapEntry<T>>,
  api deleted: bool
}

obj EachStats {
  count: i32,
  sum: i32,
  has_a: bool
}

pub fn new_map<T>(): () -> Map<T>
  Map<T>::new()

impl<T> Map<T>
  api fn new(): () -> Map<T>
    let buckets = new_buckets<T>(16)
    Map<T> { buckets: buckets, count: 0 }

  api fn with_capacity(capacity: i32): () -> Map<T>
    let target = if capacity > 0 then: capacity else: 0
    let min_bucket_count = 16
    let desired_bucket_count = next_power_of_two(target * 2)
    let bucket_count =
      if desired_bucket_count > min_bucket_count then:
        desired_bucket_count
      else:
        min_bucket_count

    let buckets = new_buckets<T>(bucket_count)
    Map<T> { buckets: buckets, count: 0 }

  api fn size(self): () -> i32
    self.count

  api fn empty(self): () -> bool
    self.count == 0

  api fn has(self, key: String): () -> bool
    if self.count == 0 then:
      return false

    let bucket_count = __array_len(self.buckets)
    let bucket_index = bucket_index_for_key(bucket_count, key)
    let bucket = __array_get(self.buckets, bucket_index)
    find_entry_index_in_bucket(bucket, key) >= 0

  api fn get(self, key: String): () -> Optional<T>
    if self.count == 0 then:
      return None {}

    let bucket_count = __array_len(self.buckets)
    let bucket_index = bucket_index_for_key(bucket_count, key)
    let bucket = __array_get(self.buckets, bucket_index)
    let entry_index = find_entry_index_in_bucket(bucket, key)
    if entry_index < 0 then:
      return None {}

    let entry = __array_get(bucket.raw_storage(), entry_index)
    Some<T> { value: entry.value }

  api fn get_or(self, key: String, default: T): () -> T
    match(self.get(key))
      Some<T> { value }:
        value
      None:
        default

  api fn get_or_else(self, key: String, default: () -> T): () -> T
    match(self.get(key))
      Some<T> { value }:
        value
      None:
        default()

  api fn set(self, key: String, value: T): () -> Map<T>
    let bucket_count = __array_len(self.buckets)
    let bucket_index = bucket_index_for_key(bucket_count, key)
    let bucket = __array_get(self.buckets, bucket_index)
    let result = set_in_bucket(bucket, key, value)

    __array_set(self.buckets, bucket_index, result.bucket)
    let count = if result.inserted then: self.count + 1 else: self.count
    let next = Map<T> { buckets: self.buckets, count: count }
    maybe_grow(next)

  api fn delete(self, key: String): () -> Map<T>
    if self.count == 0 then:
      return self

    let bucket_count = __array_len(self.buckets)
    let bucket_index = bucket_index_for_key(bucket_count, key)
    let bucket = __array_get(self.buckets, bucket_index)
    let result = delete_from_bucket(bucket, key)
    if result.deleted then:
      __array_set(self.buckets, bucket_index, result.bucket)
      return Map<T> { buckets: self.buckets, count: self.count - 1 }
    self

  api fn clear(self): () -> Map<T>
    if self.count == 0 then:
      return self

    let bucket_count = __array_len(self.buckets)
    let buckets = new_buckets<T>(bucket_count)
    Map<T> { buckets: buckets, count: 0 }

  api fn entries(self): () -> Array<MapEntry<T>>
    if self.count == 0 then:
      return Array<MapEntry<T>>::with_capacity(0)

    var out = Array<MapEntry<T>>::with_capacity(self.count)
    let bucket_count = __array_len(self.buckets)
    var bucket_index = 0
    while bucket_index < bucket_count do:
      let bucket = __array_get(self.buckets, bucket_index)
      out = out.extended(bucket)
      bucket_index = bucket_index + 1
    out

  api fn keys(self): () -> Array<String>
    if self.count == 0 then:
      return Array<String>::with_capacity(0)

    let ~out = Array<String>::with_capacity(self.count)
    let bucket_count = __array_len(self.buckets)
    var bucket_index = 0
    while bucket_index < bucket_count do:
      let bucket = __array_get(self.buckets, bucket_index)
      let storage = bucket.raw_storage()
      let len = bucket.length()
      var index = 0
      while index < len do:
        let entry = __array_get(storage, index)
        out.push(entry.key)
        index = index + 1
      bucket_index = bucket_index + 1
    out

  api fn values(self): () -> Array<T>
    if self.count == 0 then:
      return Array<T>::with_capacity(0)

    let ~out = Array<T>::with_capacity(self.count)
    let bucket_count = __array_len(self.buckets)
    var bucket_index = 0
    while bucket_index < bucket_count do:
      let bucket = __array_get(self.buckets, bucket_index)
      let storage = bucket.raw_storage()
      let len = bucket.length()
      var index = 0
      while index < len do:
        let entry = __array_get(storage, index)
        out.push(entry.value)
        index = index + 1
      bucket_index = bucket_index + 1
    out

  api fn each(self, f: (key: String, value: T) -> void): () -> void
    if self.count == 0 then:
      return void

    let bucket_count = __array_len(self.buckets)
    var bucket_index = 0
    while bucket_index < bucket_count do:
      let bucket = __array_get(self.buckets, bucket_index)
      let storage = bucket.raw_storage()
      let len = bucket.length()
      var index = 0
      while index < len do:
        let entry = __array_get(storage, index)
        f(entry.key, entry.value)
        index = index + 1
      bucket_index = bucket_index + 1

  api fn merge(self, other: Map<T>): () -> Map<T>
    if other.count == 0 then:
      return self

    var out = self
    let bucket_count = __array_len(other.buckets)
    var bucket_index = 0
    while bucket_index < bucket_count do:
      let bucket = __array_get(other.buckets, bucket_index)
      let storage = bucket.raw_storage()
      let len = bucket.length()
      var index = 0
      while index < len do:
        let entry = __array_get(storage, index)
        out = out.set(entry.key, entry.value)
        index = index + 1
      bucket_index = bucket_index + 1
    out

  api fn map_values<U>(self, f: (value: T) -> U): () -> Map<U>
    if self.count == 0 then:
      return Map<U>::new()

    var out = Map<U>::with_capacity(self.count)
    let bucket_count = __array_len(self.buckets)
    var bucket_index = 0
    while bucket_index < bucket_count do:
      let bucket = __array_get(self.buckets, bucket_index)
      let storage = bucket.raw_storage()
      let len = bucket.length()
      var index = 0
      while index < len do:
        let entry = __array_get(storage, index)
        out = out.set(entry.key, f(entry.value))
        index = index + 1
      bucket_index = bucket_index + 1
    out

  api fn filter(self, pred: (key: String, value: T) -> bool): () -> Map<T>
    if self.count == 0 then:
      return self

    var out = Map<T>::with_capacity(self.count)
    let bucket_count = __array_len(self.buckets)
    var bucket_index = 0
    while bucket_index < bucket_count do:
      let bucket = __array_get(self.buckets, bucket_index)
      let storage = bucket.raw_storage()
      let len = bucket.length()
      var index = 0
      while index < len do:
        let entry = __array_get(storage, index)
        if pred(entry.key, entry.value) then:
          out = out.set(entry.key, entry.value)
        index = index + 1
      bucket_index = bucket_index + 1
    out

impl<T> SubscriptRead<String, Optional<T>> for Map<T>
  api fn subscript_get(self, key: String) -> Optional<T>
    self.get(key)

impl<T> SubscriptWrite<String, T> for Map<T>
  api fn subscript_set(~self, key: String, value: T) -> void
    let next = self.set(key, value)
    self.buckets = next.buckets
    self.count = next.count

fn new_buckets<T>(bucket_count: i32) -> FixedArray<Array<MapEntry<T>>>
  let safe_bucket_count = if bucket_count > 0 then: bucket_count else: 1
  let buckets = new_fixed_array<Array<MapEntry<T>>>(safe_bucket_count)
  var index = 0
  while index < safe_bucket_count do:
    __array_set(buckets, index, Array<MapEntry<T>>::new())
    index = index + 1
  buckets

fn maybe_grow<T>(map: Map<T>) -> Map<T>
  let bucket_count = __array_len(map.buckets)
  if should_grow(map.count, bucket_count) then:
    let next_bucket_count = bucket_count * 2
    return rehash_to_bucket_count(map, next_bucket_count)
  map

fn should_grow(count: i32, bucket_count: i32) -> bool
  if bucket_count <= 0 then:
    return true
  (count * 4) > (bucket_count * 3)

fn rehash_to_bucket_count<T>(map: Map<T>, bucket_count: i32) -> Map<T>
  let next_bucket_count = if bucket_count > 0 then: bucket_count else: 1
  let next_buckets = new_buckets<T>(next_bucket_count)

  let previous_bucket_count = __array_len(map.buckets)
  var bucket_index = 0
  while bucket_index < previous_bucket_count do:
    let bucket = __array_get(map.buckets, bucket_index)
    insert_bucket_entries(next_buckets, next_bucket_count, bucket)
    bucket_index = bucket_index + 1

  Map<T> { buckets: next_buckets, count: map.count }

fn insert_bucket_entries<T>(
  buckets: FixedArray<Array<MapEntry<T>>>,
  bucket_count: i32,
  bucket: Array<MapEntry<T>>
) -> void
  let storage = bucket.raw_storage()
  let len = bucket.length()
  var index = 0
  while index < len do:
    let entry = __array_get(storage, index)
    insert_entry(buckets, bucket_count, entry)
    index = index + 1

fn insert_entry<T>(
  buckets: FixedArray<Array<MapEntry<T>>>,
  bucket_count: i32,
  entry: MapEntry<T>
) -> FixedArray<Array<MapEntry<T>>>
  let bucket_index = bucket_index_for_key(bucket_count, entry.key)
  let bucket = __array_get(buckets, bucket_index)
  let next_bucket = bucket.pushed(entry)
  __array_set(buckets, bucket_index, next_bucket)

fn find_entry_index_in_bucket<T>(bucket: Array<MapEntry<T>>, key: String) -> i32
  let storage = bucket.raw_storage()
  let len = bucket.length()
  var index = 0
  while index < len do:
    let entry = __array_get(storage, index)
    if entry.key.equals(key) then:
      return index
    index = index + 1
  -1

fn set_in_bucket<T>(bucket: Array<MapEntry<T>>, key: String, value: T) -> BucketSetResult<T>
  let index = find_entry_index_in_bucket(bucket, key)
  let entry = MapEntry<T> { key: key, value: value }

  if index < 0 then:
    let next_bucket = bucket.pushed(entry)
    return BucketSetResult<T> { bucket: next_bucket, inserted: true }

  let ~next_bucket = bucket.copied()
  next_bucket.replace(index, with: entry)
  BucketSetResult<T> { bucket: next_bucket, inserted: false }

fn delete_from_bucket<T>(bucket: Array<MapEntry<T>>, key: String) -> BucketDeleteResult<T>
  let index = find_entry_index_in_bucket(bucket, key)
  if index < 0 then:
    return BucketDeleteResult<T> { bucket: bucket, deleted: false }

  let next_bucket = bucket.removed(index)
  BucketDeleteResult<T> { bucket: next_bucket, deleted: true }

fn bucket_index_for_key(bucket_count: i32, key: String) -> i32
  let safe_bucket_count = if bucket_count > 0 then: bucket_count else: 1
  mod_i32(key.hash_i32(), safe_bucket_count)

fn mod_i32(value: i32, modulus: i32) -> i32
  if modulus <= 0 then:
    return 0

  let div = value / modulus
  let rem = value - div * modulus
  if rem < 0 then: rem + modulus else: rem

fn next_power_of_two(value: i32) -> i32
  let start = if value > 1 then: value else: 1
  var out = 1
  while out < start do:
    out = out * 2
  out

fn make_test_key(index: i32) -> String
  let a = index / 26
  let b = index - a * 26
  var bytes = new_fixed_array<i32>(2)
  bytes = __array_set(bytes, 0, 97 + a)
  bytes = __array_set(bytes, 1, 97 + b)
  new_string(bytes)

test "map new is empty":
  let map = Map<i32>::new()
  assert(map.size(), eq: 0)
  assert(map.empty(), eq: true)
  assert(map.has("missing"), eq: false)

  let missing = map.get("missing")
  match(missing)
    Some<i32>:
      assert(false)
    None:
      assert(true)

test "map set and get roundtrip":
  var map = Map<i32>::new()
  map = map.set("a", 1)
  map = map.set("b", 2)
  assert(map.size(), eq: 2)
  assert(map.has("a"), eq: true)

  match(map.get("b"))
    Some<i32> { value }:
      assert(value, eq: 2)
    None:
      assert(false)

test "map subscript read and write":
  let ~map = Map<i32>::new()
  map["a"] = 1
  map["b"] = 3

  match(map["a"])
    Some<i32> { value }:
      assert(value, eq: 1)
    None:
      assert(false)

  match(map["b"])
    Some<i32> { value }:
      assert(value, eq: 3)
    None:
      assert(false)

test "map set overwrites without growing size":
  var map = Map<i32>::new()
  map = map.set("a", 1)
  map = map.set("a", 9)
  assert(map.size(), eq: 1)
  match(map.get("a"))
    Some<i32> { value }:
      assert(value, eq: 9)
    None:
      assert(false)

test "map delete removes key":
  var map = Map<i32>::new()
  map = map.set("a", 1)
  assert(map.size(), eq: 1)
  map = map.delete("a")
  assert(map.size(), eq: 0)
  assert(map.has("a"), eq: false)

test "map clear removes all entries":
  var map = Map<i32>::new()
  map = map.set("a", 1)
  map = map.set("b", 2)
  map = map.clear()
  assert(map.size(), eq: 0)
  assert(map.has("a"), eq: false)

test "map entries keys and values match size":
  var map = Map<i32>::new()
  map = map.set("a", 1)
  map = map.set("b", 2)
  map = map.set("c", 3)

  let keys = map.keys()
  let values = map.values()
  let entries = map.entries()
  assert(keys.length(), eq: 3)
  assert(values.length(), eq: 3)
  assert(entries.length(), eq: 3)

  assert(map.has("a"), eq: true)
  assert(values.contains(2), eq: true)

test "map get_or and get_or_else":
  var map = Map<i32>::new()
  map = map.set("a", 4)
  assert(map.get_or("a", 0), eq: 4)
  assert(map.get_or("missing", 9), eq: 9)
  assert(map.get_or_else("missing", () -> i32 => 11), eq: 11)

test "map with_capacity supports inserts":
  var map = Map<i32>::with_capacity(40)
  var index = 0
  while index < 40 do:
    map = map.set(make_test_key(index), index)
    index = index + 1
  assert(map.size(), eq: 40)
  assert(map.get_or(make_test_key(10), -1), eq: 10)

test "map each visits all entries":
  var map = Map<i32>::new()
  map = map.set("a", 1)
  map = map.set("b", 2)
  map = map.set("c", 3)
  let ~stats = EachStats { count: 0, sum: 0, has_a: false }
  map.each((key: String, value: i32) -> void =>
    stats.count = stats.count + 1
    stats.sum = stats.sum + value
    if key.equals("a") then:
      stats.has_a = true
    void
  )
  assert(stats.count, eq: map.size())
  assert(stats.sum, eq: 6)
  assert(stats.has_a, eq: true)

test "map merge overwrites keys":
  var a = Map<i32>::new()
  a = a.set("k1", 1)
  a = a.set("k2", 2)
  var b = Map<i32>::new()
  b = b.set("k2", 9)
  b = b.set("k3", 3)
  let merged = a.merge(b)
  assert(merged.size(), eq: 3)
  assert(merged.get_or("k1", -1), eq: 1)
  assert(merged.get_or("k2", -1), eq: 9)
  assert(merged.get_or("k3", -1), eq: 3)

test "map map_values transforms values":
  var map = Map<i32>::new()
  map = map.set("a", 2)
  map = map.set("b", 4)
  let doubled = map.map_values<i32>((v: i32) -> i32 => v * 2)
  assert(doubled.size(), eq: 2)
  assert(doubled.get_or("a", -1), eq: 4)
  assert(doubled.get_or("b", -1), eq: 8)

test "map filter removes entries":
  var map = Map<i32>::new()
  map = map.set("a", 1)
  map = map.set("b", 2)
  map = map.set("c", 3)
  let filtered = map.filter((_k: String, v: i32) -> bool => v >= 2)
  assert(filtered.size(), eq: 2)
  assert(filtered.has("a"), eq: false)
  assert(filtered.has("b"), eq: true)
  assert(filtered.has("c"), eq: true)

test "map grows and preserves entries":
  var map = Map<i32>::new()
  var index = 0
  while index < 80 do:
    map = map.set(make_test_key(index), index)
    index = index + 1
  assert(map.size(), eq: 80)
  assert(map.get_or(make_test_key(0), -1), eq: 0)
  assert(map.get_or(make_test_key(50), -1), eq: 50)
  assert(map.get_or(make_test_key(79), -1), eq: 79)

test "map handles bucket collisions":
  let bucket_count = 16
  var found = false
  var key1 = make_test_key(0)
  var key2 = make_test_key(1)
  var a = 0
  while a < 200 do:
    let candidate1 = make_test_key(a)
    let index1 = bucket_index_for_key(bucket_count, candidate1)
    var b = a + 1
    while b < 200 do:
      let candidate2 = make_test_key(b)
      let index2 = bucket_index_for_key(bucket_count, candidate2)
      if index1 == index2 then:
        key1 = candidate1
        key2 = candidate2
        found = true
        b = 200
      else:
        b = b + 1
    if found then:
      a = 200
    else:
      a = a + 1

  assert(found, eq: true)
  var map = Map<i32>::new()
  map = map.set(key1, 1)
  map = map.set(key2, 2)
  assert(map.size(), eq: 2)
  assert(map.get_or(key1, 0), eq: 1)
  assert(map.get_or(key2, 0), eq: 2)
