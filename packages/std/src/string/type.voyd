use std::array::{ Array, new_array_unchecked }
use std::fixed_array::fns::{ new_fixed_array }
use std::string::index::{ make_string_index }
use std::traits::sequence::all
use std::optional::all
use std::result::types::all
use std::subscript::{ Range }

pub use std::string::errors::{ ParseFloatError, ParseIntError, Utf8Error }
pub use std::string::index::StringIndex

pub obj String {
  bytes: Array<i32>,
  byte_count: i32
}

pub obj StringSlice {
  source: String,
  start: i32,
  byte_count: i32
}

pub type CharSet = Array<i32>

impl StringSlice
  api fn byte_len(self) -> i32
    self.byte_count

  api fn is_empty(self) -> bool
    self.byte_count == 0

  api fn to_string(self) -> String
    self.source.slice_bytes(self.start, self.byte_count)

impl String
  api fn init() -> String
    empty_string()

  api fn with_capacity({ bytes _capacity: i32 }) -> String
    let capacity = if _capacity > 0 then: _capacity else: 0
    String { bytes: Array<i32>::with_capacity(capacity), byte_count: 0 }

  api fn from_utf8({ bytes source: Array<i32> }) -> Result<String, Utf8Error>
    from_utf8(bytes: source)

  api fn byte_len(self): () -> i32
    self.byte_count

  api fn rune_len(self): () -> i32
    var index = 0
    var count = 0
    let source = self.bytes.raw_storage()
    while index < self.byte_count do:
      let read = decode_utf8_at(source, self.byte_count, index)
      count = count + 1
      index = index + read.width
    count

  api fn grapheme_len(self) -> i32
    let source = self.raw_bytes()
    var index = 0
    var count = 0
    while index < self.byte_count do:
      index = next_grapheme_boundary(source, self.byte_count, index)
      count = count + 1
    count

  api fn is_empty(self) -> bool
    self.byte_count == 0

  api fn to_utf8(self): () -> Array<i32>
    match(Array<i32>::from(self.raw_bytes()))
      Some<Array<i32>> { value }:
        value
      None:
        Array<i32>::init()

  api fn as_slice(self): () -> StringSlice
    new_string_slice(self, 0, self.byte_count)

  api fn start_index(self): () -> StringIndex
    make_string_index(0)

  api fn end_index(self): () -> StringIndex
    make_string_index(self.byte_count)

  api fn slice(self, { range: Range }) -> StringSlice
    let source = self.raw_bytes()
    let start = clamp_index_to_rune_boundary(source, self.byte_count, normalize_range_start(range, self.byte_count))
    let end =
      clamp_index_to_rune_boundary(
        source,
        self.byte_count,
        normalize_range_end_exclusive(range, self.byte_count)
      )
    if start >= end then:
      return new_string_slice(self, 0, 0)
    new_string_slice(self, start, end - start)

  api fn index(self, { after cursor: StringIndex, by steps?: i32 }) -> Option<StringIndex>
    let delta = steps ?? 1
    advance_rune_index(self, cursor.to_i32(), delta)

  api fn grapheme_index(self, { after cursor: StringIndex, by steps?: i32 }) -> Option<StringIndex>
    let delta = steps ?? 1
    advance_grapheme_index(self, cursor.to_i32(), delta)

  api fn graphemes(self) -> StringGraphemeSequence
    StringGraphemeSequence { source: self }

  api fn byte_at(self, { at index: i32 }) -> Option<i32>
    if index < 0 then:
      return None {}
    match(self.bytes.get(index))
      Some { value }:
        Some<i32> { value }
      None:
        None {}

  api fn raw_bytes(self): () -> FixedArray<i32>
    self.bytes.raw_storage()

  api fn equals(self, other: String): () -> bool
    if self.byte_count != other.byte_count then:
      return false
    if self.byte_count == 0 then:
      return true

    let self_source = self.bytes.raw_storage()
    let other_source = other.bytes.raw_storage()
    var index = 0
    while index < self.byte_count do:
      if __array_get(self_source, index) != __array_get(other_source, index) then:
        return false
      index = index + 1
    true

  api fn '=='(self, other: String) -> bool
    self.equals(other)

  api fn hash_i32(self): () -> i32
    let source = self.bytes.raw_storage()
    var index = 0
    var hash = 0
    while index < self.byte_count do:
      hash = hash * 31 + __array_get(source, index)
      index = index + 1
    hash

  api fn rune_at(self, { index: i32 }) -> Option<i32>
    if index < 0 then:
      return None {}

    var byte_index = 0
    var rune_index = 0
    let source = self.bytes.raw_storage()
    while byte_index < self.byte_count do:
      let read = decode_utf8_at(source, self.byte_count, byte_index)
      if rune_index == index then:
        return Some<i32> { value: read.codepoint }
      rune_index = rune_index + 1
      byte_index = byte_index + read.width
    None {}

  api fn slice_bytes(self, start: i32, len: i32): () -> String
    if len <= 0 then:
      return empty_string()

    let clamped_start = if start < 0 then: 0 else: start
    if clamped_start >= self.byte_count then:
      return empty_string()

    let raw_end = clamped_start + len
    let end = if raw_end > self.byte_count then: self.byte_count else: raw_end
    let slice_len = end - clamped_start
    if slice_len <= 0 then:
      return empty_string()

    let source = self.bytes.raw_storage()
    let storage = new_fixed_array<i32>(slice_len)
    __array_copy(storage, {
      from: source,
      to_index: 0,
      from_index: clamped_start,
      count: slice_len
    })
    new_string(storage)

  api fn slice_runes(self, start: i32, len: i32): () -> String
    if len <= 0 then:
      return empty_string()
    if start < 0 then:
      return empty_string()

    let target_end = start + len
    var byte_index = 0
    var rune_index = 0
    var slice_start = -1
    var slice_end = -1
    let source = self.bytes.raw_storage()
    while byte_index < self.byte_count do:
      if rune_index == start then:
        slice_start = byte_index
      if rune_index == target_end then:
        slice_end = byte_index
        break

      let read = decode_utf8_at(source, self.byte_count, byte_index)
      byte_index = byte_index + read.width
      rune_index = rune_index + 1

    if slice_start < 0 then:
      return empty_string()

    let final_end = if slice_end < 0 then: byte_index else: slice_end
    let slice_len = final_end - slice_start
    if slice_len <= 0 then:
      return empty_string()

    let storage = new_fixed_array<i32>(slice_len)
    __array_copy(storage, {
      from: source,
      to_index: 0,
      from_index: slice_start,
      count: slice_len
    })
    new_string(storage)

  api fn find_rune(self, { rune: i32, from?: StringIndex }) -> Option<StringIndex>
    if rune < 0 then:
      return None {}
    if rune > 1114111 then:
      return None {}

    let start = from ?? self.start_index()
    let index = start.to_i32()
    if index < 0 or index > self.byte_count then:
      return None {}
    if not is_rune_boundary(self.raw_bytes(), self.byte_len(), index) then:
      return None {}

    let source = self.bytes.raw_storage()
    var cursor = index
    while cursor < self.byte_count do:
      let read = decode_utf8_at(source, self.byte_count, cursor)
      if read.codepoint == rune then:
        return Some<StringIndex> { value: make_string_index(cursor) }
      cursor = cursor + read.width
    None {}

  api fn starts_with(self, { prefix: StringSlice }) -> bool
    if prefix.byte_len() > self.byte_count then:
      return false
    bytes_match_slice_at(self.raw_bytes(), prefix, 0)

  api fn starts_with(self, { prefix: String }) -> bool
    self.starts_with(prefix: prefix.as_slice())

  api fn ends_with(self, { suffix: StringSlice }) -> bool
    let suffix_len = suffix.byte_len()
    if suffix_len > self.byte_count then:
      return false
    let start = self.byte_count - suffix_len
    bytes_match_slice_at(self.raw_bytes(), suffix, start)

  api fn ends_with(self, { suffix: String }) -> bool
    self.ends_with(suffix: suffix.as_slice())

  api fn contains(self, { substring: StringSlice }) -> bool
    match(self.find(substring: substring))
      Some<StringIndex>:
        true
      None:
        false

  api fn contains(self, { substring: String }) -> bool
    self.contains(substring: substring.as_slice())

  api fn contains(self, { where pred: (rune: i32) -> bool }) -> bool
    let source = self.raw_bytes()
    var index = 0
    while index < self.byte_count do:
      let read = decode_utf8_at(source, self.byte_count, index)
      if pred(read.codepoint) then:
        return true
      index = index + read.width
    false

  api fn find(self, { substring: StringSlice, from?: StringIndex }) -> Option<StringIndex>
    let start = from ?? self.start_index()
    let start_value = start.to_i32()
    if not is_rune_boundary(self.raw_bytes(), self.byte_len(), start_value) then:
      return None {}
    let match_index = find_substring_from(self, substring, start_value)
    if match_index < 0 then:
      return None {}
    Some<StringIndex> { value: make_string_index(match_index) }

  api fn find(self, { substring: String, from?: StringIndex }) -> Option<StringIndex>
    self.find(substring: substring.as_slice(), from: from)

  api fn rfind(self, { substring: StringSlice, to?: StringIndex }) -> Option<StringIndex>
    let end = to ?? self.end_index()
    let end_value = end.to_i32()
    if not is_rune_boundary(self.raw_bytes(), self.byte_len(), end_value) then:
      return None {}
    let match_index = find_substring_to(self, substring, end_value)
    if match_index < 0 then:
      return None {}
    Some<StringIndex> { value: make_string_index(match_index) }

  api fn rfind(self, { substring: String, to?: StringIndex }) -> Option<StringIndex>
    self.rfind(substring: substring.as_slice(), to: to)

  api fn find_range(self, { substring: StringSlice, from?: StringIndex }) -> Option<Range>
    let start = from ?? self.start_index()
    let start_value = start.to_i32()
    if not is_rune_boundary(self.raw_bytes(), self.byte_len(), start_value) then:
      return None {}
    let match_index = find_substring_from(self, substring, start_value)
    if match_index < 0 then:
      return None {}

    let end = match_index + substring.byte_len()
    Some<Range> {
      value: Range {
        start: Some<i32> { value: match_index },
        end: Some<i32> { value: end },
        include_end: false
      }
    }

  api fn find_range(self, { substring: String, from?: StringIndex }) -> Option<Range>
    self.find_range(substring: substring.as_slice(), from: from)

  api fn split_once(self, { on separator: i32 }): () -> Option<(String, String)>
    let match_index = self.find_rune(rune: separator)
    var separator_index = 0
    match(match_index)
      Some<StringIndex> { value }:
        separator_index = value.to_i32()
      None:
        return None {}

    let source = self.bytes.raw_storage()
    let separator_read = decode_utf8_at(source, self.byte_count, separator_index)
    let left = self.slice_bytes(0, separator_index)
    let right_start = separator_index + separator_read.width
    let right = self.slice_bytes(right_start, self.byte_count - right_start)
    Some { value: (left, right) }

  api fn split(
    self,
    { on separator: i32, max_splits?: i32, keep_empty?: bool }
  ) -> Array<StringSlice>
    self.split(where: (r: i32) -> bool => r == separator, max_splits: max_splits, keep_empty: keep_empty)

  api fn split(
    self,
    { on separator: StringSlice, max_splits?: i32, keep_empty?: bool }
  ) -> Array<StringSlice>
    split_on_substring(self, separator, max_splits: max_splits, keep_empty: keep_empty)

  api fn split(
    self,
    { on separator: String, max_splits?: i32, keep_empty?: bool }
  ) -> Array<StringSlice>
    split_on_substring(
      self,
      separator.as_slice(),
      max_splits: max_splits,
      keep_empty: keep_empty
    )

  api fn split(
    self,
    { where pred: (rune: i32) -> bool, max_splits?: i32, keep_empty?: bool }
  ) -> Array<StringSlice>
    let allow_empty = keep_empty ?? false
    let limit = max_splits ?? -1
    let source = self.raw_bytes()
    let ~parts = Array<StringSlice>::with_capacity(4)
    var start = 0
    var index = 0
    var splits = 0
    while index < self.byte_count do:
      let read = decode_utf8_at(source, self.byte_count, index)
      let can_split = limit < 0 or splits < limit
      if can_split and pred(read.codepoint) then:
        let length = index - start
        if allow_empty or length > 0 then:
          parts.push(new_string_slice(self, start, length))
        start = index + read.width
        splits = splits + 1
      index = index + read.width

    let tail_len = self.byte_count - start
    if allow_empty or tail_len > 0 then:
      parts.push(new_string_slice(self, start, tail_len))
    parts

  api fn lines(self, { keep_ends?: bool }) -> Array<StringSlice>
    let include_ends = keep_ends ?? false
    let source = self.raw_bytes()
    let ~parts = Array<StringSlice>::with_capacity(4)
    var start = 0
    var index = 0
    while index < self.byte_count do:
      let read = decode_utf8_at(source, self.byte_count, index)
      if read.codepoint == 10 then:
        let boundary = if include_ends then: index + read.width else: index
        parts.push(new_string_slice(self, start, boundary - start))
        start = index + read.width
      index = index + read.width

    if start < self.byte_count then:
      parts.push(new_string_slice(self, start, self.byte_count - start))
    elif: self.byte_count == 0 then:
      parts.push(new_string_slice(self, 0, 0))
    parts

  api fn words(self) -> Array<StringSlice>
    let source = self.raw_bytes()
    let ~parts = Array<StringSlice>::with_capacity(4)
    var start = -1
    var index = 0
    while index < self.byte_count do:
      let read = decode_utf8_at(source, self.byte_count, index)
      if is_whitespace_rune(read.codepoint) then:
        if start >= 0 then:
          parts.push(new_string_slice(self, start, index - start))
          start = -1
      else:
        if start < 0 then:
          start = index
      index = index + read.width

    if start >= 0 then:
      parts.push(new_string_slice(self, start, self.byte_count - start))
    parts

  api fn trimmed(self): () -> String
    self.trimmed(chars: whitespace_charset())

  api fn trimmed(self, { chars: CharSet }) -> String
    if self.byte_count == 0 then:
      return self

    let source = self.raw_bytes()
    var start = 0
    while start < self.byte_count do:
      let read = decode_utf8_at(source, self.byte_count, start)
      if not rune_in_charset(chars, read.codepoint) then:
        break
      start = start + read.width

    if start >= self.byte_count then:
      return empty_string()

    var end = self.byte_count
    while end > start do:
      let prev = previous_rune_boundary(source, end)
      let read = decode_utf8_at(source, self.byte_count, prev)
      if not rune_in_charset(chars, read.codepoint) then:
        break
      end = prev

    self.slice_bytes(start, end - start)

  api fn trim(~self) -> void
    let next = self.trimmed()
    self.bytes = next.bytes
    self.byte_count = next.byte_count

  api fn trim(~self, { chars: CharSet }) -> void
    let next = self.trimmed(chars: chars)
    self.bytes = next.bytes
    self.byte_count = next.byte_count

  api fn lowered(self): () -> String
    if self.byte_count == 0 then:
      return self

    let source = self.bytes.raw_storage()
    let out = new_fixed_array<i32>(self.byte_count)
    var index = 0
    while index < self.byte_count do:
      __array_set(out, index, to_ascii_lower(__array_get(source, index)))
      index = index + 1
    new_string(out)

  api fn lower(~self) -> void
    let next = self.lowered()
    self.bytes = next.bytes
    self.byte_count = next.byte_count

  api fn uppered(self): () -> String
    if self.byte_count == 0 then:
      return self

    let source = self.bytes.raw_storage()
    let out = new_fixed_array<i32>(self.byte_count)
    var index = 0
    while index < self.byte_count do:
      __array_set(out, index, to_ascii_upper(__array_get(source, index)))
      index = index + 1
    new_string(out)

  api fn upper(~self) -> void
    let next = self.uppered()
    self.bytes = next.bytes
    self.byte_count = next.byte_count

  api fn replaced(
    self,
    { old: String, with replacement: String, max_replacements?: i32 }
  ): () -> String
    if old.byte_count <= 0 then:
      return self
    if self.byte_count == 0 then:
      return self

    let source = self.bytes.raw_storage()
    let old_source = old.raw_bytes()
    let replacement_source = replacement.raw_bytes()
    let ~out = Array<i32>::with_capacity(self.byte_count)
    var index = 0
    var replacement_count = 0
    while index < self.byte_count do:
      let has_capacity = (index + old.byte_count) <= self.byte_count
      let can_replace_more = match(max_replacements)
        Some<i32> { value }:
          replacement_count < value
        None:
          true

      if has_capacity and can_replace_more and bytes_match_at(source, old_source, index, old.byte_count) then:
        append_bytes(out, replacement_source, replacement.byte_count)
        index = index + old.byte_count
        replacement_count = replacement_count + 1
      else:
        out.push(__array_get(source, index))
        index = index + 1
    new_string(out.to_fixed_array())

  api fn replace(
    ~self,
    { old: String, with replacement: String, max_replacements?: i32 }
  ) -> void
    let next = self.replaced(old: old, with: replacement, max_replacements: max_replacements)
    self.bytes = next.bytes
    self.byte_count = next.byte_count

  api fn repeat(self, { count: i32 }) -> String
    if count <= 0 then:
      return empty_string()
    if self.byte_count == 0 then:
      return self

    let capacity = self.byte_count * count
    let ~out = Array<i32>::with_capacity(capacity)
    let source = self.raw_bytes()
    var times = 0
    while times < count do:
      append_bytes(out, source, self.byte_count)
      times = times + 1
    new_string(out.to_fixed_array())

  api fn pad_left(self, { width: i32, with?: i32 }) -> String
    let pad_rune = with ?? 32
    let needed = width - self.rune_len()
    if needed <= 0 then:
      return self

    let ~bytes = Array<i32>::with_capacity(self.byte_count + needed * 4)
    var index = 0
    while index < needed do:
      append_codepoint_mut(bytes, pad_rune)
      index = index + 1
    append_bytes(bytes, self.raw_bytes(), self.byte_count)
    new_string(bytes.to_fixed_array())

  api fn pad_right(self, { width: i32, with?: i32 }) -> String
    let pad_rune = with ?? 32
    let needed = width - self.rune_len()
    if needed <= 0 then:
      return self

    let ~bytes = Array<i32>::with_capacity(self.byte_count + needed * 4)
    append_bytes(bytes, self.raw_bytes(), self.byte_count)
    var index = 0
    while index < needed do:
      append_codepoint_mut(bytes, pad_rune)
      index = index + 1
    new_string(bytes.to_fixed_array())

  api fn parse_int(self, { radix?: i32 }): () -> Result<i32, ParseIntError>
    let base = match(radix)
      Some<i32> { value }:
        value
      None:
        10

    if base < 2 or base > 36 then:
      return Err<ParseIntError> { error: ParseIntError { code: 1 } }
    if self.byte_count == 0 then:
      return Err<ParseIntError> { error: ParseIntError { code: 2 } }

    let source = self.bytes.raw_storage()
    var index = 0
    var sign = 1
    let first = __array_get(source, 0)
    if first == 45 then:
      sign = -1
      index = 1
    elif: first == 43 then:
      index = 1

    if index >= self.byte_count then:
      return Err<ParseIntError> { error: ParseIntError { code: 2 } }

    let max_i32 = 2147483647
    let min_i32 = -2147483647 - 1
    var value = 0
    while index < self.byte_count do:
      let digit = parse_digit(__array_get(source, index))
      if digit < 0 or digit >= base then:
        return Err<ParseIntError> { error: ParseIntError { code: 3 } }

      if sign > 0 then:
        let max_before_mul = max_i32 / base
        if value > max_before_mul then:
          return Err<ParseIntError> { error: ParseIntError { code: 4 } }

        let next = value * base
        let max_allowed = max_i32 - digit
        if next > max_allowed then:
          return Err<ParseIntError> { error: ParseIntError { code: 4 } }
        value = next + digit
      else:
        let min_before_mul = min_i32 / base
        if value < min_before_mul then:
          return Err<ParseIntError> { error: ParseIntError { code: 4 } }

        let next = value * base
        let min_allowed = min_i32 + digit
        if next < min_allowed then:
          return Err<ParseIntError> { error: ParseIntError { code: 4 } }
        value = next - digit
      index = index + 1

    Ok<i32> { value }

  api fn parse_float(self): () -> Result<f64, ParseFloatError>
    if self.byte_count == 0 then:
      return Err<ParseFloatError> { error: ParseFloatError { code: 1 } }

    let source = self.raw_bytes()
    var index = 0
    var sign = 1.0
    let first = __array_get(source, 0)
    if first == 45 then:
      sign = -1.0
      index = 1
    elif: first == 43 then:
      index = 1

    if index >= self.byte_count then:
      return Err<ParseFloatError> { error: ParseFloatError { code: 1 } }

    var int_part = 0.0
    var saw_digit = false
    while index < self.byte_count do:
      let digit = parse_digit(__array_get(source, index))
      if digit < 0 or digit > 9 then:
        break
      int_part = int_part * 10.0 + digit_to_f64(digit)
      saw_digit = true
      index = index + 1

    var frac_part = 0.0
    var frac_scale = 1.0
    if index < self.byte_count and __array_get(source, index) == 46 then:
      index = index + 1
      while index < self.byte_count do:
        let digit = parse_digit(__array_get(source, index))
        if digit < 0 or digit > 9 then:
          break
        frac_part = frac_part * 10.0 + digit_to_f64(digit)
        frac_scale = frac_scale * 10.0
        saw_digit = true
        index = index + 1

    if not saw_digit then:
      return Err<ParseFloatError> { error: ParseFloatError { code: 1 } }

    var exponent = 0
    var exponent_sign = 1
    if index < self.byte_count then:
      let exp_marker = __array_get(source, index)
      if exp_marker == 101 or exp_marker == 69 then:
        index = index + 1
        if index >= self.byte_count then:
          return Err<ParseFloatError> { error: ParseFloatError { code: 1 } }

        let exp_sign_byte = __array_get(source, index)
        if exp_sign_byte == 45 then:
          exponent_sign = -1
          index = index + 1
        elif: exp_sign_byte == 43 then:
          index = index + 1

        if index >= self.byte_count then:
          return Err<ParseFloatError> { error: ParseFloatError { code: 1 } }

        var saw_exp_digit = false
        while index < self.byte_count do:
          let digit = parse_digit(__array_get(source, index))
          if digit < 0 or digit > 9 then:
            break
          exponent = exponent * 10 + digit
          saw_exp_digit = true
          index = index + 1

        if not saw_exp_digit then:
          return Err<ParseFloatError> { error: ParseFloatError { code: 1 } }

    if index != self.byte_count then:
      return Err<ParseFloatError> { error: ParseFloatError { code: 1 } }

    let base = int_part + frac_part / frac_scale
    let pow = pow10_i32(exponent_sign * exponent)
    Ok<f64> { value: sign * base * pow }

  api fn to_debug(self) -> String
    build_escaped(self, false)

  api fn to_repr(self) -> String
    build_escaped(self, true)

obj Utf8Read {
  api codepoint: i32,
  api width: i32
}

obj StringIterator {
  source: FixedArray<i32>,
  byte_count: i32,
  index: i32
}

obj StringGraphemeSequence {
  source: String
}

obj StringGraphemeIterator {
  source: String,
  index: i32
}

impl Sequence<i32> for String
  api fn iter(self) -> Iterator<i32>
    StringIterator {
      source: self.raw_bytes(),
      byte_count: self.byte_len(),
      index: 0
    }

impl Iterator<i32> for StringIterator
  api fn next(~self) -> Option<i32>
    if self.index >= self.byte_count then:
      return None {}
    let read = decode_utf8_at(self.source, self.byte_count, self.index)
    self.index = self.index + read.width
    Some<i32> { value: read.codepoint }

impl Sequence<StringSlice> for StringGraphemeSequence
  api fn iter(self) -> Iterator<StringSlice>
    StringGraphemeIterator { source: self.source, index: 0 }

impl Iterator<StringSlice> for StringGraphemeIterator
  api fn next(~self) -> Option<StringSlice>
    if self.index >= self.source.byte_len() then:
      return None {}
    let start = self.index
    self.index = next_grapheme_boundary(self.source.raw_bytes(), self.source.byte_len(), self.index)
    Some<StringSlice> { value: new_string_slice(self.source, start, self.index - start) }

fn decode_utf8_at(source: FixedArray<i32>, limit: i32, index: i32) -> Utf8Read
  if index < 0 then:
    return utf8_replacement()
  if index >= limit then:
    return utf8_replacement()

  let b0 = __array_get(source, index)
  if not is_byte(b0) then:
    return utf8_replacement()
  if b0 <= 127 then:
    return Utf8Read { codepoint: b0, width: 1 }

  if b0 >= 194 and b0 <= 223 then:
    let next_index = index + 1
    if next_index >= limit then:
      return utf8_replacement()
    let b1 = __array_get(source, next_index)
    if not is_continuation_byte(b1) then:
      return utf8_replacement()
    let codepoint = (b0 - 192) * 64 + (b1 - 128)
    return Utf8Read { codepoint: codepoint, width: 2 }

  if b0 >= 224 and b0 <= 239 then:
    let next_index = index + 1
    let next_index2 = index + 2
    if next_index2 >= limit then:
      return utf8_replacement()
    let b1 = __array_get(source, next_index)
    let b2 = __array_get(source, next_index2)
    if not valid_three_byte_lead(b0, b1, b2) then:
      return utf8_replacement()
    let codepoint = (b0 - 224) * 4096 + (b1 - 128) * 64 + (b2 - 128)
    return Utf8Read { codepoint: codepoint, width: 3 }

  if b0 >= 240 and b0 <= 244 then:
    let next_index = index + 1
    let next_index2 = index + 2
    let next_index3 = index + 3
    if next_index3 >= limit then:
      return utf8_replacement()
    let b1 = __array_get(source, next_index)
    let b2 = __array_get(source, next_index2)
    let b3 = __array_get(source, next_index3)
    if not valid_four_byte_lead(b0, b1, b2, b3) then:
      return utf8_replacement()
    let codepoint = (b0 - 240) * 262144 + (b1 - 128) * 4096 + (b2 - 128) * 64 + (b3 - 128)
    return Utf8Read { codepoint: codepoint, width: 4 }

  utf8_replacement()

fn is_byte(value: i32) -> bool
  value >= 0 and value <= 255

fn is_continuation_byte(value: i32) -> bool
  value >= 128 and value <= 191

fn valid_three_byte_lead(b0: i32, b1: i32, b2: i32) -> bool
  if not is_continuation_byte(b1) then:
    return false
  if not is_continuation_byte(b2) then:
    return false
  if b0 == 224 and b1 < 160 then:
    return false
  if b0 == 237 and b1 > 159 then:
    return false
  true

fn valid_four_byte_lead(b0: i32, b1: i32, b2: i32, b3: i32) -> bool
  if not is_continuation_byte(b1) then:
    return false
  if not is_continuation_byte(b2) then:
    return false
  if not is_continuation_byte(b3) then:
    return false
  if b0 == 240 and b1 < 144 then:
    return false
  if b0 == 244 and b1 > 143 then:
    return false
  true

fn whitespace_charset() -> CharSet
  [32, 9, 10, 13]

fn is_trim_byte(value: i32) -> bool
  value == 32 or value == 9 or value == 10 or value == 13

fn rune_in_charset(chars: CharSet, rune: i32) -> bool
  chars.contains(rune)

fn is_whitespace_rune(rune: i32) -> bool
  rune == 32 or rune == 9 or rune == 10 or rune == 13

fn normalize_range_start(range: Range, length: i32) -> i32
  match(range.start)
    Some<i32> { value }:
      clamp_slice_index(value, length)
    None:
      0

fn normalize_range_end_exclusive(range: Range, length: i32) -> i32
  match(range.end)
    Some<i32> { value }:
      let clamped = clamp_slice_index(value, length)
      if not range.include_end then:
        return clamped
      if clamped >= length then:
        return length
      clamped + 1
    None:
      length

fn clamp_slice_index(index: i32, length: i32) -> i32
  if index < 0 then:
    return 0
  if index > length then:
    return length
  index

fn new_string_slice(source: String, start: i32, len: i32) -> StringSlice
  let source_len = source.byte_len()
  let start_index = clamp_slice_index(start, source_len)
  let max_len = source_len - start_index
  let clamped_len =
    if len < 0 then:
      0
    elif: len > max_len then:
      max_len
    else:
      len
  StringSlice {
    source: source,
    start: start_index,
    byte_count: clamped_len
  }

fn advance_rune_index(value: String, cursor: i32, steps: i32) -> Option<StringIndex>
  if cursor < 0 or cursor > value.byte_len() then:
    return None {}
  let source = value.raw_bytes()
  if not is_rune_boundary(source, value.byte_len(), cursor) then:
    return None {}
  if steps == 0 then:
    return Some<StringIndex> { value: make_string_index(cursor) }

  var index = cursor
  if steps > 0 then:
    var moved = 0
    while moved < steps do:
      if index >= value.byte_len() then:
        return None {}
      let read = decode_utf8_at(source, value.byte_len(), index)
      index = index + read.width
      moved = moved + 1
    return Some<StringIndex> { value: make_string_index(index) }

  var moved = 0
  while moved > steps do:
    if index <= 0 then:
      return None {}
    index = previous_rune_boundary(source, index)
    moved = moved - 1
  Some<StringIndex> { value: make_string_index(index) }

fn advance_grapheme_index(value: String, cursor: i32, steps: i32) -> Option<StringIndex>
  if cursor < 0 or cursor > value.byte_len() then:
    return None {}
  let source = value.raw_bytes()
  if not is_rune_boundary(source, value.byte_len(), cursor) then:
    return None {}
  if steps == 0 then:
    return Some<StringIndex> { value: make_string_index(cursor) }

  var index = cursor
  if steps > 0 then:
    var moved = 0
    while moved < steps do:
      if index >= value.byte_len() then:
        return None {}
      index = next_grapheme_boundary(source, value.byte_len(), index)
      moved = moved + 1
    return Some<StringIndex> { value: make_string_index(index) }

  var moved = 0
  while moved > steps do:
    if index <= 0 then:
      return None {}
    index = previous_grapheme_boundary(source, value.byte_len(), index)
    moved = moved - 1
  Some<StringIndex> { value: make_string_index(index) }

fn previous_rune_boundary(source: FixedArray<i32>, index: i32) -> i32
  var cursor = index - 1
  while cursor > 0 and is_continuation_byte(__array_get(source, cursor)) do:
    cursor = cursor - 1
  if cursor < 0 then: 0 else: cursor

fn is_rune_boundary(source: FixedArray<i32>, length: i32, index: i32) -> bool
  if index < 0 or index > length then:
    return false
  if index == 0 or index == length then:
    return true
  not is_continuation_byte(__array_get(source, index))

fn clamp_index_to_rune_boundary(source: FixedArray<i32>, length: i32, index: i32) -> i32
  let clamped = clamp_slice_index(index, length)
  if clamped <= 0 or clamped >= length then:
    return clamped

  var cursor = clamped
  while cursor > 0 and is_continuation_byte(__array_get(source, cursor)) do:
    cursor = cursor - 1
  cursor

fn next_grapheme_boundary(source: FixedArray<i32>, length: i32, index: i32) -> i32
  if index >= length then:
    return length

  let head = decode_utf8_at(source, length, index)
  var cursor = index + head.width
  var previous = head.codepoint
  var regional_indicator_count = grapheme_regional_indicator_count_initial(previous)
  while cursor < length do:
    let read = decode_utf8_at(source, length, cursor)
    if should_join_grapheme(previous, read.codepoint, regional_indicator_count) then:
      cursor = cursor + read.width
      previous = read.codepoint
      regional_indicator_count = grapheme_regional_indicator_count_next(
        regional_indicator_count,
        previous
      )
    else:
      break
  cursor

fn previous_grapheme_boundary(source: FixedArray<i32>, length: i32, index: i32) -> i32
  if index <= 0 then:
    return 0

  var cursor = 0
  var prev = 0
  while cursor < index do:
    prev = cursor
    cursor = next_grapheme_boundary(source, length, cursor)
  prev

// Grapheme clustering rules used by grapheme_len/graphemes/grapheme_index.
fn should_join_grapheme(previous: i32, next: i32, regional_indicator_count: i32) -> bool
  if should_join_grapheme_non_regional(previous, next) then:
    return true
  if should_join_grapheme_regional_indicators(previous, next, regional_indicator_count) then:
    return true
  false

fn should_join_grapheme_non_regional(previous: i32, next: i32) -> bool
  if next == 8205 then:
    return true
  if previous == 8205 then:
    return true
  if next >= 65024 and next <= 65039 then:
    return true
  if next >= 127995 and next <= 127999 then:
    return true
  if next >= 768 and next <= 879 then:
    return true
  if next >= 6832 and next <= 6911 then:
    return true
  false

fn should_join_grapheme_regional_indicators(
  previous: i32,
  next: i32,
  regional_indicator_count: i32
) -> bool
  if not is_regional_indicator(previous) then:
    return false
  if not is_regional_indicator(next) then:
    return false
  let pair_count = regional_indicator_count / 2
  let consumed = pair_count * 2
  let remainder = regional_indicator_count - consumed
  remainder == 1

fn grapheme_regional_indicator_count_initial(codepoint: i32) -> i32
  if is_regional_indicator(codepoint) then:
    return 1
  0

fn grapheme_regional_indicator_count_next(current: i32, codepoint: i32) -> i32
  if is_regional_indicator(codepoint) then:
    return current + 1
  0

fn is_regional_indicator(codepoint: i32) -> bool
  codepoint >= 127462 and codepoint <= 127487

fn find_substring_from(value: String, substring: StringSlice, start: i32) -> i32
  if substring.byte_len() == 0 then:
    return clamp_slice_index(start, value.byte_len())
  if substring.byte_len() > value.byte_len() then:
    return -1
  if start < 0 or start > value.byte_len() then:
    return -1

  let source = value.raw_bytes()
  let limit = value.byte_len() - substring.byte_len()
  var index = start
  while index <= limit do:
    if bytes_match_slice_at(source, substring, index) then:
      return index
    index = index + 1
  -1

fn find_substring_to(value: String, substring: StringSlice, end: i32) -> i32
  if substring.byte_len() == 0 then:
    return clamp_slice_index(end, value.byte_len())
  if substring.byte_len() > value.byte_len() then:
    return -1

  let clamped_end = clamp_slice_index(end, value.byte_len())
  let source = value.raw_bytes()
  var index = clamped_end - substring.byte_len()
  while index >= 0 do:
    if bytes_match_slice_at(source, substring, index) then:
      return index
    index = index - 1
  -1

fn split_on_substring(
  value: String,
  separator: StringSlice,
  { max_splits?: i32, keep_empty?: bool }
) -> Array<StringSlice>
  let allow_empty = keep_empty ?? false
  let limit = max_splits ?? -1
  let sep_len = separator.byte_len()
  if sep_len <= 0 then:
    let ~one = Array<StringSlice>::with_capacity(1)
    one.push(value.as_slice())
    return one

  let source = value.raw_bytes()
  let ~parts = Array<StringSlice>::with_capacity(4)
  var start = 0
  var index = 0
  var splits = 0
  let max_index = value.byte_len() - sep_len
  while index <= max_index do:
    let can_split = limit < 0 or splits < limit
    if can_split and bytes_match_slice_at(source, separator, index) then:
      let length = index - start
      if allow_empty or length > 0 then:
        parts.push(new_string_slice(value, start, length))
      start = index + sep_len
      index = start
      splits = splits + 1
    else:
      index = index + 1

  let tail_len = value.byte_len() - start
  if allow_empty or tail_len > 0 then:
    parts.push(new_string_slice(value, start, tail_len))
  parts

fn to_ascii_lower(value: i32) -> i32
  if value >= 65 and value <= 90 then:
    return value + 32
  value

fn to_ascii_upper(value: i32) -> i32
  if value >= 97 and value <= 122 then:
    return value - 32
  value

fn parse_digit(value: i32) -> i32
  if value >= 48 and value <= 57 then:
    return value - 48
  if value >= 65 and value <= 90 then:
    return value - 55
  if value >= 97 and value <= 122 then:
    return value - 87
  -1

fn digit_to_f64(value: i32) -> f64
  if value == 0 then:
    return 0.0
  if value == 1 then:
    return 1.0
  if value == 2 then:
    return 2.0
  if value == 3 then:
    return 3.0
  if value == 4 then:
    return 4.0
  if value == 5 then:
    return 5.0
  if value == 6 then:
    return 6.0
  if value == 7 then:
    return 7.0
  if value == 8 then:
    return 8.0
  if value == 9 then:
    return 9.0
  0.0

fn pow10_i32(value: i32) -> f64
  if value == 0 then:
    return 1.0

  var out = 1.0
  var index = 0
  let abs = if value < 0 then: 0 - value else: value
  while index < abs do:
    out = out * 10.0
    index = index + 1

  if value < 0 then:
    return 1.0 / out
  out

fn build_escaped(value: String, include_quotes: bool) -> String
  let ~bytes = Array<i32>::with_capacity(value.byte_len() + 2)
  if include_quotes then:
    bytes.push(34)

  let source = value.raw_bytes()
  var index = 0
  while index < value.byte_len() do:
    let read = decode_utf8_at(source, value.byte_len(), index)
    append_escaped_rune(bytes, read.codepoint)
    index = index + read.width

  if include_quotes then:
    bytes.push(34)
  new_string(bytes.to_fixed_array())

fn append_escaped_rune(~out: Array<i32>, rune: i32) -> void
  if rune == 34 then:
    out.push(92)
    out.push(34)
    return void
  if rune == 92 then:
    out.push(92)
    out.push(92)
    return void
  if rune == 10 then:
    out.push(92)
    out.push(110)
    return void
  if rune == 13 then:
    out.push(92)
    out.push(114)
    return void
  if rune == 9 then:
    out.push(92)
    out.push(116)
    return void
  if rune < 32 then:
    append_hex_escape(out, rune)
    return void

  append_codepoint_mut(out, rune)

fn append_hex_escape(~out: Array<i32>, rune: i32) -> void
  out.push(92)
  out.push(117)
  out.push(123)

  let raw = rune
  if raw == 0 then:
    out.push(48)
  else:
    let ~digits = Array<i32>::with_capacity(8)
    var value = raw
    while value > 0 do:
      let digit = value - (value / 16) * 16
      digits.push(hex_digit(digit))
      value = value / 16
    var index = digits.len() - 1
    while index >= 0 do:
      match(digits.get(index))
        Some<i32> { value }:
          out.push(value)
        None:
          void
      index = index - 1

  out.push(125)

fn hex_digit(value: i32) -> i32
  if value < 10 then:
    return 48 + value
  97 + (value - 10)

fn bytes_match_at(
  source: FixedArray<i32>,
  target: FixedArray<i32>,
  index: i32,
  target_len: i32
) -> bool
  var cursor = 0
  while cursor < target_len do:
    if __array_get(source, index + cursor) != __array_get(target, cursor) then:
      return false
    cursor = cursor + 1
  true

fn bytes_match_slice_at(
  source: FixedArray<i32>,
  target: StringSlice,
  index: i32
) -> bool
  let target_len = target.byte_len()
  let target_source = target.source.raw_bytes()
  let target_start = target.start
  var cursor = 0
  while cursor < target_len do:
    if __array_get(source, index + cursor) != __array_get(target_source, target_start + cursor) then:
      return false
    cursor = cursor + 1
  true

fn append_bytes(~out: Array<i32>, source: FixedArray<i32>, count: i32) -> void
  var index = 0
  while index < count do:
    out.push(__array_get(source, index))
    index = index + 1

pub fn from_utf8({ bytes: Array<i32> }) -> Result<String, Utf8Error>
  let source_bytes = bytes
  let source = source_bytes.raw_storage()
  let len = source_bytes.len()
  var index = 0
  while index < len do:
    let width = valid_utf8_width_at(source, len, index)
    if width <= 0 then:
      return Err<Utf8Error> { error: Utf8Error { code: 1 } }
    index = index + width
  Ok<String> { value: String { bytes: source_bytes, byte_count: len } }

fn from_utf8_legacy(bytes: Array<i32>): () -> Result<String, Utf8Error>
  let source = bytes.raw_storage()
  let len = bytes.len()
  var index = 0
  while index < len do:
    if not is_byte(__array_get(source, index)) then:
      return Err<Utf8Error> { error: Utf8Error { code: 1 } }
    index = index + 1
  Ok<String> { value: new_string(bytes.to_fixed_array()) }

fn append_codepoint_mut(~bytes: Array<i32>, codepoint: i32) -> void
  if codepoint < 0 then:
    append_replacement_mut(bytes)
    return void
  if codepoint <= 127 then:
    bytes.push(codepoint)
    return void
  if codepoint <= 2047 then:
    bytes.push(192 + (codepoint / 64))
    bytes.push(128 + (codepoint - (codepoint / 64) * 64))
    return void
  if codepoint <= 65535 then:
    if codepoint >= 55296 and codepoint <= 57343 then:
      append_replacement_mut(bytes)
      return void
    bytes.push(224 + (codepoint / 4096))
    bytes.push(128 + ((codepoint / 64) - (codepoint / 4096) * 64))
    bytes.push(128 + (codepoint - (codepoint / 64) * 64))
    return void
  if codepoint <= 1114111 then:
    bytes.push(240 + (codepoint / 262144))
    bytes.push(128 + ((codepoint / 4096) - (codepoint / 262144) * 64))
    bytes.push(128 + ((codepoint / 64) - (codepoint / 4096) * 64))
    bytes.push(128 + (codepoint - (codepoint / 64) * 64))
    return void
  append_replacement_mut(bytes)

pub fn new_string(from_bytes: FixedArray<i32>): () -> String
  let input_length = __array_len(from_bytes)
  let ~bytes = Array<i32>::with_capacity(input_length)
  var index = 0
  while index < input_length do:
    let read = decode_utf8_at(from_bytes, input_length, index)
    append_codepoint_mut(bytes, read.codepoint)
    index = index + read.width
  let byte_count = bytes.len()
  String { bytes: bytes, byte_count: byte_count }

fn append_replacement_mut(~bytes: Array<i32>) -> void
  bytes.push(239)
  bytes.push(191)
  bytes.push(189)

fn utf8_replacement() -> Utf8Read
  Utf8Read { codepoint: 65533, width: 1 }

fn valid_utf8_width_at(source: FixedArray<i32>, limit: i32, index: i32) -> i32
  if index < 0 or index >= limit then:
    return 0

  let b0 = __array_get(source, index)
  if not is_byte(b0) then:
    return 0
  if b0 <= 127 then:
    return 1

  if b0 >= 194 and b0 <= 223 then:
    let next_index = index + 1
    if next_index >= limit then:
      return 0
    let b1 = __array_get(source, next_index)
    if is_continuation_byte(b1) then: 2 else: 0

  if b0 >= 224 and b0 <= 239 then:
    let next_index = index + 1
    let next_index2 = index + 2
    if next_index2 >= limit then:
      return 0
    let b1 = __array_get(source, next_index)
    let b2 = __array_get(source, next_index2)
    if valid_three_byte_lead(b0, b1, b2) then: 3 else: 0

  if b0 >= 240 and b0 <= 244 then:
    let next_index = index + 1
    let next_index2 = index + 2
    let next_index3 = index + 3
    if next_index3 >= limit then:
      return 0
    let b1 = __array_get(source, next_index)
    let b2 = __array_get(source, next_index2)
    let b3 = __array_get(source, next_index3)
    if valid_four_byte_lead(b0, b1, b2, b3) then: 4 else: 0

  0

fn empty_string() -> String
  new_string(new_fixed_array<i32>(0))
