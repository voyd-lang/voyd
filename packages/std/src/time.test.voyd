use std::error::HostError
use std::result::types::all
use std::string::type::{ StringSlice, new_string }
use std::test::assertions::all
use std::test::host_dto::self as host_dto_test

fn read_unix_millis(value: SystemTime) -> i64
  value.unix_millis()

test "system_time unix_millis is pure":
  let now = system_time_now_with_millis(i64_from_i32(123))

  assert(read_unix_millis(now), eq: i64_from_i32(123))

fn system_time_now_with_millis(ms: i64): () -> SystemTime
  try
    SystemTime::now()
  Time::monotonic_now_millis(tail):
    tail(i64_from_i32(0))
  Time::system_now_millis(tail):
    tail(ms)
  Time::sleep_millis(tail, _ms):
    tail(host_dto_test::host_ok_payload())

test "sleep decodes host errors":
  let result = sleep_with_error(code: 7, message: "blocked".as_slice())
  match(result)
    Err<HostError> { error }:
      assert(error.code, eq: 7)
      assert(error.message.equals("blocked"), eq: true)
    Ok<Unit>:
      assert(false, eq: true)

fn sleep_with_error({ code: i32, message: StringSlice }): () -> Result<Unit, HostError>
  try
    sleep(duration: Duration::from_millis(ms: i64_from_i32(5)))
  Time::monotonic_now_millis(tail):
    tail(i64_from_i32(0))
  Time::system_now_millis(tail):
    tail(i64_from_i32(0))
  Time::sleep_millis(tail, _ms):
    tail(host_dto_test::host_error_payload(code: code, message: message.to_string()))

fn i64_from_i32(value: i32): () -> i64 __i64_extend_s(value)
