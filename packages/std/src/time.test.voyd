use std::error::HostError
use std::msgpack::self as msgpack
use std::result::types::all
use std::string::type::StringSlice
use std::test::assertions::all
use std::test::host_dto::self as host_dto_test

obj IntervalCapture {
  set_calls: i32,
  clear_calls: i32,
  callback_calls: i32
}

fn read_unix_millis(value: SystemTime) -> i64
  value.unix_millis()

test "system_time unix_millis is pure":
  let now = system_time_now_with_millis(i64_from_i32(123))

  assert(read_unix_millis(now), eq: i64_from_i32(123))

fn system_time_now_with_millis(ms: i64): () -> SystemTime
  try
    SystemTime::now()
  Time::monotonic_now_millis(tail):
    tail(i64_from_i32(0))
  Time::system_now_millis(tail):
    tail(ms)
  Time::sleep_millis(tail, _ms):
    tail(host_dto_test::host_ok_payload())
  Time::set_timeout_millis(tail, _ms):
    tail(host_dto_test::host_ok_payload())
  Time::set_interval_millis(tail, _ms):
    tail(host_dto_test::host_ok_with_value(msgpack::make_i32(0)))
  Time::clear_timer(tail, _timer_id):
    tail(host_dto_test::host_ok_payload())

test "sleep decodes host errors":
  let result = sleep_with_error(code: 7, message: "blocked".as_slice())
  match(result)
    Err<HostError> { error }:
      assert(error.code, eq: 7)
      assert(error.message.equals("blocked"), eq: true)
    Ok<Unit>:
      assert(false, eq: true)

fn sleep_with_error({ code: i32, message: StringSlice }): () -> Result<Unit, HostError>
  try
    sleep(i64_from_i32(5))
  Time::monotonic_now_millis(tail):
    tail(i64_from_i32(0))
  Time::system_now_millis(tail):
    tail(i64_from_i32(0))
  Time::sleep_millis(tail, _ms):
    tail(host_dto_test::host_error_payload(code: code, message: message.to_string()))
  Time::set_timeout_millis(tail, _ms):
    tail(host_dto_test::host_ok_payload())
  Time::set_interval_millis(tail, _ms):
    tail(host_dto_test::host_ok_with_value(msgpack::make_i32(0)))
  Time::clear_timer(tail, _timer_id):
    tail(host_dto_test::host_ok_payload())

test "on_timeout invokes callback on success":
  let result = on_timeout_with_payload(
    payload: host_dto_test::host_ok_payload()
  )
  match(result)
    Ok<Unit>:
      assert(true, eq: true)
    Err<HostError>:
      assert(false, eq: true)

test "on_timeout decodes host errors and skips callback":
  let result = on_timeout_with_payload(
    payload: host_dto_test::host_error_payload(
      code: 11,
      message: "denied"
    )
  )
  match(result)
    Err<HostError> { error }:
      assert(error.code, eq: 11)
      assert(error.message.equals("denied"), eq: true)
    Ok<Unit>:
      assert(false, eq: true)

fn on_timeout_with_payload({ payload: MsgPack }): () -> Result<Unit, HostError>
  try
    on_timeout(
      Duration::from_millis(i64_from_i32(5)),
      () -> void => void
    )
  Time::monotonic_now_millis(tail):
    tail(i64_from_i32(0))
  Time::system_now_millis(tail):
    tail(i64_from_i32(0))
  Time::sleep_millis(tail, _ms):
    tail(host_dto_test::host_ok_payload())
  Time::set_timeout_millis(tail, _ms):
    tail(payload)
  Time::set_interval_millis(tail, _ms):
    tail(host_dto_test::host_ok_with_value(msgpack::make_i32(0)))
  Time::clear_timer(tail, _timer_id):
    tail(host_dto_test::host_ok_payload())

test "on_interval repeats callbacks and surfaces host errors":
  let ~capture = IntervalCapture {
    set_calls: 0,
    clear_calls: 0,
    callback_calls: 0
  }
  let result = on_interval_until_error(capture)
  match(result)
    Err<HostError> { error }:
      assert(error.code, eq: 9)
      assert(error.message.equals("stopped"), eq: true)
      assert(capture.set_calls, eq: 2)
      assert(capture.clear_calls, eq: 1)
      assert(capture.callback_calls, eq: 1)
    Ok<Unit>:
      assert(false, eq: true)

fn on_interval_until_error(~capture: IntervalCapture): () -> Result<Unit, HostError>
  try
    on_interval(
      Duration::from_millis(i64_from_i32(5)),
      () -> void =>
        capture.callback_calls = capture.callback_calls + 1
    )
  Time::monotonic_now_millis(tail):
    tail(i64_from_i32(0))
  Time::system_now_millis(tail):
    tail(i64_from_i32(0))
  Time::sleep_millis(tail, _ms):
    tail(host_dto_test::host_ok_payload())
  Time::set_timeout_millis(tail, _ms):
    tail(host_dto_test::host_ok_payload())
  Time::set_interval_millis(tail, _ms):
    capture.set_calls = capture.set_calls + 1
    if capture.set_calls == 1:
      tail(host_dto_test::host_ok_with_value(msgpack::make_i32(42)))
    else:
      tail(host_dto_test::host_error_payload(code: 9, message: "stopped"))
  Time::clear_timer(tail, _timer_id):
    capture.clear_calls = capture.clear_calls + 1
    tail(host_dto_test::host_ok_payload())

test "on_interval clears timer when sleep fails":
  let ~capture = IntervalCapture {
    set_calls: 0,
    clear_calls: 0,
    callback_calls: 0
  }
  let result = on_interval_sleep_error(capture)
  match(result)
    Err<HostError> { error }:
      assert(error.code, eq: 5)
      assert(error.message.equals("sleep-failed"), eq: true)
      assert(capture.set_calls, eq: 1)
      assert(capture.clear_calls, eq: 1)
      assert(capture.callback_calls, eq: 0)
    Ok<Unit>:
      assert(false, eq: true)

fn on_interval_sleep_error(~capture: IntervalCapture): () -> Result<Unit, HostError>
  try
    on_interval(
      Duration::from_millis(i64_from_i32(5)),
      () -> void =>
        capture.callback_calls = capture.callback_calls + 1
    )
  Time::monotonic_now_millis(tail):
    tail(i64_from_i32(0))
  Time::system_now_millis(tail):
    tail(i64_from_i32(0))
  Time::sleep_millis(tail, _ms):
    tail(host_dto_test::host_error_payload(code: 5, message: "sleep-failed"))
  Time::set_timeout_millis(tail, _ms):
    tail(host_dto_test::host_ok_payload())
  Time::set_interval_millis(tail, _ms):
    capture.set_calls = capture.set_calls + 1
    tail(host_dto_test::host_ok_with_value(msgpack::make_i32(77)))
  Time::clear_timer(tail, _timer_id):
    capture.clear_calls = capture.clear_calls + 1
    tail(host_dto_test::host_ok_payload())

fn i64_from_i32(value: i32): () -> i64 __i64_extend_s(value)
