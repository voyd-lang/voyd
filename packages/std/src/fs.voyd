use std::array::Array
use std::dict::Dict
use std::error::IoError
use std::msgpack::MsgPack
use std::msgpack::self as msgpack
use std::optional::types::all
use std::path::Path
use std::result::types::all
use std::string::type::{ String, StringSlice, new_string }

@effect(id: "std::fs::Fs")
pub eff Fs
  read_bytes(tail, path: MsgPack) -> MsgPack
  read_string(tail, path: MsgPack) -> MsgPack
  write_bytes(tail, payload: MsgPack) -> MsgPack
  write_string(tail, payload: MsgPack) -> MsgPack
  exists(tail, path: MsgPack) -> bool
  list_dir(tail, path: MsgPack) -> MsgPack

pub fn read_bytes({ path: Path }): Fs -> Result<Array<i32>, IoError>
  decode_read_bytes_result(Fs::read_bytes(encode_path(path)))

pub fn read_string({ path: Path }): Fs -> Result<String, IoError>
  decode_read_string_result(Fs::read_string(encode_path(path)))

pub fn write_bytes({ path: Path, bytes: Array<i32> }): Fs -> Result<Unit, IoError>
  let payload = encode_write_bytes_payload(path: path, bytes: bytes)
  decode_write_result(Fs::write_bytes(payload))

pub fn write_string({ path: Path, s: StringSlice }): Fs -> Result<Unit, IoError>
  let payload = encode_write_string_payload(path: path, value: s.to_string())
  decode_write_result(Fs::write_string(payload))

pub fn exists({ path: Path }): Fs -> bool
  Fs::exists(encode_path(path))

pub fn list_dir({ path: Path }): Fs -> Result<Array<Path>, IoError>
  decode_list_dir_result(Fs::list_dir(encode_path(path)))

fn encode_path(path: Path): () -> MsgPack
  msgpack::make_string(path.as_string())

fn encode_write_bytes_payload({ path: Path, bytes: Array<i32> }): () -> MsgPack
  let ~payload = Dict<String, MsgPack>::init()
  payload.set(key: "path", value: encode_path(path))
  payload.set(key: "bytes", value: encode_byte_array(bytes))
  msgpack::make_map(payload)

fn encode_write_string_payload({ path: Path, value: String }): () -> MsgPack
  let ~payload = Dict<String, MsgPack>::init()
  payload.set(key: "path", value: encode_path(path))
  payload.set(key: "value", value: msgpack::make_string(value))
  msgpack::make_map(payload)

fn encode_byte_array(bytes: Array<i32>): () -> MsgPack
  let ~encoded = Array<MsgPack>::with_capacity(bytes.len())
  var index = 0
  while index < bytes.len() do:
    match(bytes.get(index))
      Some<i32> { value }:
        encoded.push(msgpack::make_i32(value))
      None:
        void
    index = index + 1
  msgpack::make_array(encoded)

fn decode_read_bytes_result(payload: MsgPack): () -> Result<Array<i32>, IoError>
  let decoded = msgpack::unpack_map(payload)
  if read_bool(decoded, "ok") == false then:
    return Err<IoError> { error: decode_io_error(decoded) }

  Ok<Array<i32>> { value: decode_byte_array(read_msgpack(decoded, "value")) }

fn decode_read_string_result(payload: MsgPack): () -> Result<String, IoError>
  let decoded = msgpack::unpack_map(payload)
  if read_bool(decoded, "ok") == false then:
    return Err<IoError> { error: decode_io_error(decoded) }

  Ok<String> { value: msgpack::unpack_string(read_msgpack(decoded, "value")) }

fn decode_write_result(payload: MsgPack): () -> Result<Unit, IoError>
  let decoded = msgpack::unpack_map(payload)
  if read_bool(decoded, "ok") then:
    return Ok<Unit> { value: Unit {} }
  Err<IoError> { error: decode_io_error(decoded) }

fn decode_list_dir_result(payload: MsgPack): () -> Result<Array<Path>, IoError>
  let decoded = msgpack::unpack_map(payload)
  if read_bool(decoded, "ok") == false then:
    return Err<IoError> { error: decode_io_error(decoded) }

  Ok<Array<Path>> { value: decode_path_array(read_msgpack(decoded, "value")) }

fn decode_io_error(payload: Dict<String, MsgPack>): () -> IoError
  IoError {
    code: read_i32(payload, "code"),
    message: read_string(payload, "message")
  }

fn decode_byte_array(payload: MsgPack): () -> Array<i32>
  let source = msgpack::unpack_array(payload)
  let ~out = Array<i32>::with_capacity(source.len())
  var index = 0
  while index < source.len() do:
    match(source.get(index))
      Some<MsgPack> { value }:
        out.push(normalize_byte(msgpack::unpack_i32(value)))
      None:
        void
    index = index + 1
  out

fn decode_path_array(payload: MsgPack): () -> Array<Path>
  let source = msgpack::unpack_array(payload)
  let ~out = Array<Path>::with_capacity(source.len())
  var index = 0
  while index < source.len() do:
    match(source.get(index))
      Some<MsgPack> { value }:
        value.match(path_value)
          String:
            out.push(Path::new(s: path_value.as_slice()))
          else:
            void
      None:
        void
    index = index + 1
  out

fn normalize_byte(value: i32): () -> i32
  mod_i32(value, 256)

fn mod_i32(value: i32, modulus: i32) -> i32
  if modulus <= 0 then:
    return 0
  let div = value / modulus
  let rem = value - div * modulus
  if rem < 0 then: rem + modulus else: rem

fn read_bool(map: Dict<String, MsgPack>, key: String): () -> bool
  msgpack::unpack_bool(read_msgpack(map, key))

fn read_i32(map: Dict<String, MsgPack>, key: String): () -> i32
  msgpack::unpack_i32(read_msgpack(map, key))

fn read_string(map: Dict<String, MsgPack>, key: String): () -> String
  msgpack::unpack_string(read_msgpack(map, key))

fn read_msgpack(map: Dict<String, MsgPack>, key: String): () -> MsgPack
  match(map.get(key: key))
    Some<MsgPack> { value }:
      value
    None:
      msgpack::make_null()
