//! File system APIs backed by host runtime operations.
//!
//! `std::fs` provides read/write/existence/listing helpers that operate on
//! `std::path::Path` and return typed `Result` values where host I/O can fail.
//! All effect payloads are MessagePack-encoded DTOs.

use std::array::Array
use std::bytes::{ ByteBuffer, Bytes }
use std::error::IoError
use std::host_dto::HostDto
use std::math::{ MathError, mod_euclid }
use std::msgpack::MsgPack
use std::msgpack::self as msgpack
use std::optional::types::all
use std::path::Path
use std::result::types::all
use std::string::type::{ String, StringSlice, new_string }

@effect(id: "std::fs::Fs")
/// Host file-system effect used by `std::fs`.
pub eff Fs
  /// Reads file contents from `path` and returns raw byte data or an I/O error DTO.
  read_bytes(tail, path: MsgPack) -> MsgPack
  /// Reads UTF-8 text contents from `path` and returns string data or an I/O error DTO.
  read_string(tail, path: MsgPack) -> MsgPack
  /// Writes raw byte data to a file.
  ///
  /// `payload` contains `{ path, bytes }`.
  write_bytes(tail, payload: MsgPack) -> MsgPack
  /// Writes UTF-8 text to a file.
  ///
  /// `payload` contains `{ path, value }`.
  write_string(tail, payload: MsgPack) -> MsgPack
  /// Returns the host-reported existence check for `path`.
  exists(tail, path: MsgPack) -> bool
  /// Lists child paths in the directory at `path`, or returns an I/O error DTO.
  list_dir(tail, path: MsgPack) -> MsgPack

/// Reads a file as raw bytes.
///
/// Example:
/// `let bytes = fs::read_bytes(path: Path::new(s: "./image.bin".as_slice()))`
pub fn read_bytes({ path: Path }): Fs -> Result<Bytes, IoError>
  decode_read_bytes_result(Fs::read_bytes(encode_path(path)))

/// Reads text from a file.
///
/// This expects host-side UTF-8 text decoding.
pub fn read_string({ path: Path }): Fs -> Result<String, IoError>
  decode_read_string_result(Fs::read_string(encode_path(path)))

/// Writes bytes to a file.
///
/// Example:
/// `let write_result = fs::write_bytes(path: file_path, bytes: payload)`
pub fn write_bytes({ path: Path, bytes: Bytes }): Fs -> Result<Unit, IoError>
  let payload = encode_write_bytes_payload(path: path, bytes: bytes)
  decode_write_result(Fs::write_bytes(payload))

/// Writes text to a file.
///
/// Example:
/// `let write_result = fs::write_string(path: file_path, s: "hello".as_slice())`
pub fn write_string({ path: Path, s: StringSlice }): Fs -> Result<Unit, IoError>
  let payload = encode_write_string_payload(path: path, value: s.to_string())
  decode_write_result(Fs::write_string(payload))

/// Returns true when the path exists in the file system.
pub fn exists({ path: Path }): Fs -> bool
  Fs::exists(encode_path(path))

/// Lists child paths in a directory.
///
/// Each returned `Path` is decoded from host-provided string entries.
pub fn list_dir({ path: Path }): Fs -> Result<Array<Path>, IoError>
  decode_list_dir_result(Fs::list_dir(encode_path(path)))

fn encode_path(path: Path): () -> MsgPack
  msgpack::make_string(path.as_string())

fn encode_write_bytes_payload({ path: Path, bytes: Bytes }): () -> MsgPack
  HostDto::init()
    .set("path", encode_path(path))
    .set("bytes", encode_byte_array(bytes))
    .pack()

fn encode_write_string_payload({ path: Path, value: String }): () -> MsgPack
  HostDto::init()
    .set("path", encode_path(path))
    .set("value", msgpack::make_string(value))
    .pack()

fn encode_byte_array(bytes: Bytes): () -> MsgPack
  let source = bytes.to_array()
  let ~encoded = Array<MsgPack>::with_capacity(bytes.len())
  var index = 0
  while index < source.len() do:
    match(source.get(index))
      Some<i32> { value }:
        encoded.push(msgpack::make_i32(value))
      None:
        void
    index = index + 1
  msgpack::make_array(encoded)

fn decode_read_bytes_result(payload: MsgPack): () -> Result<Bytes, IoError>
  let decoded = HostDto::unpack(payload)
  if decoded.read_bool("ok") == false:
    return Err<IoError> { error: decode_io_error(decoded) }

  Ok<Bytes> { value: decode_bytes(decoded.read_msgpack("value")) }

fn decode_read_string_result(payload: MsgPack): () -> Result<String, IoError>
  let decoded = HostDto::unpack(payload)
  if decoded.read_bool("ok") == false:
    return Err<IoError> { error: decode_io_error(decoded) }

  Ok<String> { value: decoded.read_string("value") }

fn decode_write_result(payload: MsgPack): () -> Result<Unit, IoError>
  let decoded = HostDto::unpack(payload)
  if decoded.read_bool("ok"):
    return Ok<Unit> { value: Unit {} }
  Err<IoError> { error: decode_io_error(decoded) }

fn decode_list_dir_result(payload: MsgPack): () -> Result<Array<Path>, IoError>
  let decoded = HostDto::unpack(payload)
  if decoded.read_bool("ok") == false:
    return Err<IoError> { error: decode_io_error(decoded) }

  Ok<Array<Path>> { value: decode_path_array(decoded.read_msgpack("value")) }

fn decode_io_error(payload: HostDto): () -> IoError
  IoError {
    code: payload.read_i32("code"),
    message: payload.read_string("message")
  }

fn decode_bytes(payload: MsgPack): () -> Bytes
  let source = msgpack::unpack_array(payload)
  let ~buffer = ByteBuffer::with_capacity(bytes: source.len())
  var index = 0
  while index < source.len() do:
    match(source.get(index))
      Some<MsgPack> { value }:
        buffer.push(value: normalize_byte(msgpack::unpack_i32(value)))
      None:
        void
    index = index + 1
  buffer.as_bytes()

fn decode_path_array(payload: MsgPack): () -> Array<Path>
  let source = msgpack::unpack_array(payload)
  let ~out = Array<Path>::with_capacity(source.len())
  var index = 0
  while index < source.len() do:
    match(source.get(index))
      Some<MsgPack> { value }:
        value.match(path_value)
          String:
            out.push(Path::new(s: path_value.as_slice()))
          else:
            void
      None:
        void
    index = index + 1
  out

fn normalize_byte(value: i32): () -> i32
  match(mod_euclid(value, 256))
    Ok<i32> { value }:
      value
    Err<MathError>:
      0
