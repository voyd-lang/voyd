//! Random-number and random-byte helpers backed by the host `Random` effect.
//! The host implementation is expected to provide cryptographically secure
//! randomness when available.

use std::array::Array
use std::bytes::ByteBuffer
use std::math::{ MathError, mod_euclid }
use std::msgpack::MsgPack
use std::msgpack::self as msgpack
use std::number::cast::{ to_f32, to_f64, to_i32_wrapping, to_i64 }
use std::optional::types::all
use std::range::Range

/// Host-provided random source effect.
///
/// The host random provider should use a secure entropy source when available.
/// `std::random` normalizes returned values into `i32` byte ranges where needed.
@effect(id: "voyd.std.random")
pub eff Random
  /// Returns a random signed 64-bit integer.
  next_i64(tail) -> i64
  /// Returns random 64-bit bits interpreted as an unsigned integer payload.
  ///
  /// The transport representation is `i64`, but callers should treat the bits
  /// as unsigned payload.
  next_u64(tail) -> i64
  /// Returns an array of random byte values with length `len`.
  ///
  /// Host values are expected to be i32 entries; callers should normalize each
  /// element into the `[0, 255]` range before treating them as bytes.
  fill_bytes(tail, len: i32) -> MsgPack

/// Raw 64-bit bits interpreted as unsigned payload.
pub obj U64Bits {
  /// Underlying bit pattern.
  api bits: i64
}

/// Fast deterministic pseudo-random generator for local sampling.
///
/// `LocalRng` is not cryptographically secure. It is intended for hot local
/// loops (for example, render jitter) where host-effect round-trips are too
/// expensive.
pub obj LocalRng {
  state: i64
}

impl LocalRng
  /// Creates a local RNG from explicit seed bits.
  api fn seeded(seed: i64) -> LocalRng
    LocalRng { state: normalize_local_seed(seed) }

  /// Creates a local RNG from explicit seed bits.
  api fn seeded(seed: U64Bits) -> LocalRng
    LocalRng::seeded(seed.bits)

  /// Seeds a local RNG from the host random source.
  ///
  /// This performs one host random effect call, then all subsequent sampling
  /// remains local and effect-free.
  api fn seeded_from_host(): Random -> LocalRng
    LocalRng::seeded(next_u64())

  /// Returns the next random bits.
  api fn next_u64(~self) -> U64Bits
    self.state = local_rng_next_state(self.state)
    U64Bits { bits: self.state }

  /// Returns the next random signed integer.
  api fn next_i64(~self) -> i64
    self.next_u64().bits

  /// Returns a random boolean value.
  api fn random_bool(~self) -> bool
    self.random_i32() % 2 == 0

  /// Returns a random i32 value.
  api fn random_i32(~self) -> i32
    to_i32_wrapping(self.next_i64())

  /// Returns a random i32 value within the provided range.
  api fn random_i32(~self, range: Range<i32>) -> i32
    sample_i32_from_seed(self.next_i64(), range)

  /// Returns a random i64 value.
  api fn random_i64(~self) -> i64
    self.next_i64()

  /// Returns a random i64 value within the provided range.
  api fn random_i64(~self, range: Range<i64>) -> i64
    let start_i64 = range_start_or_zero(range.start)
    if range.include_end:
      match(range.end)
        Some<i64> { value }:
          if value == i64_max_value():
            return local_rng_i64_inclusive_to_max(self, start_i64)
        None:
          void
    let end_exclusive = range_end_exclusive(range, start_i64)
    sample_i64_from_seed(self.next_i64(), start_i64, end_exclusive)

  /// Returns a random floating-point value in `[0.0, 1.0)`.
  api fn random_f64(~self) -> f64
    f64_in_interval_from_unit(local_rng_unit_f64(self), 0.0, 1.0)

  /// Returns a random floating-point value within the provided range.
  api fn random_f64(~self, range: Range<f64>) -> f64
    let start = range_start_or_zero(range.start)
    let end_exclusive = range_end_exclusive(range, start)
    f64_in_interval_from_unit(local_rng_unit_f64(self), start, end_exclusive)

  /// Returns a random floating-point value in `[0.0, 1.0)` as `f32`.
  api fn random_f32(~self) -> f32
    to_f32(self.random_f64())

  /// Returns a random floating-point value within the provided range as `f32`.
  api fn random_f32(~self, range: Range<f32>) -> f32
    let start = range_start_or_zero(range.start)
    let end_exclusive = range_end_exclusive(range, start)
    to_f32(
      f64_in_interval_from_unit(
        local_rng_unit_f64(self),
        to_f64(start),
        to_f64(end_exclusive)
      )
    )

/// Returns a random 64-bit integer.
pub fn next_i64(): Random -> i64
  Random::next_i64()

/// Returns random 64-bit bits interpreted as an unsigned integer payload.
pub fn next_u64(): Random -> U64Bits
  U64Bits { bits: Random::next_u64() }

/// Fills a byte buffer with cryptographically secure random bytes.
/// `len` controls the number of bytes appended to `buf`.
/// Example:
/// `let buf = ByteBuffer::new()`
/// `random::fill_bytes(buf, len: 16)`
/// `buf.len() == 16`
pub fn fill_bytes(~buf: ByteBuffer, len: i32): Random -> void
  if len <= 0:
    return void

  let payload = Random::fill_bytes(len)
  let decoded = msgpack::unpack_array(payload)

  var index = 0
  while index < len do:
    if index < decoded.len():
      match(decoded.get(index))
        Some<MsgPack> { value }:
          buf.push(mod_euclid_i32_or_zero(msgpack::unpack_i32(value), 256))
        None:
          let next = to_i32_wrapping(next_i64())
          buf.push(mod_euclid_i32_or_zero(next, 256))
    else:
      let next = to_i32_wrapping(next_i64())
      buf.push(mod_euclid_i32_or_zero(next, 256))
    index = index + 1

/// Fills a byte buffer with cryptographically secure random bytes.
pub fn fill_buffer(~buf: ByteBuffer, len: i32): Random -> void
  fill_bytes(buf, len)

/// Returns a random boolean value.
pub fn random_bool(): Random -> bool
  let value = random_i32()
  value % 2 == 0

/// Returns a random i32 value.
///
/// Default behavior (no range): samples across the full `i32` domain.
pub fn random_i32(): Random -> i32
  to_i32_wrapping(next_i64())

/// Returns a random i32 value within the provided range.
/// The range lower bound is inclusive. The upper bound follows `Range`:
/// exclusive by default, inclusive when `include_end` is true.
/// Example:
/// `random::random_i32(1..6)` samples values in `[1, 5]`.
pub fn random_i32(range: Range<i32>): Random -> i32
  sample_i32_from_seed(next_i64(), range)

/// Returns a random i64 value.
///
/// Default behavior (no range): samples across the full `i64` domain.
pub fn random_i64(): Random -> i64
  next_i64()

/// Returns a random i64 value within the provided range.
///
/// The range lower bound is inclusive. The upper bound follows `Range`:
/// exclusive by default, inclusive when `include_end` is true.
pub fn random_i64(range: Range<i64>): Random -> i64
  let start_i64 = range_start_or_zero(range.start)
  if range.include_end:
    match(range.end)
      Some<i64> { value }:
        if value == i64_max_value():
          return random_i64_inclusive_to_max(start_i64)
      None:
        void
  let end_exclusive = range_end_exclusive(range, start_i64)
  sample_i64_from_seed(next_i64(), start_i64, end_exclusive)

/// Returns a random floating-point value in `[0.0, 1.0)`.
///
/// This no-argument overload is the default behavior.
pub fn random_f64(): Random -> f64
  f64_in_interval_from_unit(random_unit_f64(), 0.0, 1.0)

/// Returns a random floating-point value within the provided range.
///
/// The lower bound is inclusive. The upper bound follows `Range` semantics:
/// exclusive by default, inclusive when `include_end` is true.
/// Example:
/// `random::random_f64(0.0..10.0)` samples values in `[0.0, 10.0)`.
pub fn random_f64(range: Range<f64>): Random -> f64
  let start = range_start_or_zero(range.start)
  let end_exclusive = range_end_exclusive(range, start)
  f64_in_interval_from_unit(random_unit_f64(), start, end_exclusive)

/// Returns a random floating-point value in `[0.0, 1.0)` as `f32`.
///
/// This no-argument overload is the default behavior.
pub fn random_f32(): Random -> f32
  to_f32(random_f64())

/// Returns a random floating-point value within the provided range as `f32`.
///
/// The lower bound is inclusive. The upper bound follows `Range` semantics:
/// exclusive by default, inclusive when `include_end` is true.
pub fn random_f32(range: Range<f32>): Random -> f32
  let start = range_start_or_zero(range.start)
  let end_exclusive = range_end_exclusive(range, start)
  to_f32(
    f64_in_interval_from_unit(
      random_unit_f64(),
      to_f64(start),
      to_f64(end_exclusive)
    )
  )

fn range_start_or_zero(start: Option<i32>) -> i32
  match(start)
    Some<i32> { value }:
      value
    None:
      0

fn range_start_or_zero(start: Option<i64>) -> i64
  match(start)
    Some<i64> { value }:
      value
    None:
      to_i64(0)

fn range_start_or_zero(start: Option<f64>) -> f64
  match(start)
    Some<f64> { value }:
      value
    None:
      0.0

fn range_start_or_zero(start: Option<f32>) -> f32
  match(start)
    Some<f32> { value }:
      value
    None:
      to_f32(0)

fn range_end_exclusive(range: Range<i32>, start: i64) -> i64
  match(range.end)
    Some<i32> { value }:
      let end = to_i64(value)
      if range.include_end:
        end + to_i64(1)
      else:
        end
    None:
      start + to_i64(1)

fn range_end_exclusive(range: Range<i64>, start: i64) -> i64
  match(range.end)
    Some<i64> { value }:
      if range.include_end:
        value + to_i64(1)
      else:
        value
    None:
      start + to_i64(1)

fn range_end_exclusive(range: Range<f64>, start: f64) -> f64
  match(range.end)
    Some<f64> { value }:
      if range.include_end:
        value + 1.0
      else:
        value
    None:
      start + 1.0

fn range_end_exclusive(range: Range<f32>, start: f32) -> f32
  match(range.end)
    Some<f32> { value }:
      if range.include_end:
        value + to_f32(1)
      else:
        value
    None:
      start + to_f32(1)

fn mod_euclid_i32_or_zero(value: i32, modulus: i32) -> i32
  match(mod_euclid(value, modulus))
    Ok<i32> { value }:
      value
    Err<MathError>:
      0

fn mod_euclid_i64_or_zero(value: i64, modulus: i64) -> i64
  match(mod_euclid(value, modulus))
    Ok<i64> { value }:
      value
    Err<MathError>:
      to_i64(0)

fn random_unit_f64(): Random -> f64
  unit_f64_from_bits(next_u64().bits)

fn random_unit_denominator_i64(): () -> i64
  to_i64(1073741824) * to_i64(8388608)

fn i64_max_value(): () -> i64
  9223372036854775807i64

fn i64_min_value(): () -> i64
  -9223372036854775808i64

fn random_i64_inclusive_to_max(start: i64): Random -> i64
  if start == i64_min_value():
    return next_i64()
  i64_inclusive_to_max_from_bits(start, next_u64().bits)

fn local_rng_unit_f64(~rng: LocalRng) -> f64
  unit_f64_from_bits(rng.next_u64().bits)

fn local_rng_i64_inclusive_to_max(~rng: LocalRng, start: i64) -> i64
  if start == i64_min_value():
    return rng.next_i64()
  i64_inclusive_to_max_from_bits(start, rng.next_u64().bits)

fn sample_i32_from_seed(seed: i64, range: Range<i32>): () -> i32
  let start = range_start_or_zero(range.start)
  let start_i64 = to_i64(start)
  let end_exclusive = range_end_exclusive(range, start_i64)
  to_i32_wrapping(sample_i64_from_seed(seed, start_i64, end_exclusive))

fn sample_i64_from_seed(seed: i64, start: i64, end_exclusive: i64): () -> i64
  if end_exclusive <= start:
    return start

  let span = end_exclusive - start
  start + mod_euclid_i64_or_zero(seed, span)

fn f64_in_interval_from_unit(unit: f64, start: f64, end_exclusive: f64): () -> f64
  if end_exclusive <= start:
    return start

  let span = end_exclusive - start
  start + unit * span

fn unit_f64_from_bits(bits: i64): () -> f64
  let denominator_i64 = random_unit_denominator_i64()
  let mantissa = mod_euclid_i64_or_zero(bits, denominator_i64)
  to_f64(mantissa) / to_f64(denominator_i64)

fn i64_inclusive_to_max_from_bits(start: i64, bits: i64): () -> i64
  let max = i64_max_value()
  if start > max:
    return start

  let span_exclusive = (max - start) + to_i64(1)
  let offset = mod_euclid_i64_or_zero(bits, span_exclusive)
  start + offset

fn local_rng_next_state(current: i64): () -> i64
  let seeded = normalize_local_seed(current)
  var state = bit_xor_i64(seeded, shift_l_i64(seeded, 13))
  state = bit_xor_i64(state, shift_ru_i64(state, 7))
  bit_xor_i64(state, shift_l_i64(state, 17))

fn normalize_local_seed(seed: i64): () -> i64
  if seed == to_i64(0):
    return 88172645463393265i64
  seed

@intrinsic(name: "__shift_l")
fn shift_l_i64(value: i64, bits: i32): () -> i64 __shift_l(value, bits)

@intrinsic(name: "__shift_ru")
fn shift_ru_i64(value: i64, bits: i32): () -> i64 __shift_ru(value, bits)

@intrinsic(name: "__bit_xor")
fn bit_xor_i64(left: i64, right: i64): () -> i64 __bit_xor(left, right)
