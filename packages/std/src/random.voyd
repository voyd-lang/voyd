//! Random-number and random-byte helpers backed by the host `Random` effect.
//! The host implementation is expected to provide cryptographically secure
//! randomness when available.

use std::array::Array
use std::bytes::ByteBuffer
use std::math::{ MathError, mod_euclid }
use std::msgpack::MsgPack
use std::msgpack::self as msgpack
use std::number::cast::{ to_f32, to_f64, to_i32_wrapping, to_i64 }
use std::optional::types::all
use std::range::Range

/// Host-provided random source effect.
///
/// The host random provider should use a secure entropy source when available.
/// `std::random` normalizes returned values into `i32` byte ranges where needed.
@effect(id: "voyd.std.random")
pub eff Random
  /// Returns a random signed 64-bit integer.
  next_i64(tail) -> i64
  /// Returns an array of random byte values with length `len`.
  ///
  /// Host values are expected to be i32 entries; callers should normalize each
  /// element into the `[0, 255]` range before treating them as bytes.
  fill_bytes(tail, len: i32) -> MsgPack

/// Returns a random 64-bit integer.
pub fn next_i64(): Random -> i64
  Random::next_i64()

/// Fills a byte buffer with cryptographically secure random bytes.
/// `len` controls the number of bytes appended to `buf`.
/// Example:
/// `let buf = ByteBuffer::new()`
/// `random::fill_bytes(buf, len: 16)`
/// `buf.len() == 16`
pub fn fill_bytes(~buf: ByteBuffer, len: i32): Random -> void
  if len <= 0:
    return void

  let payload = Random::fill_bytes(len)
  let decoded = msgpack::unpack_array(payload)

  var index = 0
  while index < len do:
    if index < decoded.len():
      match(decoded.get(index))
        Some<MsgPack> { value }:
          buf.push(mod_euclid_i32_or_zero(msgpack::unpack_i32(value), 256))
        None:
          let next = to_i32_wrapping(next_i64())
          buf.push(mod_euclid_i32_or_zero(next, 256))
    else:
      let next = to_i32_wrapping(next_i64())
      buf.push(mod_euclid_i32_or_zero(next, 256))
    index = index + 1

/// Fills a byte buffer with cryptographically secure random bytes.
pub fn fill_buffer(~buf: ByteBuffer, len: i32): Random -> void
  fill_bytes(buf, len)

/// Returns a random boolean value.
pub fn random_bool(): Random -> bool
  let value = random_i32()
  value % 2 == 0

/// Returns a random i32 value.
///
/// Default behavior (no range): samples across the full `i32` domain.
pub fn random_i32(): Random -> i32
  to_i32_wrapping(next_i64())

/// Returns a random i32 value within the provided range.
/// The range lower bound is inclusive. The upper bound follows `Range`:
/// exclusive by default, inclusive when `include_end` is true.
/// Example:
/// `random::random_i32(1..6)` samples values in `[1, 5]`.
pub fn random_i32(range: Range): Random -> i32
  let start = range_start_or_zero(range.start)
  let start_i64 = to_i64(start)
  let end_exclusive = range_end_exclusive(range, start_i64)
  if end_exclusive <= start_i64:
    return start

  let span = end_exclusive - start_i64
  let seed = next_i64()
  let sample = start_i64 + mod_euclid_i64_or_zero(seed, span)
  to_i32_wrapping(sample)

/// Returns a random i64 value.
///
/// Default behavior (no range): samples across the full `i64` domain.
pub fn random_i64(): Random -> i64
  next_i64()

/// Returns a random i64 value within the provided range.
///
/// The range lower bound is inclusive. The upper bound follows `Range`:
/// exclusive by default, inclusive when `include_end` is true.
pub fn random_i64(range: Range): Random -> i64
  let start_i64 = to_i64(range_start_or_zero(range.start))
  let end_exclusive = range_end_exclusive(range, start_i64)
  if end_exclusive <= start_i64:
    return start_i64

  let span = end_exclusive - start_i64
  let seed = next_i64()
  start_i64 + mod_euclid_i64_or_zero(seed, span)

/// Returns a random floating-point value in `[0.0, 1.0)`.
///
/// This no-argument overload is the default behavior.
pub fn random_f64(): Random -> f64
  random_f64_in_interval(to_i64(0), to_i64(1))

/// Returns a random floating-point value within the provided range.
///
/// The lower bound is inclusive. The upper bound follows `Range` semantics:
/// exclusive by default, inclusive when `include_end` is true.
/// Example:
/// `random::random_f64(0..10)` samples values in `[0.0, 10.0)`.
pub fn random_f64(range: Range): Random -> f64
  let start = range_start_or_zero(range.start)
  let start_i64 = to_i64(start)
  let end_exclusive = range_end_exclusive(range, start_i64)
  random_f64_in_interval(start_i64, end_exclusive)

/// Returns a random floating-point value in `[0.0, 1.0)` as `f32`.
///
/// This no-argument overload is the default behavior.
pub fn random_f32(): Random -> f32
  to_f32(random_f64())

/// Returns a random floating-point value within the provided range as `f32`.
///
/// The lower bound is inclusive. The upper bound follows `Range` semantics:
/// exclusive by default, inclusive when `include_end` is true.
pub fn random_f32(range: Range): Random -> f32
  to_f32(random_f64(range))

fn range_start_or_zero(start: Option<i32>) -> i32
  match(start)
    Some<i32> { value }:
      value
    None:
      0

fn range_end_exclusive(range: Range, start: i64) -> i64
  match(range.end)
    Some<i32> { value }:
      let end = to_i64(value)
      if range.include_end:
        end + to_i64(1)
      else:
        end
    None:
      start + to_i64(1)

fn mod_euclid_i32_or_zero(value: i32, modulus: i32) -> i32
  match(mod_euclid(value, modulus))
    Ok<i32> { value }:
      value
    Err<MathError>:
      0

fn mod_euclid_i64_or_zero(value: i64, modulus: i64) -> i64
  match(mod_euclid(value, modulus))
    Ok<i64> { value }:
      value
    Err<MathError>:
      to_i64(0)

fn random_f64_in_interval(start: i64, end_exclusive: i64): Random -> f64
  if end_exclusive <= start:
    return to_f64(start)

  let span = to_f64(end_exclusive - start)
  let start_f64 = to_f64(start)
  start_f64 + random_unit_f64() * span

fn random_unit_f64(): Random -> f64
  let seed = to_f64(next_i64())
  let shifted = seed + 9223372036854775808.0
  shifted / 18446744073709551616.0
