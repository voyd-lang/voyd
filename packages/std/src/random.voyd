//! Random-number and random-byte helpers backed by the host `Random` effect.
//! The host implementation is expected to provide cryptographically secure
//! randomness when available.

use std::array::Array
use std::bytes::ByteBuffer
use std::math::{ MathError, mod_euclid }
use std::msgpack::MsgPack
use std::msgpack::self as msgpack
use std::number::cast::{ to_i32_wrapping, to_i64 }
use std::optional::types::all
use std::subscript::Range

/// Host-provided random source effect.
///
/// The host random provider should use a secure entropy source when available.
/// `std::random` normalizes returned values into `i32` byte ranges where needed.
@effect(id: "voyd.std.random")
pub eff Random
  /// Returns a random signed 64-bit integer.
  next_i64(tail) -> i64
  /// Returns an array of random byte values with length `len`.
  ///
  /// Host values are expected to be i32 entries; callers should normalize each
  /// element into the `[0, 255]` range before treating them as bytes.
  fill_bytes(tail, len: i32) -> MsgPack

/// Returns a random 64-bit integer.
pub fn next_i64(): Random -> i64
  Random::next_i64()

/// Fills a byte buffer with cryptographically secure random bytes.
/// `len` controls the number of bytes appended to `buf`.
/// Example:
/// `let buf = ByteBuffer::new()`
/// `random::fill_bytes(buf, len: 16)`
/// `buf.len() == 16`
pub fn fill_bytes(~buf: ByteBuffer, len: i32): Random -> void
  if len <= 0:
    return void

  let payload = Random::fill_bytes(len)
  let decoded = msgpack::unpack_array(payload)

  var index = 0
  while index < len do:
    if index < decoded.len():
      match(decoded.get(index))
        Some<MsgPack> { value }:
          buf.push(mod_euclid_i32_or_zero(msgpack::unpack_i32(value), 256))
        None:
          let next = to_i32_wrapping(next_i64())
          buf.push(mod_euclid_i32_or_zero(next, 256))
    else:
      let next = to_i32_wrapping(next_i64())
      buf.push(mod_euclid_i32_or_zero(next, 256))
    index = index + 1

/// Fills a byte buffer with cryptographically secure random bytes.
pub fn fill_buffer(~buf: ByteBuffer, len: i32): Random -> void
  fill_bytes(buf, len)

/// Returns a random boolean value.
pub fn random_bool(): Random -> bool
  let value = to_i32_wrapping(next_i64())
  value % 2 == 0

/// Returns a random integer within the provided range.
/// The range lower bound is inclusive. The upper bound follows `Range`:
/// exclusive by default, inclusive when `include_end` is true.
/// Example:
/// `random::random_int(1..6)` samples values in `[1, 5]`.
pub fn random_int(range: Range): Random -> i32
  let start = range_start_or_zero(range.start)
  let start_i64 = to_i64(start)
  let end_exclusive = range_end_exclusive(range, start_i64)
  if end_exclusive <= start_i64:
    return start

  let span = end_exclusive - start_i64
  let seed = next_i64()
  let sample = start_i64 + mod_euclid_i64_or_zero(seed, span)
  to_i32_wrapping(sample)

fn range_start_or_zero(start: Option<i32>) -> i32
  match(start)
    Some<i32> { value }:
      value
    None:
      0

fn range_end_exclusive(range: Range, start: i64) -> i64
  match(range.end)
    Some<i32> { value }:
      let end = to_i64(value)
      if range.include_end:
        end + to_i64(1)
      else:
        end
    None:
      start + to_i64(1)

fn mod_euclid_i32_or_zero(value: i32, modulus: i32) -> i32
  match(mod_euclid(value, modulus))
    Ok<i32> { value }:
      value
    Err<MathError>:
      0

fn mod_euclid_i64_or_zero(value: i64, modulus: i64) -> i64
  match(mod_euclid(value, modulus))
    Ok<i64> { value }:
      value
    Err<MathError>:
      to_i64(0)
