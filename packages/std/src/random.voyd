use std::array::Array
use std::bytes::ByteBuffer
use std::msgpack::MsgPack
use std::msgpack::self as msgpack
use std::optional::types::all
use std::subscript::Range

@effect(id: "std::random::Random")
pub eff Random
  next_i64(tail) -> i64
  fill_bytes(tail, len: i32) -> MsgPack

/// Returns a random 64-bit integer.
pub fn next_i64(): Random -> i64
  Random::next_i64()

/// Fills a byte buffer with cryptographically secure random bytes.
pub fn fill_bytes(~buf: ByteBuffer, len: i32): Random -> void
  if len <= 0 then:
    return void

  let payload = Random::fill_bytes(len)
  let decoded = msgpack::unpack_array(payload)

  var index = 0
  while index < len do:
    if index < decoded.len() then:
      match(decoded.get(index))
        Some<MsgPack> { value }:
          buf.push(value: mod_i32(msgpack::unpack_i32(value), 256))
        None:
          let next = wrap_i64(next_i64())
          buf.push(value: mod_i32(next, 256))
    else:
      let next = wrap_i64(next_i64())
      buf.push(value: mod_i32(next, 256))
    index = index + 1

/// Fills a byte buffer with cryptographically secure random bytes.
pub fn fill_buffer(~buf: ByteBuffer, len: i32): Random -> void
  fill_bytes(buf, len)

/// Returns a random boolean value.
pub fn random_bool(): Random -> bool
  let value = wrap_i64(next_i64())
  mod_i32(value, 2) == 0

/// Returns a random integer within the provided range.
pub fn random_int({ range: Range }): Random -> i32
  let start = range_start_or_zero(range.start)
  let start_i64 = extend_i32_s(start)
  let end_exclusive = range_end_exclusive(range, start_i64)
  if end_exclusive <= start_i64 then:
    return start

  let span = end_exclusive - start_i64
  let seed = next_i64()
  let sample = start_i64 + mod_i64(seed, span)
  wrap_i64(sample)

fn range_start_or_zero(start: Option<i32>) -> i32
  match(start)
    Some<i32> { value }:
      value
    None:
      0

fn range_end_exclusive(range: Range, start: i64) -> i64
  match(range.end)
    Some<i32> { value }:
      let end = extend_i32_s(value)
      if range.include_end then:
        end + extend_i32_s(1)
      else:
        end
    None:
      start + extend_i32_s(1)

fn mod_i32(value: i32, modulus: i32) -> i32
  if modulus <= 0 then:
    return 0
  let div = value / modulus
  let rem = value - div * modulus
  if rem < 0 then: rem + modulus else: rem

fn mod_i64(value: i64, modulus: i64) -> i64
  if modulus <= extend_i32_s(0) then:
    return extend_i32_s(0)
  let div = value / modulus
  let rem = value - div * modulus
  if rem < extend_i32_s(0) then: rem + modulus else: rem

fn wrap_i64(value: i64): () -> i32 __i32_wrap_i64(value)
fn extend_i32_s(value: i32): () -> i64 __i64_extend_s(value)
