use std::array::{ Array, new_array_unchecked }
use std::dict::Dict
use std::string::{ String, new_string }
use std::test::assertions::all

test "json parse handles objects, arrays, booleans, and numbers":
  let input = from_ascii([
    123,34,111,107,34,58,116,114,117,101,44,34,110,34,58,49,50,44,
    34,97,114,114,34,58,91,102,97,108,115,101,44,110,117,108,108,93,125
  ])

  match(parse(s: input.as_slice()))
    Ok<JsonValue> { value }:
      value.match(root)
        JsonObject:
          assert(root.value.contains_key(key: "ok"), eq: true)
          assert(root.value.contains_key(key: "n"), eq: true)
          assert(root.value.contains_key(key: "arr"), eq: true)
        else:
          assert(false, eq: true)
    Err<JsonError>:
      assert(false, eq: true)

test "json parse decodes escaped strings":
  let input = from_ascii([34,108,105,110,101,92,110,34])
  let expected = from_ascii([108,105,110,101,10])

  match(parse(s: input.as_slice()))
    Ok<JsonValue> { value }:
      value.match(root)
        JsonString:
          assert(root.value.equals(expected), eq: true)
        else:
          assert(false, eq: true)
    Err<JsonError>:
      assert(false, eq: true)

test "json parse decodes escaped surrogate pairs":
  let input = from_ascii([34,92,117,68,56,51,68,92,117,68,69,48,48,34])
  let expected = from_ascii([240,159,152,128])

  match(parse(s: input.as_slice()))
    Ok<JsonValue> { value }:
      value.match(root)
        JsonString:
          assert(root.value.equals(expected), eq: true)
        else:
          assert(false, eq: true)
    Err<JsonError>:
      assert(false, eq: true)

test "json parse keeps escapes after unmatched high surrogate":
  let input = from_ascii([34,92,117,68,56,51,68,92,117,48,48,52,49,34])
  let expected = from_ascii([239,191,189,65])

  match(parse(s: input.as_slice()))
    Ok<JsonValue> { value }:
      value.match(root)
        JsonString:
          assert(root.value.equals(expected), eq: true)
        else:
          assert(false, eq: true)
    Err<JsonError>:
      assert(false, eq: true)

test "json parse rejects invalid input":
  match(parse(s: "{".as_slice()))
    Ok<JsonValue>:
      assert(false, eq: true)
    Err<JsonError> { error }:
      assert(error.message.contains(substring: "json parse error"), eq: true)

test "json parse rejects oversized exponents":
  match(parse(s: "1e100000000".as_slice()))
    Ok<JsonValue>:
      assert(false, eq: true)
    Err<JsonError>:
      assert(true, eq: true)

test "json parse preserves subnormal magnitudes":
  match(parse(s: "1e-309".as_slice()))
    Ok<JsonValue> { value }:
      value.match(root)
        JsonNumber:
          assert(root.value > 0.0, eq: true)
        else:
          assert(false, eq: true)
    Err<JsonError>:
      assert(false, eq: true)

test "json parse rejects overflowing mantissas":
  let too_large = repeat_byte(57, 500)
  match(parse(s: too_large.as_slice()))
    Ok<JsonValue>:
      assert(false, eq: true)
    Err<JsonError>:
      assert(true, eq: true)

test "json parse accepts long fractional mantissas":
  let input = long_fraction_input(49, 400)
  match(parse(s: input.as_slice()))
    Ok<JsonValue> { value }:
      value.match(root)
        JsonNumber:
          assert(root.value > 0.0, eq: true)
          assert(root.value < 1.0, eq: true)
        else:
          assert(false, eq: true)
    Err<JsonError>:
      assert(false, eq: true)

test "json parse allows zero mantissa with large exponent":
  match(parse(s: "0e309".as_slice()))
    Ok<JsonValue> { value }:
      value.match(root)
        JsonNumber:
          assert(root.value, eq: 0.0)
        else:
          assert(false, eq: true)
    Err<JsonError>:
      assert(false, eq: true)

  match(parse(s: "-0e400".as_slice()))
    Ok<JsonValue> { value }:
      value.match(root)
        JsonNumber:
          assert(root.value, eq: 0.0)
        else:
          assert(false, eq: true)
    Err<JsonError>:
      assert(false, eq: true)

test "json stringify emits compact object envelope":
  let ~fields = Dict<String, JsonValue>::init()
  fields.set(key: "ok", value: JsonBool { value: true })
  fields.set(key: "count", value: JsonNumber { value: 12.5 })

  let ~items = Array<JsonValue>::with_capacity(2)
  items.push(value: JsonString { value: "x" })
  items.push(value: JsonNull {})
  fields.set(key: "items", value: JsonArray { value: items })

  let value = JsonObject { value: fields }
  let compact = stringify(value: value)

  assert(compact.starts_with(prefix: "{"), eq: true)
  assert(compact.ends_with(suffix: "}"), eq: true)

test "json stringify includes object keys":
  let ~fields = Dict<String, JsonValue>::init()
  fields.set(key: "ok", value: JsonBool { value: true })
  fields.set(key: "count", value: JsonNumber { value: 12.5 })

  let ~items = Array<JsonValue>::with_capacity(2)
  items.push(value: JsonString { value: "x" })
  items.push(value: JsonNull {})
  fields.set(key: "items", value: JsonArray { value: items })

  let value = JsonObject { value: fields }
  let compact = stringify(value: value)

  match(parse(s: compact.as_slice()))
    Ok<JsonValue> { value: roundtrip }:
      roundtrip.match(root)
        JsonObject:
          assert(root.value.contains_key(key: "ok"), eq: true)
          assert(root.value.contains_key(key: "count"), eq: true)
          assert(root.value.contains_key(key: "items"), eq: true)
        else:
          assert(false, eq: true)
    Err<JsonError>:
      assert(false, eq: true)

test "json stringify_pretty emits newlines":
  let ~fields = Dict<String, JsonValue>::init()
  fields.set(key: "ok", value: JsonBool { value: true })
  fields.set(key: "count", value: JsonNumber { value: 12.5 })

  let ~items = Array<JsonValue>::with_capacity(2)
  items.push(value: JsonString { value: "x" })
  items.push(value: JsonNull {})
  fields.set(key: "items", value: JsonArray { value: items })

  let value = JsonObject { value: fields }
  let pretty = stringify_pretty(value: value)

  assert(pretty.contains(substring: from_ascii([10])), eq: true)

test "json stringify falls back for non-finite numbers":
  let nan_text = stringify(value: JsonNumber { value: 0.0 / 0.0 })
  let inf_text = stringify(value: JsonNumber { value: 1.0 / 0.0 })
  let neg_inf_text = stringify(value: JsonNumber { value: (0.0 - 1.0) / 0.0 })

  assert(nan_text.equals("0"), eq: true)
  assert(inf_text.equals("0"), eq: true)
  assert(neg_inf_text.equals("0"), eq: true)

test "json stringify preserves magnitude for large finite numbers":
  var huge = 1.0
  var index = 0
  while index < 20 do:
    huge = huge * 10.0
    index = index + 1

  let encoded = stringify(value: JsonNumber { value: huge })
  match(parse(s: encoded.as_slice()))
    Ok<JsonValue> { value }:
      value.match(root)
        JsonNumber:
          let ratio = root.value / huge
          assert(ratio > 0.999999999, eq: true)
          assert(ratio < 1.000000001, eq: true)
        else:
          assert(false, eq: true)
    Err<JsonError>:
      assert(false, eq: true)

test "json stringify preserves tiny non-zero magnitude":
  var tiny = 1.0
  var index = 0
  while index < 14 do:
    tiny = tiny / 10.0
    index = index + 1

  let encoded = stringify(value: JsonNumber { value: tiny })
  assert(encoded.equals("0"), eq: false)
  assert(encoded.equals("-0"), eq: false)

  match(parse(s: encoded.as_slice()))
    Ok<JsonValue> { value }:
      value.match(root)
        JsonNumber:
          let ratio = root.value / tiny
          assert(ratio > 0.999999999, eq: true)
          assert(ratio < 1.000000001, eq: true)
        else:
          assert(false, eq: true)
    Err<JsonError>:
      assert(false, eq: true)

test "json stringify preserves extended fractional precision":
  let source = JsonNumber { value: 0.1234567890123456 }
  let encoded = stringify(value: source)
  assert(encoded.equals("0.123456789012"), eq: false)

  match(parse(s: encoded.as_slice()))
    Ok<JsonValue> { value }:
      value.match(root)
        JsonNumber:
          let ratio = root.value / 0.1234567890123456
          assert(ratio > 0.999999999999, eq: true)
          assert(ratio < 1.000000000001, eq: true)
        else:
          assert(false, eq: true)
    Err<JsonError>:
      assert(false, eq: true)

test "json stringify preserves subnormal numbers":
  var tiny = 1.0
  var index = 0
  while index < 309 do:
    tiny = tiny / 10.0
    index = index + 1

  let encoded = stringify(value: JsonNumber { value: tiny })
  assert(encoded.equals("0"), eq: false)
  assert(encoded.equals("-0"), eq: false)

  match(parse(s: encoded.as_slice()))
    Ok<JsonValue> { value }:
      value.match(root)
        JsonNumber:
          assert(root.value > 0.0, eq: true)
        else:
          assert(false, eq: true)
    Err<JsonError>:
      assert(false, eq: true)

fn from_ascii(bytes: Array<i32>): () -> String
  new_string(bytes.to_fixed_array())

fn repeat_byte(byte: i32, count: i32): () -> String
  let ~bytes = Array<i32>::with_capacity(count)
  var index = 0
  while index < count do:
    bytes.push(byte)
    index = index + 1
  new_string(bytes.to_fixed_array())

fn long_fraction_input(digit: i32, digits: i32): () -> String
  let ~bytes = Array<i32>::with_capacity(digits + 2)
  bytes.push(48)
  bytes.push(46)

  var index = 0
  while index < digits do:
    bytes.push(digit)
    index = index + 1

  new_string(bytes.to_fixed_array())
