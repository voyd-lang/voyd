use std::array::{ Array, new_array_unchecked }
use std::optional::types::all
use std::string::type::{ String, from_utf8, Utf8Error, new_string }
use std::test::assertions::all

obj EachStats {
  count: i32,
  sum: i32,
  has_a: bool
}

obj IntKey {
  value: i32
}

impl IntKey
  fn '=='(self, other: IntKey) -> bool
    self.value == other.value

impl DictKey<IntKey> for IntKey
  /// Returns the hash code used for dictionary key bucketing.
  api fn dict_hash(self) -> i32
    self.value

  /// Compares this key with another key for dictionary equality.
  api fn dict_eq(self, other: IntKey) -> bool
    self.value == other.value

obj CollidingKey {
  value: i32
}

impl DictKey<CollidingKey> for CollidingKey
  /// Returns the hash code used for dictionary key bucketing.
  api fn dict_hash(self) -> i32
    7

  /// Compares this key with another key for dictionary equality.
  api fn dict_eq(self, other: CollidingKey) -> bool
    self.value == other.value

fn must_utf8(bytes: Array<i32>) -> String
  match(from_utf8(bytes))
    Ok<String> { value }:
      value
    Err<Utf8Error>:
      assert(false)
      String::init()

fn make_test_key(index: i32) -> String
  let a = index / 26
  let b = index - a * 26
  must_utf8([97 + a, 97 + b])

fn array_of_5(a: i32, b: i32, c: i32, d: i32, e: i32) -> Array<i32>
  let ~out = Array<i32>::with_capacity(5)
  out.push(a)
  out.push(b)
  out.push(c)
  out.push(d)
  out.push(e)
  out

test "dict init is empty":
  let map = Dict<String, i32>::init()
  assert(map.len(), eq: 0)
  assert(map.is_empty(), eq: true)

test "dict with_capacity supports inserts":
  let ~map = Dict<IntKey, i32>::with_capacity(40)
  var index = 0
  while index < 40 do:
    map.set(IntKey { value: index }, index)
    index = index + 1
  assert(map.len(), eq: 40)

  match(map.get(IntKey { value: 10 }))
    Some<i32> { value }:
      assert(value, eq: 10)
    None:
      assert(false)

test "dict with_capacity clamps unsafe sizes":
  let huge = Dict<IntKey, i32>::with_capacity(2147483647)
  assert(bucket_count_of(huge), eq: 65536)

  let negative = Dict<IntKey, i32>::with_capacity(-7)
  assert(bucket_count_of(negative), eq: 16)

test "dict set insert get contains remove clear":
  let ~map = Dict<String, i32>::init()
  map.set("a", 1)
  let previous = map.insert("a", 2)
  match(previous)
    Some<i32> { value }:
      assert(value, eq: 1)
    None:
      assert(false)

  assert(map.contains("a"), eq: true)
  match(map.get("a"))
    Some<i32> { value }:
      assert(value, eq: 2)
    None:
      assert(false)

  let removed = map.remove("a")
  match(removed)
    Some<i32> { value }:
      assert(value, eq: 2)
    None:
      assert(false)

  assert(map.contains("a"), eq: false)
  map.set("x", 9)
  map.clear()
  assert(map.len(), eq: 0)

test "dict keys values entries each":
  let ~map = Dict<String, i32>::init()
  map.set("a", 1)
  map.set("b", 2)
  map.set("c", 3)

  let keys = map.keys()
  let values = map.values()
  let entries = map.entries()
  assert(keys.len(), eq: 3)
  assert(values.len(), eq: 3)
  assert(entries.len(), eq: 3)

  let ~stats = EachStats { count: 0, sum: 0, has_a: false }
  map.each((key: String, value: i32) -> void =>
    stats.count = stats.count + 1
    stats.sum = stats.sum + value
    if key.equals("a"):
      stats.has_a = true
    void
  )
  assert(stats.count, eq: 3)
  assert(stats.sum, eq: 6)
  assert(stats.has_a, eq: true)

test "dict extend merged merge":
  let ~left = Dict<String, i32>::init()
  left.set("a", 1)
  let ~right = Dict<String, i32>::init()
  right.set("b", 2)
  right.set("a", 9)
  let merged = left.merged(
    right,
    (_key: String, l: i32, r: i32) -> i32 => l + r
  )
  let ~out = merged
  out.merge(merged, (_k: String, l: i32, r: i32) -> i32 => l + r)
  match(out.get("a"))
    Some<i32> { value }:
      assert(value, eq: 20)
    None:
      assert(false)
  match(out.get("b"))
    Some<i32> { value }:
      assert(value, eq: 4)
    None:
      assert(false)

test "dict map and filter":
  let ~map = Dict<String, i32>::init()
  map.set("a", 1)
  map.set("b", 2)
  map.set("c", 3)

  let mapped = map.map<i32>((_k: String, v: i32) -> i32 => v * 10)
  match(mapped.get("b"))
    Some<i32> { value }:
      assert(value, eq: 20)
    None:
      assert(false)

  let filtered = map.filter((_k: String, v: i32) -> bool => v >= 2)
  assert(filtered.len(), eq: 2)
  assert(filtered.contains("a"), eq: false)

test "dict entry helpers":
  let base = Dict<String, i32>::init()

  let next = base.entry("kiwi").or_insert(0)
  match(next.get("kiwi"))
    Some<i32> { value }:
      assert(value, eq: 0)
    None:
      assert(false)

  let next2 = next.entry("kiwi").and_modify((v: i32) -> i32 => v + 1).dict
  match(next2.get("kiwi"))
    Some<i32> { value }:
      assert(value, eq: 1)
    None:
      assert(false)

  let next3 = next2.entry("pear").or_insert_with(() -> i32 => 42)
  match(next3.get("pear"))
    Some<i32> { value }:
      assert(value, eq: 42)
    None:
      assert(false)

  let removed = next3.entry("pear").remove()
  match(removed)
    Some<i32> { value }:
      assert(value, eq: 42)
    None:
      assert(false)

test "dict grows and preserves entries":
  let ~map = Dict<IntKey, i32>::init()
  var index = 0
  while index < 80 do:
    map.set(IntKey { value: index }, index)
    index = index + 1
  assert(map.len(), eq: 80)

  match(map.get(IntKey { value: 0 }))
    Some<i32> { value }:
      assert(value, eq: 0)
    None:
      assert(false)

  match(map.get(IntKey { value: 79 }))
    Some<i32> { value }:
      assert(value, eq: 79)
    None:
      assert(false)

test "dict supports non-string key type":
  let ~map = Dict<IntKey, i32>::init()
  map.set(IntKey { value: 1 }, 10)
  map.set(IntKey { value: 2 }, 20)

  match(map.get(IntKey { value: 1 }))
    Some<i32> { value }:
      assert(value, eq: 10)
    None:
      assert(false)

test "dict handles colliding custom key hashes":
  let ~map = Dict<CollidingKey, i32>::init()
  map.set(CollidingKey { value: 1 }, 10)
  map.set(CollidingKey { value: 2 }, 20)
  map.set(CollidingKey { value: 3 }, 30)
  assert(map.len(), eq: 3)
  match(map.get(CollidingKey { value: 2 }))
    Some<i32> { value }:
      assert(value, eq: 20)
    None:
      assert(false)

test "array group_by groups values by key":
  let grouped = array_of_5(1, 2, 3, 4, 5).group_by<String>((value: i32) -> String =>
    let half = value / 2
    if half * 2 == value then: "even" else: "odd"
  )

  match(grouped.get("even"))
    Some<Array<i32>> { value }:
      assert(value.len(), eq: 2)
    None:
      assert(false)

  match(grouped.get("odd"))
    Some<Array<i32>> { value }:
      assert(value.len(), eq: 3)
    None:
      assert(false)

fn bucket_count_of<K: DictKey<K>, V>(dict: Dict<K, V>) -> i32
  __array_len(dict.buckets)
