//! Floating-point and numeric helper APIs used by `std::math`.
//! Functions in this module favor direct Wasm intrinsics for predictable
//! runtime behavior across hosts.

use std::result::types::all
use std::math::errors::{ MathError, math_error, math_error_code_overflow }

/// Returns the absolute value, rejecting signed overflow.
pub fn abs(value: i32) -> Result<i32, MathError>
  if value >= 0:
    return Ok<i32> { value }
  let out = 0 - value
  if out < 0:
    return math_error(code: math_error_code_overflow())
  Ok<i32> { value: out }

/// Returns the absolute value, rejecting signed overflow.
pub fn abs(value: i64) -> Result<i64, MathError>
  if value >= extend_i32_s(0):
    return Ok<i64> { value }
  let out = extend_i32_s(0) - value
  if out < extend_i32_s(0):
    return math_error(code: math_error_code_overflow())
  Ok<i64> { value: out }

/// Returns the absolute value.
pub fn abs(value: f64) -> f64
  if value <= 0.0 then: 0.0 - value else: value

/// Returns the absolute value.
pub fn abs(value: f32) -> f32
  demote_f64(abs(promote_f32(value)))

/// Returns the sign of `value` as `-1`, `0`, or `1`.
pub fn signum(value: i32) -> i32
  if
    value < 0: -1
    value > 0: 1
    else: 0

/// Returns the sign of `value` as `-1`, `0`, or `1`.
pub fn signum(value: i64) -> i64
  if
    value < extend_i32_s(0): extend_i32_s(-1)
    value > extend_i32_s(0): extend_i32_s(1)
    else: extend_i32_s(0)

/// Returns the sign of `value` as `-1`, `0`, or `1`.
/// Returns `NaN` unchanged.
pub fn signum(value: f64) -> f64
  if value != value:
    return value
  if
    value < 0.0: -1.0
    value > 0.0: 1.0
    else: 0.0

/// Returns the sign of `value` as `-1`, `0`, or `1`.
/// Returns `NaN` unchanged.
pub fn signum(value: f32) -> f32
  demote_f64(signum(promote_f32(value)))

/// Rounds `value` down to the nearest integer.
pub fn floor(value: f64) -> f64
  floor_f64(value)

/// Rounds `value` down to the nearest integer.
pub fn floor(value: f32) -> f32
  floor_f32(value)

/// Rounds `value` up to the nearest integer.
pub fn ceil(value: f64) -> f64
  ceil_f64(value)

/// Rounds `value` up to the nearest integer.
pub fn ceil(value: f32) -> f32
  ceil_f32(value)

/// Rounds `value` to the nearest integer using ties-to-even semantics.
pub fn round(value: f64) -> f64
  round_f64(value)

/// Rounds `value` to the nearest integer using ties-to-even semantics.
pub fn round(value: f32) -> f32
  round_f32(value)

/// Rounds `value` toward zero.
pub fn trunc(value: f64) -> f64
  trunc_f64(value)

/// Rounds `value` toward zero.
pub fn trunc(value: f32) -> f32
  trunc_f32(value)

/// Returns the fractional component of `value`.
pub fn fract(value: f64) -> f64
  value - trunc(value)

/// Returns the fractional component of `value`.
pub fn fract(value: f32) -> f32
  value - trunc(value)

/// Returns the square root of `value`.
pub fn sqrt(value: f64) -> f64
  sqrt_f64(value)

/// Returns the square root of `value`.
pub fn sqrt(value: f32) -> f32
  sqrt_f32(value)

/// Returns the Euclidean norm of `(x, y)`: `sqrt(x*x + y*y)`.
pub fn hypot(x: f64, y: f64) -> f64
  sqrt((x * x) + (y * y))

/// Returns the Euclidean norm of `(x, y)`: `sqrt(x*x + y*y)`.
pub fn hypot(x: f32, y: f32) -> f32
  sqrt((x * x) + (y * y))

/// Raises `value` to the power of `exponent`.
pub fn pow(value: f64, exponent: f64) -> f64
  pow_f64(value, exponent)

/// Raises `value` to the power of `exponent`.
pub fn pow(value: f32, exponent: f32) -> f32
  demote_f64(pow(promote_f32(value), promote_f32(exponent)))

/// Returns the sine of `value` (radians).
pub fn sin(value: f64) -> f64
  sin_f64(value)

/// Returns the sine of `value` (radians).
pub fn sin(value: f32) -> f32
  demote_f64(sin(promote_f32(value)))

/// Returns the cosine of `value` (radians).
pub fn cos(value: f64) -> f64
  cos_f64(value)

/// Returns the cosine of `value` (radians).
pub fn cos(value: f32) -> f32
  demote_f64(cos(promote_f32(value)))

/// Returns the tangent of `value` (radians).
pub fn tan(value: f64) -> f64
  tan_f64(value)

/// Returns the tangent of `value` (radians).
pub fn tan(value: f32) -> f32
  demote_f64(tan(promote_f32(value)))

/// Returns the angle in radians between the positive x-axis and `(x, y)`.
/// Parameter order follows `atan2(y, x)`.
pub fn atan2(y: f64, x: f64) -> f64
  atan2_f64(y, x)

/// Returns the angle in radians between the positive x-axis and `(x, y)`.
/// Parameter order follows `atan2(y, x)`.
pub fn atan2(y: f32, x: f32) -> f32
  demote_f64(atan2(promote_f32(y), promote_f32(x)))

/// Returns the natural logarithm (base e).
pub fn ln(value: f64) -> f64
  ln_f64(value)

/// Returns the natural logarithm (base e).
pub fn ln(value: f32) -> f32
  demote_f64(ln(promote_f32(value)))

/// Returns the base-2 logarithm.
pub fn log2(value: f64) -> f64
  log2_f64(value)

/// Returns the base-2 logarithm.
pub fn log2(value: f32) -> f32
  demote_f64(log2(promote_f32(value)))

/// Returns the base-10 logarithm.
pub fn log10(value: f64) -> f64
  log10_f64(value)

/// Returns the base-10 logarithm.
pub fn log10(value: f32) -> f32
  demote_f64(log10(promote_f32(value)))

/// Returns e raised to `value`.
pub fn exp(value: f64) -> f64
  exp_f64(value)

/// Returns e raised to `value`.
pub fn exp(value: f32) -> f32
  demote_f64(exp(promote_f32(value)))

/// Returns true when `value` is `NaN`.
pub fn is_nan(value: f64) -> bool
  value != value

/// Returns true when `value` is `NaN`.
pub fn is_nan(value: f32) -> bool
  is_nan(promote_f32(value))

/// Returns true when `value` is finite.
/// Finite means not `NaN` and not positive/negative infinity.
pub fn is_finite(value: f64) -> bool
  let gap = value - value
  gap == 0.0

/// Returns true when `value` is finite.
pub fn is_finite(value: f32) -> bool
  is_finite(promote_f32(value))

/// Returns true when `value` is infinite.
pub fn is_infinite(value: f64) -> bool
  not is_nan(value) and not is_finite(value)

/// Returns true when `value` is infinite.
pub fn is_infinite(value: f32) -> bool
  is_infinite(promote_f32(value))

@intrinsic(name: "__f32_demote_f64")
fn demote_f64(value: f64): () -> f32 __f32_demote_f64(value)

@intrinsic(name: "__f64_promote_f32")
fn promote_f32(value: f32): () -> f64 __f64_promote_f32(value)

@intrinsic(name: "__floor")
fn floor_f64(value: f64): () -> f64 __floor(value)

@intrinsic(name: "__floor")
fn floor_f32(value: f32): () -> f32 __floor(value)

@intrinsic(name: "__ceil")
fn ceil_f64(value: f64): () -> f64 __ceil(value)

@intrinsic(name: "__ceil")
fn ceil_f32(value: f32): () -> f32 __ceil(value)

@intrinsic(name: "__round")
fn round_f64(value: f64): () -> f64 __round(value)

@intrinsic(name: "__round")
fn round_f32(value: f32): () -> f32 __round(value)

@intrinsic(name: "__trunc")
fn trunc_f64(value: f64): () -> f64 __trunc(value)

@intrinsic(name: "__trunc")
fn trunc_f32(value: f32): () -> f32 __trunc(value)

@intrinsic(name: "__sqrt")
fn sqrt_f64(value: f64): () -> f64 __sqrt(value)

@intrinsic(name: "__sqrt")
fn sqrt_f32(value: f32): () -> f32 __sqrt(value)

@intrinsic(name: "__pow")
fn pow_f64(value: f64, exponent: f64): () -> f64 __pow(value, exponent)

@intrinsic(name: "__sin")
fn sin_f64(value: f64): () -> f64 __sin(value)

@intrinsic(name: "__cos")
fn cos_f64(value: f64): () -> f64 __cos(value)

@intrinsic(name: "__tan")
fn tan_f64(value: f64): () -> f64 __tan(value)

@intrinsic(name: "__atan2")
fn atan2_f64(y: f64, x: f64): () -> f64 __atan2(y, x)

@intrinsic(name: "__ln")
fn ln_f64(value: f64): () -> f64 __ln(value)

@intrinsic(name: "__log2")
fn log2_f64(value: f64): () -> f64 __log2(value)

@intrinsic(name: "__log10")
fn log10_f64(value: f64): () -> f64 __log10(value)

@intrinsic(name: "__exp")
fn exp_f64(value: f64): () -> f64 __exp(value)

fn extend_i32_s(value: i32): () -> i64 __i64_extend_s(value)
