//! JSON value model and UTF-8 parser/serializer helpers.
//! Use `parse` to decode JSON text into `JsonValue` and `stringify`/`stringify_pretty`
//! to encode values back to text.

use std::array::Array
use std::dict::Dict
use std::number::cast::self as number_cast
use std::optional::types::all
use std::result::types::{ Result, Ok, Err }
use std::string::{ String, StringSlice, new_string }

pub use std::error::JsonError

/// Represents the JSON `null` literal.
pub obj JsonNull {}

/// Represents a JSON boolean literal.
pub obj JsonBool {
  /// Stored boolean payload.
  api value: bool
}

/// Represents a JSON number.
pub obj JsonNumber {
  /// Stored numeric payload.
  api value: f64
}

/// Represents a JSON string.
pub obj JsonString {
  /// Stored string payload.
  api value: String
}

/// Represents a JSON array.
pub obj JsonArray {
  /// Stored element values.
  api value: Array<JsonValue>
}

/// Represents a JSON object keyed by strings.
pub obj JsonObject {
  /// Stored object fields.
  api value: Dict<String, JsonValue>
}

/// Tagged union over all supported JSON value variants.
pub type JsonValue = JsonNull | JsonBool | JsonNumber | JsonString | JsonArray | JsonObject

obj JsonParser {
  source: String,
  index: i32
}

/// Parses UTF-8 JSON text into a `JsonValue`.
///
/// Params:
/// - `source`: JSON source text.
///
/// Returns:
/// - `Ok<JsonValue>` when the full input parses successfully.
/// - `Err<JsonError>` for malformed JSON or trailing characters.
///
/// Example:
/// ```voyd
/// use std::json
///
/// let parsed = json::parse("{\"ok\":true}")
/// ```
pub fn parse(source: String) -> Result<JsonValue, JsonError>
  let ~parser = JsonParser { source: source, index: 0 }
  skip_whitespace(parser)
  let value_result = parse_value(parser)
  match(value_result)
    Ok<JsonValue> { value }:
      skip_whitespace(parser)
      if parser.index != parser.source.as_slice().byte_len():
        return Err<JsonError> { error: json_error("json parse error: trailing characters") }
      Ok<JsonValue> { value: value }
    Err<JsonError> { error }:
      Err<JsonError> { error: error }

pub fn parse(source: StringSlice) -> Result<JsonValue, JsonError>
  parse(source.to_string())

/// Serializes a `JsonValue` to compact JSON text.
///
/// Params:
/// - `value`: JSON value to serialize.
///
/// Example:
/// ```voyd
/// use std::json
///
/// let text = json::stringify(JsonBool { value: true })
/// ```
pub fn stringify(value: JsonValue) -> String
  let ~bytes = Array<i32>::with_capacity(64)
  write_json_value(bytes, value, false, 0)
  new_string(bytes.to_fixed_array())

/// Serializes a `JsonValue` to pretty JSON text with indentation.
///
/// Params:
/// - `value`: JSON value to serialize.
pub fn stringify_pretty(value: JsonValue) -> String
  let ~bytes = Array<i32>::with_capacity(64)
  write_json_value(bytes, value, true, 0)
  new_string(bytes.to_fixed_array())

fn parse_value(~parser: JsonParser): () -> Result<JsonValue, JsonError>
  skip_whitespace(parser)
  match(peek(parser))
    Some<i32> { value: byte }:
      if byte == 110:
        return parse_literal_null(parser)
      if byte == 116:
        return parse_literal_true(parser)
      if byte == 102:
        return parse_literal_false(parser)
      if byte == 34:
        return parse_string_value(parser)
      if byte == 91:
        return parse_array(parser)
      if byte == 123:
        return parse_object(parser)
      parse_number(parser)
    None:
      Err<JsonError> { error: json_error("json parse error: unexpected end of input") }

fn parse_literal_null(~parser: JsonParser): () -> Result<JsonValue, JsonError>
  if consume_literal(parser, "null"):
    return Ok<JsonValue> { value: JsonNull {} }
  Err<JsonError> { error: json_error("json parse error: invalid literal") }

fn parse_literal_true(~parser: JsonParser): () -> Result<JsonValue, JsonError>
  if consume_literal(parser, "true"):
    return Ok<JsonValue> { value: JsonBool { value: true } }
  Err<JsonError> { error: json_error("json parse error: invalid literal") }

fn parse_literal_false(~parser: JsonParser): () -> Result<JsonValue, JsonError>
  if consume_literal(parser, "false"):
    return Ok<JsonValue> { value: JsonBool { value: false } }
  Err<JsonError> { error: json_error("json parse error: invalid literal") }

fn parse_string_value(~parser: JsonParser): () -> Result<JsonValue, JsonError>
  match(parse_string(parser))
    Ok<String> { value }:
      Ok<JsonValue> { value: JsonString { value: value } }
    Err<JsonError> { error }:
      Err<JsonError> { error: error }

fn parse_string(~parser: JsonParser): () -> Result<String, JsonError>
  if not consume_byte(parser, 34):
    return Err<JsonError> { error: json_error("json parse error: expected string") }

  let ~bytes = Array<i32>::with_capacity(16)
  while true do:
    let byte = next_byte_or(parser, -1)
    if byte < 0:
      return Err<JsonError> { error: json_error("json parse error: unterminated string") }
    if byte == 34:
      return string_from_utf8(bytes)
    if byte == 92:
      let escaped = next_byte_or(parser, -1)
      if escaped < 0:
        return Err<JsonError> { error: json_error("json parse error: unterminated escape") }
      let append_result = append_escaped(bytes, escaped, parser)
      if append_result != 0:
        return Err<JsonError> { error: json_error("json parse error: invalid string escape") }
      continue
    if byte < 32:
      return Err<JsonError> {
        error: json_error("json parse error: unescaped control character in string")
      }
    bytes.push(byte)

  Err<JsonError> { error: json_error("json parse error: unterminated string") }

fn parse_array(~parser: JsonParser): () -> Result<JsonValue, JsonError>
  parser.index = parser.index + 1
  skip_whitespace(parser)

  let ~items = Array<JsonValue>::with_capacity(4)
  if consume_byte(parser, 93):
    return Ok<JsonValue> { value: JsonArray { value: items } }

  while true do:
    match(parse_value(parser))
      Ok<JsonValue> { value }:
        items.push(value)
      Err<JsonError> { error }:
        return Err<JsonError> { error: error }

    skip_whitespace(parser)
    if consume_byte(parser, 44):
      skip_whitespace(parser)
      continue
    if consume_byte(parser, 93):
      return Ok<JsonValue> { value: JsonArray { value: items } }
    return Err<JsonError> { error: json_error("json parse error: expected ',' or ']' in array") }

  Err<JsonError> { error: json_error("json parse error: expected ',' or ']' in array") }

fn parse_object(~parser: JsonParser): () -> Result<JsonValue, JsonError>
  parser.index = parser.index + 1
  skip_whitespace(parser)

  let ~fields = Dict<String, JsonValue>::init()
  if consume_byte(parser, 125):
    return Ok<JsonValue> { value: JsonObject { value: fields } }

  while true do:
    match(parse_string(parser))
      Ok<String> { value: key }:
        skip_whitespace(parser)
        if not consume_byte(parser, 58):
          return Err<JsonError> { error: json_error("json parse error: expected ':' after object key") }
        skip_whitespace(parser)
        match(parse_value(parser))
          Ok<JsonValue> { value }:
            fields.set(key, value)
          Err<JsonError> { error }:
            return Err<JsonError> { error: error }
      Err<JsonError> { error }:
        return Err<JsonError> { error: error }

    skip_whitespace(parser)
    if consume_byte(parser, 44):
      skip_whitespace(parser)
      continue
    if consume_byte(parser, 125):
      return Ok<JsonValue> { value: JsonObject { value: fields } }
    return Err<JsonError> { error: json_error("json parse error: expected ',' or '}' in object") }

  Err<JsonError> { error: json_error("json parse error: expected ',' or '}' in object") }

fn parse_number(~parser: JsonParser): () -> Result<JsonValue, JsonError>
  let start = parser.index
  if consume_byte(parser, 45):
    void

  match(peek(parser))
    Some<i32> { value: first_digit }:
      if first_digit == 48:
        parser.index = parser.index + 1
      else:
        if is_digit(first_digit):
          consume_digits(parser)
        else:
          return Err<JsonError> { error: json_error("json parse error: invalid number") }
    None:
      return Err<JsonError> { error: json_error("json parse error: invalid number") }

  if consume_byte(parser, 46):
    match(peek(parser))
      Some<i32> { value: digit }:
        if not is_digit(digit):
          return Err<JsonError> { error: json_error("json parse error: invalid fraction") }
        consume_digits(parser)
      None:
        return Err<JsonError> { error: json_error("json parse error: invalid fraction") }

  let next = peek(parser)
  let has_exponent = match(next)
    Some<i32> { value }:
      value == 101 or value == 69
    None:
      false
  if has_exponent:
    parser.index = parser.index + 1
    let _ = consume_byte(parser, 43) or consume_byte(parser, 45)
    match(peek(parser))
      Some<i32> { value: digit }:
        if not is_digit(digit):
          return Err<JsonError> { error: json_error("json parse error: invalid exponent") }
        consume_digits(parser)
      None:
        return Err<JsonError> { error: json_error("json parse error: invalid exponent") }

  let lexeme = parser.source.slice_bytes(start, parser.index - start)
  match(parse_json_number(lexeme))
    Ok<f64> { value }:
      Ok<JsonValue> { value: JsonNumber { value: value } }
    Err:
      Err<JsonError> { error: json_error("json parse error: invalid number") }

/// Writes one JSON value into `out`.
///
/// Params:
/// - `out`: Destination UTF-8 byte buffer.
/// - `value`: Value to serialize.
/// - `pretty`: Enables indentation/newlines when `true`.
/// - `depth`: Current indentation depth.
fn write_json_value(~out: Array<i32>, value: JsonValue, pretty: bool, depth: i32) -> void
  value.match(active)
    JsonNull:
      append_ascii(out, "null")
    JsonBool:
      if active.value:
        append_ascii(out, "true")
      else:
        append_ascii(out, "false")
    JsonNumber:
      append_string(out, number_cast::to_string(active.value))
    JsonString:
      append_json_string(out, active.value)
    JsonArray:
      append_json_array(out, active.value, pretty, depth)
    JsonObject:
      append_json_object(out, active.value, pretty, depth)

fn append_json_array(
  ~out: Array<i32>,
  items: Array<JsonValue>,
  pretty: bool,
  depth: i32
) -> void
  out.push(91)
  if items.is_empty():
    out.push(93)
    return void

  var index = 0
  while index < items.len() do:
    if pretty:
      out.push(10)
      append_indent(out, depth + 1)

    match(items.get(index))
      Some<JsonValue> { value }:
        write_json_value(out, value, pretty, depth + 1)
      None:
        append_ascii(out, "null")

    index = index + 1
    if index < items.len():
      out.push(44)
      if not pretty:
        void

  if pretty:
    out.push(10)
    append_indent(out, depth)
  out.push(93)

fn append_json_object(
  ~out: Array<i32>,
  value: Dict<String, JsonValue>,
  pretty: bool,
  depth: i32
) -> void
  out.push(123)
  let entries = value.entries()
  if entries.is_empty():
    out.push(125)
    return void

  var index = 0
  while index < entries.len() do:
    if pretty:
      out.push(10)
      append_indent(out, depth + 1)

    match(entries.get(index))
      Some<(String, JsonValue)> { value: entry }:
        append_json_string(out, entry.0)
        out.push(58)
        if pretty:
          out.push(32)
        write_json_value(out, entry.1, pretty, depth + 1)
      None:
        append_ascii(out, "\"\"")

    index = index + 1
    if index < entries.len():
      out.push(44)

  if pretty:
    out.push(10)
    append_indent(out, depth)
  out.push(125)

fn append_json_string(~out: Array<i32>, value: String) -> void
  out.push(34)
  var index = 0
  while index < value.as_slice().byte_len() do:
    let byte = byte_at_or(value, index, -1)
    if not append_json_escape(out, byte):
      out.push(byte)
    index = index + 1
  out.push(34)

fn append_json_escape(~out: Array<i32>, byte: i32) -> bool
  if byte == 34:
    out.push(92)
    out.push(34)
    return true
  if byte == 92:
    out.push(92)
    out.push(92)
    return true
  if byte == 8:
    out.push(92)
    out.push(98)
    return true
  if byte == 12:
    out.push(92)
    out.push(102)
    return true
  if byte == 10:
    out.push(92)
    out.push(110)
    return true
  if byte == 13:
    out.push(92)
    out.push(114)
    return true
  if byte == 9:
    out.push(92)
    out.push(116)
    return true
  if byte >= 0 and byte < 32:
    out.push(92)
    out.push(117)
    out.push(48)
    out.push(48)
    out.push(hex_digit(byte / 16))
    out.push(hex_digit(byte - (byte / 16) * 16))
    return true
  false

fn append_indent(~out: Array<i32>, depth: i32) -> void
  var index = 0
  while index < depth do:
    out.push(32)
    out.push(32)
    index = index + 1

fn append_ascii(~out: Array<i32>, value: String) -> void
  append_string(out, value)

fn append_string(~out: Array<i32>, value: String) -> void
  let source = value.raw_bytes()
  var index = 0
  while index < value.as_slice().byte_len() do:
    out.push(__array_get(source, index))
    index = index + 1

fn consume_digits(~parser: JsonParser) -> void
  while true do:
    match(peek(parser))
      Some<i32> { value }:
        if is_digit(value):
          parser.index = parser.index + 1
        else:
          break
      None:
        break

fn consume_literal(~parser: JsonParser, literal: String) -> bool
  let start = parser.index
  let source = literal.to_utf8()
  var index = 0
  while index < source.len() do:
    match(next_byte(parser))
      Some<i32> { value }:
        if value != source.at(index):
          parser.index = start
          return false
      None:
        parser.index = start
        return false
    index = index + 1
  true

fn skip_whitespace(~parser: JsonParser) -> void
  while true do:
    match(peek(parser))
      Some<i32> { value }:
        if is_whitespace(value):
          parser.index = parser.index + 1
        else:
          break
      None:
        break

fn peek(parser: JsonParser): () -> Option<i32>
  parser.source.get_byte(parser.index)

fn next_byte(~parser: JsonParser): () -> Option<i32>
  match(parser.source.get_byte(parser.index))
    Some<i32> { value }:
      parser.index = parser.index + 1
      Some<i32> { value: value }
    None:
      None {}

fn next_byte_or(~parser: JsonParser, fallback: i32) -> i32
  match(next_byte(parser))
    Some<i32> { value }:
      value
    None:
      fallback

fn consume_byte(~parser: JsonParser, expected: i32) -> bool
  match(peek(parser))
    Some<i32> { value }:
      if value != expected:
        return false
      parser.index = parser.index + 1
      true
    None:
      false

fn append_escaped(~out: Array<i32>, escaped: i32, ~parser: JsonParser) -> i32
  if escaped == 34:
    out.push(34)
    return 0
  if escaped == 92:
    out.push(92)
    return 0
  if escaped == 47:
    out.push(47)
    return 0
  if escaped == 98:
    out.push(8)
    return 0
  if escaped == 102:
    out.push(12)
    return 0
  if escaped == 110:
    out.push(10)
    return 0
  if escaped == 114:
    out.push(13)
    return 0
  if escaped == 116:
    out.push(9)
    return 0
  if escaped != 117:
    return -1

  let lead = read_unicode_escape(parser)
  if lead < 0:
    return -1
  if is_high_surrogate(lead):
    let checkpoint = parser.index
    if consume_byte(parser, 92):
      if consume_byte(parser, 117):
        let trail = read_unicode_escape(parser)
        if is_low_surrogate(trail):
          append_codepoint(out, decode_surrogate_pair(lead, trail))
          return 0
      parser.index = checkpoint
    append_replacement(out)
    return 0
  if is_low_surrogate(lead):
    append_replacement(out)
    return 0

  append_codepoint(out, lead)
  0

fn read_unicode_escape(~parser: JsonParser) -> i32
  var codepoint = 0
  var index = 0
  while index < 4 do:
    match(next_byte(parser))
      Some<i32> { value }:
        let digit = hex_to_i32(value)
        if digit < 0:
          return -1
        codepoint = codepoint * 16 + digit
      None:
        return -1
    index = index + 1
  codepoint

fn append_codepoint(~out: Array<i32>, codepoint: i32) -> void
  if codepoint < 0:
    append_replacement(out)
    return void
  if codepoint <= 127:
    out.push(codepoint)
    return void
  if codepoint <= 2047:
    out.push(192 + (codepoint / 64))
    out.push(128 + (codepoint - (codepoint / 64) * 64))
    return void
  if codepoint <= 65535:
    if codepoint >= 55296 and codepoint <= 57343:
      append_replacement(out)
      return void
    out.push(224 + (codepoint / 4096))
    out.push(128 + ((codepoint / 64) - (codepoint / 4096) * 64))
    out.push(128 + (codepoint - (codepoint / 64) * 64))
    return void
  if codepoint <= 1114111:
    out.push(240 + (codepoint / 262144))
    out.push(128 + ((codepoint / 4096) - (codepoint / 262144) * 64))
    out.push(128 + ((codepoint / 64) - (codepoint / 4096) * 64))
    out.push(128 + (codepoint - (codepoint / 64) * 64))
    return void
  append_replacement(out)

fn append_replacement(~out: Array<i32>) -> void
  out.push(239)
  out.push(191)
  out.push(189)

fn string_from_utf8(bytes: Array<i32>): () -> Result<String, JsonError>
  Ok<String> { value: new_string(bytes.to_fixed_array()) }

fn byte_at_or(value: String, index: i32, fallback: i32) -> i32
  match(value.get_byte(index))
    Some<i32> { value: read }:
      read
    None:
      fallback

fn is_whitespace(value: i32) -> bool
  value == 9 or value == 10 or value == 13 or value == 32

fn is_digit(value: i32) -> bool
  value >= 48 and value <= 57

fn hex_to_i32(value: i32) -> i32
  if value >= 48 and value <= 57:
    return value - 48
  if value >= 65 and value <= 70:
    return value - 55
  if value >= 97 and value <= 102:
    return value - 87
  -1

fn hex_digit(value: i32) -> i32
  if value < 10:
    return 48 + value
  97 + (value - 10)

fn is_high_surrogate(value: i32) -> bool
  value >= 55296 and value <= 56319

fn is_low_surrogate(value: i32) -> bool
  value >= 56320 and value <= 57343

fn decode_surrogate_pair(lead: i32, trail: i32) -> i32
  65536 + (lead - 55296) * 1024 + (trail - 56320)

fn is_non_finite_float(value: f64) -> bool
  if value != value:
    return true
  let delta = value - value
  delta != delta

fn digit_to_f64(value: i32) -> f64
  if value == 0:
    return 0.0
  if value == 1:
    return 1.0
  if value == 2:
    return 2.0
  if value == 3:
    return 3.0
  if value == 4:
    return 4.0
  if value == 5:
    return 5.0
  if value == 6:
    return 6.0
  if value == 7:
    return 7.0
  if value == 8:
    return 8.0
  if value == 9:
    return 9.0
  0.0

fn parse_json_number(source: String): () -> Result<f64, JsonError>
  let len = source.as_slice().byte_len()
  if len <= 0:
    return Err<JsonError> { error: json_error("json parse error: invalid number") }

  var index = 0
  var sign = 1.0
  let first = byte_at_or(source, 0, -1)
  if first == 45:
    sign = -1.0
    index = 1

  if index >= len:
    return Err<JsonError> { error: json_error("json parse error: invalid number") }

  var significand = 0.0
  var collected_digits = 0
  var significant_digits = 0
  var saw_nonzero_digit = false

  var saw_int_digit = false
  if byte_at_or(source, index, -1) == 48:
    saw_int_digit = true
    index = index + 1
  else:
    while index < len do:
      let digit = parse_decimal_digit(byte_at_or(source, index, -1))
      if digit < 0:
        break
      saw_int_digit = true
      if digit != 0 or saw_nonzero_digit:
        saw_nonzero_digit = true
        significant_digits = significant_digits + 1
        if collected_digits < 17:
          significand = significand * 10.0 + digit_to_f64(digit)
          collected_digits = collected_digits + 1
      index = index + 1
  if not saw_int_digit:
    return Err<JsonError> { error: json_error("json parse error: invalid number") }

  var frac_digits = 0
  if index < len and byte_at_or(source, index, -1) == 46:
    index = index + 1
    if index >= len:
      return Err<JsonError> { error: json_error("json parse error: invalid number") }

    var saw_fraction_digit = false
    while index < len do:
      let digit = parse_decimal_digit(byte_at_or(source, index, -1))
      if digit < 0:
        break
      frac_digits = frac_digits + 1
      if digit != 0 or saw_nonzero_digit:
        saw_nonzero_digit = true
        significant_digits = significant_digits + 1
        if collected_digits < 17:
          significand = significand * 10.0 + digit_to_f64(digit)
          collected_digits = collected_digits + 1
      saw_fraction_digit = true
      index = index + 1
    if not saw_fraction_digit:
      return Err<JsonError> { error: json_error("json parse error: invalid number") }

  var exponent = 0
  var exponent_sign = 1
  if index < len:
    let marker = byte_at_or(source, index, -1)
    if marker == 101 or marker == 69:
      index = index + 1
      if index >= len:
        return Err<JsonError> { error: json_error("json parse error: invalid number") }

      let sign_byte = byte_at_or(source, index, -1)
      if
        sign_byte == 45:
          exponent_sign = -1
          index = index + 1
        sign_byte == 43:
          index = index + 1

      if index >= len:
        return Err<JsonError> { error: json_error("json parse error: invalid number") }

      var saw_exp_digit = false
      while index < len do:
        let digit = parse_decimal_digit(byte_at_or(source, index, -1))
        if digit < 0:
          break
        if exponent < 1000000:
          exponent = exponent * 10 + digit
        saw_exp_digit = true
        index = index + 1
      if not saw_exp_digit:
        return Err<JsonError> { error: json_error("json parse error: invalid number") }

  if index != len:
    return Err<JsonError> { error: json_error("json parse error: invalid number") }

  if not saw_nonzero_digit:
    return Ok<f64> { value: sign * 0.0 }

  let omitted_digits = significant_digits - collected_digits
  let signed_exponent = exponent_sign * exponent - frac_digits + omitted_digits

  let value = sign * significand * pow10_i32(signed_exponent)
  if is_non_finite_float(value):
    return Err<JsonError> { error: json_error("json parse error: invalid number") }

  Ok<f64> { value: value }

fn parse_decimal_digit(byte: i32) -> i32
  if byte >= 48 and byte <= 57:
    return byte - 48
  -1

fn pow10_i32(value: i32) -> f64
  if value == 0:
    return 1.0
  if value < 0:
    return pow10_negative_i32(0 - value)
  pow10_positive_i32(value)

fn pow10_positive_i32(value: i32) -> f64
  var out = 1.0
  var base = 10.0
  var remaining = value
  while remaining > 0 do:
    let half = remaining / 2
    let odd = remaining - half * 2
    if odd == 1:
      out = out * base
    base = base * base
    remaining = half
  out

fn pow10_negative_i32(value: i32) -> f64
  var out = 1.0
  var base = 0.1
  var remaining = value
  while remaining > 0 do:
    let half = remaining / 2
    let odd = remaining - half * 2
    if odd == 1:
      out = out * base
    base = base * base
    remaining = half
  out

fn json_error(message: String) -> JsonError
  JsonError { message: message }
