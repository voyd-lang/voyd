//! HTTP request/response helpers backed by the host networking runtime.
//!
//! `std::fetch` provides typed request and response DTOs plus convenience helpers
//! for common HTTP workflows. Requests are encoded as MessagePack maps for the host
//! `Fetch` effect and decoded back into `Result<FetchResponse, HostError>`.

use std::array::Array
use std::error::HostError
use std::host_dto::HostDto
use std::msgpack::MsgPack
use std::msgpack::self as msgpack
use std::optional::all
use std::result::types::all
use std::string::type::{ String, StringSlice, new_string }

pub obj FetchHeader {
  /// Case-insensitive header field name.
  api name: String,
  /// Header value.
  api value: String
}

pub type FetchHeaders = Array<FetchHeader>

pub obj FetchRequest {
  /// HTTP method (for example `GET` or `POST`).
  api method: String,
  /// Absolute request URL.
  api url: String,
  /// Request headers.
  api headers: FetchHeaders,
  /// Optional request body.
  api body?: String,
  /// Optional timeout budget in milliseconds.
  api timeout_millis?: i32
}

impl FetchRequest
  /// Builds a request from explicit values.
  api fn init({
    method: String,
    url: String,
    headers?: FetchHeaders,
    body?: String,
    timeout_millis?: i32
  }) -> FetchRequest
    FetchRequest {
      method: method,
      url: url,
      headers: headers ?? Array<FetchHeader>::init(),
      body: body,
      timeout_millis
    }

  /// Builds a request from explicit values.
  api fn init({
    method: StringSlice,
    url: StringSlice,
    headers?: FetchHeaders,
    body?: StringSlice,
    timeout_millis?: i32
  }) -> FetchRequest
    FetchRequest::init(
      method: method.to_string(),
      url: url.to_string(),
      headers: headers,
      body: body?.to_string(),
      timeout_millis: timeout_millis
    )

  /// Builds a `GET` request.
  api fn get(url: String) -> FetchRequest
    FetchRequest::init(method: http_get_method(), url: url)

  /// Builds a `GET` request.
  api fn get(url: StringSlice) -> FetchRequest
    FetchRequest::get(url.to_string())

  /// Builds a `POST` request with a text body.
  api fn post({ url: String, body: String }) -> FetchRequest
    FetchRequest::init(method: http_post_method(), url: url).with_body(body)

  /// Builds a `POST` request with a text body.
  api fn post({ url: StringSlice, body: StringSlice }) -> FetchRequest
    FetchRequest::post(url: url.to_string(), body: body.to_string())

  /// Returns a copy with one header appended.
  api fn with_header(self, { name: String, value: String }) -> FetchRequest
    let ~next_headers = self.headers.copied(1)
    next_headers.push(header(name: name, value: value))
    FetchRequest {
      method: self.method,
      url: self.url,
      headers: next_headers,
      body: self.body,
      timeout_millis: self.timeout_millis
    }

  /// Returns a copy with one header appended.
  api fn with_header(self, { name: StringSlice, value: StringSlice }) -> FetchRequest
    self.with_header(name: name.to_string(), value: value.to_string())

  /// Returns a copy with a text body.
  api fn with_body(self, body: String) -> FetchRequest
    FetchRequest {
      method: self.method,
      url: self.url,
      headers: self.headers,
      body: Some<String> { value: body },
      timeout_millis: self.timeout_millis
    }

  /// Returns a copy with a text body.
  api fn with_body(self, body: StringSlice) -> FetchRequest
    self.with_body(body.to_string())

  /// Returns a copy with a timeout budget in milliseconds.
  api fn with_timeout(self, millis: i32) -> FetchRequest
    FetchRequest {
      method: self.method,
      url: self.url,
      headers: self.headers,
      body: self.body,
      timeout_millis: Some<i32> { value: millis }
    }

  /// Sends this request.
  api fn send(self): Fetch -> Result<FetchResponse, HostError>
    request(request: self)

pub obj FetchResponse {
  /// HTTP response status code.
  api status: i32,
  /// HTTP response status text.
  api status_text: String,
  /// Response headers.
  api headers: FetchHeaders,
  /// UTF-8 decoded response body text.
  api body: String
}

impl FetchResponse
  /// Returns true for 2xx status codes.
  api fn is_success(self) -> bool
    self.status >= 200 and self.status < 300

  /// Returns the first header value matching `name`.
  api fn header(self, name: String) -> Option<String>
    let target = name.lowered()
    var index = 0
    while index < self.headers.len() do:
      match(self.headers.get(index))
        Some<FetchHeader> { value }:
          if value.name.lowered().equals(target):
            return Some<String> { value: value.value }
        None:
          void
      index = index + 1
    None {}

  /// Returns the first header value matching `name`.
  api fn header(self, name: StringSlice) -> Option<String>
    self.header(name.to_string())

/// Host networking effect used by `std::fetch`.
///
/// The payload is a MessagePack map with request metadata and optional body/timeout.
@effect(id: "voyd.std.fetch")
pub eff Fetch
  /// Sends an HTTP request.
  ///
  /// `payload` must encode:
  /// - `method`: HTTP method string (`GET`, `POST`, and so on)
  /// - `url`: absolute URL
  /// - `headers`: array of `{ name, value }`
  /// - `body`: optional UTF-8 string or `null`
  /// - `timeout_millis`: optional i32 or `null`
  ///
  /// Returns a MessagePack object shaped as:
  /// - success: `{ ok: true, value: <response dto> }`
  /// - failure: `{ ok: false, code: i32, message: string }`
  request(tail, payload: MsgPack) -> MsgPack

/// Creates one header value.
pub fn header({ name: String, value: String }): () -> FetchHeader
  FetchHeader { name: name, value: value }

/// Creates one header value.
pub fn header({ name: StringSlice, value: StringSlice }): () -> FetchHeader
  header(name: name.to_string(), value: value.to_string())

/// Sends an HTTP request.
///
/// This is the lowest-level public API in this module and accepts a fully-built
/// `FetchRequest` value.
pub fn request({ request: FetchRequest }): Fetch -> Result<FetchResponse, HostError>
  decode_request_result(Fetch::request(encode_request_payload(request)))

/// Sends an HTTP request from explicit values.
///
/// Example:
/// `let response = fetch::request_with(method: "PUT".as_slice(), url: url)`
pub fn request({
  method: String,
  url: String,
  headers?: FetchHeaders,
  body?: String,
  timeout_millis?: i32
}): Fetch -> Result<FetchResponse, HostError>
  request(request: FetchRequest::init(
    method: method,
    url: url,
    headers: headers,
    body: body,
    timeout_millis: timeout_millis
  ))

/// Sends an HTTP request from explicit values.
///
/// Example:
/// `let response = fetch::request_with(method: "PUT".as_slice(), url: url)`
pub fn request({
  method: StringSlice,
  url: StringSlice,
  headers?: FetchHeaders,
  body?: StringSlice,
  timeout_millis?: i32
}): Fetch -> Result<FetchResponse, HostError>
  request(
    method: method.to_string(),
    url: url.to_string(),
    headers: headers,
    body: body?.to_string(),
    timeout_millis: timeout_millis
  )

/// Sends an HTTP request from explicit values.
pub fn request_with({
  method: String,
  url: String,
  headers?: FetchHeaders,
  body?: String,
  timeout_millis?: i32
}): Fetch -> Result<FetchResponse, HostError>
  request(
    method: method,
    url: url,
    headers: headers,
    body: body,
    timeout_millis: timeout_millis
  )

/// Sends an HTTP request from explicit values.
pub fn request_with({
  method: StringSlice,
  url: StringSlice,
  headers?: FetchHeaders,
  body?: StringSlice,
  timeout_millis?: i32
}): Fetch -> Result<FetchResponse, HostError>
  request(
    method: method,
    url: url,
    headers: headers,
    body: body,
    timeout_millis: timeout_millis
  )

/// Sends a `GET` request.
///
/// Example:
/// `let response = fetch::request_get("https://voyd.dev".as_slice())`
pub fn get(url: String): Fetch -> Result<FetchResponse, HostError>
  request(request: FetchRequest::get(url))

/// Sends a `GET` request.
pub fn get(url: StringSlice): Fetch -> Result<FetchResponse, HostError>
  get(url.to_string())

/// Sends a `GET` request.
///
/// Example:
/// `let response = fetch::request_get("https://voyd.dev".as_slice())`
pub fn request_get(url: String): Fetch -> Result<FetchResponse, HostError>
  get(url)

/// Sends a `GET` request.
pub fn request_get(url: StringSlice): Fetch -> Result<FetchResponse, HostError>
  get(url)

/// Sends a `POST` request with a text body.
pub fn post({ url: String, body: String }): Fetch -> Result<FetchResponse, HostError>
  request(request: FetchRequest::post(url: url, body: body))

/// Sends a `POST` request with a text body.
pub fn post({ url: StringSlice, body: StringSlice }): Fetch -> Result<FetchResponse, HostError>
  post(url: url.to_string(), body: body.to_string())

/// Sends a `POST` request with a text body.
///
/// Example:
/// `let response = fetch::request_post(url: api.as_slice(), body: payload.as_slice())`
pub fn request_post({ url: String, body: String }): Fetch -> Result<FetchResponse, HostError>
  post(url: url, body: body)

/// Sends a `POST` request with a text body.
pub fn request_post({ url: StringSlice, body: StringSlice }): Fetch -> Result<FetchResponse, HostError>
  post(url: url, body: body)

fn encode_request_payload(request: FetchRequest): () -> MsgPack
  HostDto::init()
    .set("method", msgpack::make_string(request.method))
    .set("url", msgpack::make_string(request.url))
    .set("headers", encode_headers(request.headers))
    .set("body", encode_optional_string(request.body))
    .set("timeout_millis", encode_optional_i32(request.timeout_millis))
    .pack()

fn encode_headers(headers: FetchHeaders): () -> MsgPack
  let ~encoded = Array<MsgPack>::with_capacity(headers.len())
  var index = 0
  while index < headers.len() do:
    match(headers.get(index))
      Some<FetchHeader> { value }:
        encoded.push(encode_header(value))
      None:
        void
    index = index + 1
  msgpack::make_array(encoded)

fn encode_header(value: FetchHeader): () -> MsgPack
  HostDto::init()
    .set("name", msgpack::make_string(value.name))
    .set("value", msgpack::make_string(value.value))
    .pack()

fn encode_optional_string(value: Option<String>): () -> MsgPack
  match(value)
    Some<String> { value }:
      msgpack::make_string(value)
    None:
      msgpack::make_null()

fn encode_optional_i32(value: Option<i32>): () -> MsgPack
  match(value)
    Some<i32> { value }:
      msgpack::make_i32(value)
    None:
      msgpack::make_null()

fn decode_request_result(payload: MsgPack): () -> Result<FetchResponse, HostError>
  let decoded = HostDto::unpack(payload)
  if decoded.read_bool("ok") == false:
    return Err<HostError> { error: decode_host_error(decoded) }

  Ok<FetchResponse> { value: decode_fetch_response(decoded.read_msgpack("value")) }

fn decode_fetch_response(payload: MsgPack): () -> FetchResponse
  let decoded = HostDto::unpack(payload)
  FetchResponse {
    status: decoded.read_i32("status"),
    status_text: decoded.read_string("status_text"),
    headers: decode_headers(decoded.read_msgpack("headers")),
    body: decoded.read_string("body")
  }

fn decode_headers(payload: MsgPack): () -> FetchHeaders
  let source = msgpack::unpack_array(payload)
  let ~headers = Array<FetchHeader>::with_capacity(source.len())
  var index = 0
  while index < source.len() do:
    match(source.get(index))
      Some<MsgPack> { value }:
        headers.push(decode_header(value))
      None:
        void
    index = index + 1
  headers

fn decode_header(payload: MsgPack): () -> FetchHeader
  let decoded = HostDto::unpack(payload)
  FetchHeader {
    name: decoded.read_string("name"),
    value: decoded.read_string("value")
  }

fn decode_host_error(payload: HostDto): () -> HostError
  HostError {
    code: payload.read_i32("code"),
    message: payload.read_string("message")
  }

fn http_get_method() -> String
  "GET".as_slice().to_string()

fn http_post_method() -> String
  "POST".as_slice().to_string()
