use std::test::assertions::all

obj OptionalMacroPoint {
  x: i32
}

obj OptionalMacroCounter {
  value: i32
}

impl OptionalMacroCounter
  fn add(self, delta: i32): () -> i32
    self.value + delta

obj OptionalMacroContainer {
  counter: OptionalMacroCounter
}

fn optional_i32(value: i32): () -> Optional<i32>
  Some { value: value }

fn i32_zero(): () -> i32
  0

fn i32_two(): () -> i32
  2

fn i32_five(): () -> i32
  5

fn i32_four(): () -> i32
  4

fn i32_nine(): () -> i32
  9

fn i32_eleven(): () -> i32
  11

test "hi returns 3":
  let result = hi()
  assert(result, eq: 3)

test "unwrap_or returns inner value":
  let value = unwrap_or<i32>(some<i32>(3), 0)
  assert(value, eq: 3)

test "unwrap_or returns default for none":
  let value = unwrap_or<i32>(none<i32>(), 9)
  assert(value, eq: 9)

test "unwrap_or_else uses fallback":
  let value = unwrap_or_else<i32>(none<i32>(), () -> i32 => 11)
  assert(value, eq: 11)

test "map preserves some":
  let result = map<i32, i32>(some<i32>(2), (v: i32) -> i32 => v + 1)
  match(result)
    Some { value }:
      assert(value, eq: 3)
    None:
      assert(false)

test "map preserves none":
  let result = map<i32, i32>(none<i32>(), (v: i32) -> i32 => v + 1)
  assert(is_none<i32>(result))

test "and_then returns mapped optional":
  let result = and_then<i32, i32>(
    some<i32>(2),
    (v: i32) -> Optional<i32> => some<i32>(v + 2)
  )
  match(result)
    Some { value }:
      assert(value, eq: 4)
    None:
      assert(false)

test "or_value uses fallback":
  let result = or_value<i32>(none<i32>(), some<i32>(8))
  match(result)
    Some { value }:
      assert(value, eq: 8)
    None:
      assert(false)

test "or_else uses fallback":
  let result = or_else<i32>(none<i32>(), () -> Optional<i32> => some<i32>(7))
  match(result)
    Some { value }:
      assert(value, eq: 7)
    None:
      assert(false)

test "?? unwraps some":
  let result = optional_i32(i32_five()) ?? i32_zero()
  assert(result, eq: 5)

test "?? uses fallback for none":
  let result = none<i32>() ?? i32_nine()
  assert(result, eq: 9)

test "?? infers fallback from optional value":
  let result = optional_i32(i32_five()) ?? 0
  assert(result, eq: 5)

test "?. accesses field":
  let point = OptionalMacroPoint { x: i32_four() }
  let result = some(point)?.x
  match(result)
    Some { value }:
      assert(value, eq: 4)
    None:
      assert(false)

test "?. returns none":
  let result = none<OptionalMacroPoint>()?.x
  assert(is_none<i32>(result))

test "?. chains methods":
  let container = OptionalMacroContainer {
    counter: OptionalMacroCounter { value: 3 }
  }
  let result = some(container)?.counter?.add(i32_two()) ?? i32_zero()
  assert(result, eq: 5)

test "?. with ?? fallback":
  let result = none<OptionalMacroContainer>()?.counter?.add(i32_two()) ?? i32_eleven()
  assert(result, eq: 11)
