use std::optional::types::all
use std::test::assertions::all

pub fn some<T>(value: T): () -> Optional<T>
  Some { value: value }

pub fn none<T>(): () -> Optional<T>
  None {}

pub fn is_some<T>(opt: Optional<T>): () -> boolean
  match(opt)
    Some:
      true
    None:
      false

pub fn is_none<T>(opt: Optional<T>): () -> boolean
  match(opt)
    Some:
      false
    None:
      true

pub fn unwrap_or<T>(opt: Optional<T>, default: T): () -> T
  match(opt)
    Some { value }:
      value
    None:
      default

pub fn unwrap_or_else<T>(opt: Optional<T>, default: () -> T): () -> T
  match(opt)
    Some { value }:
      value
    None:
      default()

pub fn map<T, U>(opt: Optional<T>, f: (v: T) -> U): () -> Optional<U>
  match(opt)
    Some { value }:
      Some { value: f(value) }
    None:
      None {}

pub fn and_then<T, U>(opt: Optional<T>, f: (v: T) -> Optional<U>): () -> Optional<U>
  match(opt)
    Some { value }:
      f(value)
    None:
      None {}

pub fn or_value<T>(opt: Optional<T>, fallback: Optional<T>): () -> Optional<T>
  match(opt)
    Some:
      opt
    None:
      fallback

pub fn or_else<T>(opt: Optional<T>, fallback: () -> Optional<T>): () -> Optional<T>
  match(opt)
    Some:
      opt
    None:
      fallback()

test "unwrap_or returns inner value":
  let value = unwrap_or<i32>(some<i32>(3), 0)
  assert(value, eq: 3)

test "unwrap_or returns default for none":
  let value = unwrap_or<i32>(none<i32>(), 9)
  assert(value, eq: 9)

test "unwrap_or_else uses fallback":
  let value = unwrap_or_else<i32>(none<i32>(), () -> i32 => 11)
  assert(value, eq: 11)

test "map preserves some":
  let result = map<i32, i32>(some<i32>(2), (v: i32) -> i32 => v + 1)
  match(result)
    Some { value }:
      assert(value, eq: 3)
    None:
      assert(false)

test "map preserves none":
  let result = map<i32, i32>(none<i32>(), (v: i32) -> i32 => v + 1)
  assert(is_none<i32>(result))

test "and_then returns mapped optional":
  let result = and_then<i32, i32>(
    some<i32>(2),
    (v: i32) -> Optional<i32> => some<i32>(v + 2)
  )
  match(result)
    Some { value }:
      assert(value, eq: 4)
    None:
      assert(false)

test "or_value uses fallback":
  let result = or_value<i32>(none<i32>(), some<i32>(8))
  match(result)
    Some { value }:
      assert(value, eq: 8)
    None:
      assert(false)

test "or_else uses fallback":
  let result = or_else<i32>(none<i32>(), () -> Optional<i32> => some<i32>(7))
  match(result)
    Some { value }:
      assert(value, eq: 7)
    None:
      assert(false)
