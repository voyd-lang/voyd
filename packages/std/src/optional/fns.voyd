use super::types::all

/// Constructs an optional value containing `value`.
pub fn some<T>(value: T): () -> Optional<T>
  Some { value: value }

/// Constructs an empty optional value.
pub fn none<T>(): () -> Optional<T>
  None {}

/// Returns true when the optional value is present.
pub fn is_some<T>(opt: Optional<T>): () -> boolean
  match(opt)
    Some:
      true
    None:
      false

/// Returns true when the optional value is absent.
pub fn is_none<T>(opt: Optional<T>): () -> boolean
  match(opt)
    Some:
      false
    None:
      true

/// Returns the contained value or the provided fallback.
pub fn unwrap_or<T>(opt: Optional<T>, default: T): () -> T
  match(opt)
    Some { value }:
      value
    None:
      default

/// Returns the contained value or computes a fallback.
pub fn unwrap_or_else<T>(opt: Optional<T>, default: () -> T) -> T
  match(opt)
    Some { value }:
      value
    None:
      default()

/// Transforms the contained value when present and leaves `None` unchanged.
pub fn map<T, U>(opt: Optional<T>, f: (v: T) -> U) -> Optional<U>
  match(opt)
    Some { value }:
      Some { value: f(value) }
    None:
      None {}

/// Runs `f` only when a value is present, propagating `None` otherwise.
pub fn and_then<T, U>(opt: Optional<T>, f: (v: T) -> Optional<U>) -> Optional<U>
  match(opt)
    Some { value }:
      f(value)
    None:
      None {}

/// Returns the current optional value or the provided fallback optional value.
pub fn or_value<T>(opt: Optional<T>, fallback: Optional<T>): () -> Optional<T>
  match(opt)
    Some:
      opt
    None:
      fallback

/// Returns the current optional value or computes a fallback optional value.
pub fn or_else<T>(opt: Optional<T>, fallback: () -> Optional<T>) -> Optional<T>
  match(opt)
    Some:
      opt
    None:
      fallback()

pub macro '??'(l, r)
  let l_result = identifier(__optional_coalesce_left)
  `
    let $l_result = $l
    if $l_result is Some:
      $l_result.value
    else:
      $r

pub macro '?.'(l, r)
  let l_result = identifier(__optional_chain_left)
  let value = identifier(__optional_chain_value)
  `
    let $l_result = $l
    match($l_result)
      Some { value: $value }:
        Some { value: ($value).$r }
      None:
        None {}
