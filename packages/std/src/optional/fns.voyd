use super::types::all

fn hi()
  3

pub fn some<T>(value: T): () -> Optional<T>
  Some { value: value }

pub fn none<T>(): () -> Optional<T>
  None {}

pub fn is_some<T>(opt: Optional<T>): () -> boolean
  match(opt)
    Some:
      true
    None:
      false

pub fn is_none<T>(opt: Optional<T>): () -> boolean
  match(opt)
    Some:
      false
    None:
      true

pub fn unwrap_or<T>(opt: Optional<T>, default: T): () -> T
  match(opt)
    Some { value }:
      value
    None:
      default

pub fn unwrap_or_else<T>(opt: Optional<T>, default: () -> T): () -> T
  match(opt)
    Some { value }:
      value
    None:
      default()

pub fn map<T, U>(opt: Optional<T>, f: (v: T) -> U): () -> Optional<U>
  match(opt)
    Some { value }:
      Some { value: f(value) }
    None:
      None {}

pub fn and_then<T, U>(opt: Optional<T>, f: (v: T) -> Optional<U>): () -> Optional<U>
  match(opt)
    Some { value }:
      f(value)
    None:
      None {}

pub fn or_value<T>(opt: Optional<T>, fallback: Optional<T>): () -> Optional<T>
  match(opt)
    Some:
      opt
    None:
      fallback

pub fn or_else<T>(opt: Optional<T>, fallback: () -> Optional<T>): () -> Optional<T>
  match(opt)
    Some:
      opt
    None:
      fallback()

pub macro '??'(l, r)
  let l_result = identifier(__optional_coalesce_left)
  `
    let $l_result = $l
    if $l_result is Some:
      $l_result.value
    else:
      $r

pub macro '?.'(l, r)
  let l_result = identifier(__optional_chain_left)
  let value = identifier(__optional_chain_value)
  `
    let $l_result = $l
    match($l_result)
      Some { value: $value }:
        Some { value: ($value).$r }
      None:
        None {}
