use std::array::Array
use std::fixed_array::fns::{ new_fixed_array }
use std::dict::{ Dict, DictKey }
use std::memory::self as memory
use std::msgpack::types::{ Binary, Bool, F32, F64, I32, I64, Null, Numeric }
use std::optional::types::all
use std::string::type::{ new_string, String }

@serializer("msgpack", encode_value, decode_value)
pub type MsgPack = Null | Numeric | Bool | String | Binary | Array<MsgPack> | MsgPackMap

obj MsgPackMap {
  entries: Array<(String, MsgPack)>
}

obj Encoder {
  ptr: i32,
  pos: i32,
  len: i32,
  ok: bool
}

obj Decoder {
  ptr: i32,
  pos: i32,
  end: i32,
  ok: bool
}

/// Encodes a MessagePack value into a memory region and returns bytes written or `-1` on failure.
pub fn encode_value(value: MsgPack, ptr: i32, len: i32): () -> i32
  let ~encoder = Encoder(ptr, len)
  encoder.encode_any(value)
  if encoder.ok then: encoder.pos else: -1

/// Decodes a MessagePack value from a memory region.
pub fn decode_value(ptr: i32, len: i32): () -> MsgPack
  let ~decoder = Decoder(ptr, len)
  let value = decoder.decode_any()
  if decoder.ok then: value else: make_null()

fn empty_binary(): () -> Binary
  Binary { bytes: Array<i32>::init() }

fn empty_array(): () -> Array<MsgPack>
  Array<MsgPack>::init()

fn empty_map(): () -> Dict<String, MsgPack>
  Dict<String, MsgPack>::init()

fn empty_text(): () -> String
  new_string(new_fixed_array<i32>(0))

/// Returns a MessagePack null value.
pub fn make_null(): () -> MsgPack
  Null {}

/// Wraps a 32-bit integer as a MessagePack value.
pub fn make_i32(value: i32): () -> MsgPack
  I32 { value }

/// Wraps a 64-bit integer as a MessagePack value.
pub fn make_i64(value: i64): () -> MsgPack
  I64 { value }

/// Wraps a 32-bit float as a MessagePack value.
pub fn make_f32(value: f32): () -> MsgPack
  F32 { value }

/// Wraps a boolean as a MessagePack value.
pub fn make_bool(value: bool): () -> MsgPack
  Bool { value }

/// Wraps a string as a MessagePack value.
pub fn make_string(value: String): () -> MsgPack
  value

/// Wraps binary data as a MessagePack value.
pub fn make_binary(value: Binary): () -> MsgPack
  value

/// Wraps an array as a MessagePack value.
pub fn make_array(value: Array<MsgPack>): () -> MsgPack
  value

/// Wraps a string-keyed dictionary as a MessagePack map value.
pub fn make_map(value: Dict<String, MsgPack>): () -> MsgPack
  MsgPackMap { entries: value.entries() }

/// Extracts a 32-bit integer from a MessagePack value.
pub fn unpack_i32(value: MsgPack): () -> i32
  value.match(decoded)
    I32:
      decoded.value
    I64:
      wrap_i64(decoded.value)
    else:
      0

/// Extracts a 64-bit integer from a MessagePack value.
pub fn unpack_i64(value: MsgPack): () -> i64
  value.match(decoded)
    I64:
      decoded.value
    I32:
      extend_i32_s(decoded.value)
    else:
      extend_i32_s(0)

/// Extracts a 32-bit float from a MessagePack value.
pub fn unpack_f32(value: MsgPack): () -> f32
  value.match(decoded)
    F32:
      decoded.value
    F64:
      demote_f64(decoded.value)
    else:
      reinterpret_i32_to_f32(0)

/// Extracts a 64-bit float from a MessagePack value.
pub fn unpack_f64(value: MsgPack): () -> f64
  value.match(decoded)
    F64:
      decoded.value
    F32:
      promote_f32(decoded.value)
    else:
      0.0

/// Extracts a boolean from a MessagePack value.
pub fn unpack_bool(value: MsgPack): () -> bool
  value.match(decoded)
    Bool:
      decoded.value
    else:
      false

/// Extracts a string from a MessagePack value.
pub fn unpack_string(value: MsgPack): () -> String
  value.match(decoded)
    String:
      decoded
    else:
      empty_text()

/// Extracts binary data from a MessagePack value.
pub fn unpack_binary(value: MsgPack): () -> Binary
  value.match(boxed)
    Binary:
      boxed
    else:
      empty_binary()

/// Extracts an array from a MessagePack value.
pub fn unpack_array(value: MsgPack): () -> Array<MsgPack>
  value.match(boxed)
    Array<MsgPack>:
      boxed
    else:
      empty_array()

/// Extracts a string-keyed map from a MessagePack value.
pub fn unpack_map(value: MsgPack): () -> Dict<String, MsgPack>
  value.match(boxed)
    MsgPackMap:
      let ~out = Dict<String, MsgPack>::init()
      let entries = boxed.entries
      var index = 0
      while index < entries.len() do:
        match(entries.get(index))
          Some<(String, MsgPack)> { value: entry }:
            out.set(key: entry.0, value: entry.1)
          None:
            void
        index = index + 1
      out
    else:
      empty_map()

impl Encoder
  /// Initializes a codec cursor over the provided memory region.
  pub fn init(ptr: i32, len: i32)
    Encoder { ptr: ptr, pos: 0, len: len, ok: true }

  fn can_write(~self, count: i32) -> bool
    if self.ok == false then:
      return false
    if count <= 0 then:
      return true
    let next = self.pos + count
    if next > self.len then:
      self.ok = false
      return false
    let memory_end = memory::size() * 65536
    if (self.ptr + next) > memory_end then:
      self.ok = false
      return false
    true

  fn write_u8(~self, value: i32) -> void
    if self.can_write(1) == false then:
      return void
    memory::store_u8(self.ptr + self.pos, value)
    self.pos = self.pos + 1

  fn write_u16(~self, value: i32) -> void
    if self.can_write(2) == false then:
      return void
    self.write_u8(shift_ru(value, 8))
    self.write_u8(bit_and(value, 255))

  fn write_u32(~self, value: i32) -> void
    if self.can_write(4) == false then:
      return void
    self.write_u8(shift_ru(value, 24))
    self.write_u8(bit_and(shift_ru(value, 16), 255))
    self.write_u8(bit_and(shift_ru(value, 8), 255))
    self.write_u8(bit_and(value, 255))

  fn write_u64(~self, value: i64) -> void
    if self.can_write(8) == false then:
      return void
    self.write_u8(bit_and(wrap_i64(shift_ru(value, 56)), 255))
    self.write_u8(bit_and(wrap_i64(shift_ru(value, 48)), 255))
    self.write_u8(bit_and(wrap_i64(shift_ru(value, 40)), 255))
    self.write_u8(bit_and(wrap_i64(shift_ru(value, 32)), 255))
    self.write_u8(bit_and(wrap_i64(shift_ru(value, 24)), 255))
    self.write_u8(bit_and(wrap_i64(shift_ru(value, 16)), 255))
    self.write_u8(bit_and(wrap_i64(shift_ru(value, 8)), 255))
    self.write_u8(bit_and(wrap_i64(value), 255))

  fn encode_numeric(~self, value: Numeric) -> void
    value.match(number)
      I32:
        self.encode_i32(number.value)
      I64:
        self.encode_i64(number.value)
      F32:
        self.encode_f32(number.value)
      F64:
        self.encode_f64(number.value)

  fn encode_i32(~self, value: i32) -> void
    if value >= 0 and value < 128 then:
      self.write_u8(value)
      return void
    if value >= -32 and value < 0 then:
      self.write_u8(value + 256)
      return void
    self.write_u8(210)
    self.write_u32(value)

  fn encode_i64(~self, value: i64) -> void
    self.write_u8(211)
    self.write_u64(value)

  fn encode_f32(~self, value: f32) -> void
    self.write_u8(202)
    self.write_u32(reinterpret_f32_to_i32(value))

  fn encode_f64(~self, value: f64) -> void
    self.write_u8(203)
    self.write_u64(reinterpret_f64_to_i64(value))

  fn encode_string(~self, value: String) -> void
    let len = value.byte_count
    if len < 32 then:
      self.write_u8(160 + len)
    elif: len < 256 then:
      self.write_u8(217)
      self.write_u8(len)
    elif: len < 65536 then:
      self.write_u8(218)
      self.write_u16(len)
    else:
      self.write_u8(219)
      self.write_u32(len)

    let source = value.bytes.raw_storage()
    var index = 0
    while index < len do:
      self.write_u8(__array_get(source, index))
      index = index + 1

  fn encode_binary(~self, bytes: Array<i32>) -> void
    let len = bytes.len()
    if len < 256 then:
      self.write_u8(196)
      self.write_u8(len)
    elif: len < 65536 then:
      self.write_u8(197)
      self.write_u16(len)
    else:
      self.write_u8(198)
      self.write_u32(len)

    let source = bytes.raw_storage()
    var index = 0
    while index < len do:
      self.write_u8(__array_get(source, index))
      index = index + 1

  fn encode_array(~self, value: Array<MsgPack>) -> void
    let len = value.len()
    if len < 16 then:
      self.write_u8(144 + len)
    elif: len < 65536 then:
      self.write_u8(220)
      self.write_u16(len)
    else:
      self.write_u8(221)
      self.write_u32(len)

    let source = value.raw_storage()
    var index = 0
    while index < len do:
      self.encode_any(__array_get(source, index))
      index = index + 1

  fn encode_map(~self, value: Dict<String, MsgPack>) -> void
    self.encode_map_entries(value.entries())

  fn encode_map_entries(~self, entries: Array<(String, MsgPack)>) -> void
    let len = entries.len()
    if len < 16 then:
      self.write_u8(128 + len)
    elif: len < 65536 then:
      self.write_u8(222)
      self.write_u16(len)
    else:
      self.write_u8(223)
      self.write_u32(len)

    let storage = entries.raw_storage()
    let entry_count = entries.len()
    var index = 0
    while index < entry_count do:
      let entry = __array_get(storage, index)
      self.encode_string(entry.0)
      self.encode_any(entry.1)
      index = index + 1

  fn encode_any(~self, value: MsgPack) -> void
    value.match(decoded)
      Null:
        self.write_u8(192)
      Bool:
        let flag = if decoded.value then: 195 else: 194
        self.write_u8(flag)
      I32:
        self.encode_numeric(decoded)
      I64:
        self.encode_numeric(decoded)
      F32:
        self.encode_numeric(decoded)
      F64:
        self.encode_numeric(decoded)
      String:
        self.encode_string(decoded)
      Binary:
        self.encode_binary(decoded.bytes)
      Array<MsgPack>:
        self.encode_array(decoded)
      MsgPackMap:
        self.encode_map_entries(decoded.entries)

impl Decoder
  /// Initializes a codec cursor over the provided memory region.
  pub fn init(ptr: i32, len: i32)
    Decoder { ptr: ptr, pos: 0, end: ptr + len, ok: true }

  fn can_read(~self, count: i32) -> bool
    if self.ok == false then:
      return false
    if count <= 0 then:
      return true
    let next = self.ptr + self.pos + count
    let memory_end = memory::size() * 65536
    if next > self.end then:
      self.ok = false
      return false
    if next > memory_end then:
      self.ok = false
      return false
    true

  fn read_u8(~self) -> i32
    if self.can_read(1) == false then:
      return 0
    let value = memory::load_u8(self.ptr + self.pos)
    self.pos = self.pos + 1
    value

  fn read_u16(~self) -> i32
    if self.can_read(2) == false then:
      return 0
    let high = self.read_u8()
    let low = self.read_u8()
    bit_or(shift_l(high, 8), low)

  fn read_u32(~self) -> i32
    if self.can_read(4) == false then:
      return 0
    let b1 = self.read_u8()
    let b2 = self.read_u8()
    let b3 = self.read_u8()
    let b4 = self.read_u8()
    var value = bit_or(shift_l(b1, 24), shift_l(b2, 16))
    value = bit_or(value, shift_l(b3, 8))
    bit_or(value, b4)

  fn read_u64(~self) -> i64
    if self.can_read(8) == false then:
      return extend_i32_u(0)
    let b1 = extend_i32_u(self.read_u8())
    let b2 = extend_i32_u(self.read_u8())
    let b3 = extend_i32_u(self.read_u8())
    let b4 = extend_i32_u(self.read_u8())
    let b5 = extend_i32_u(self.read_u8())
    let b6 = extend_i32_u(self.read_u8())
    let b7 = extend_i32_u(self.read_u8())
    let b8 = extend_i32_u(self.read_u8())

    var value = bit_or(shift_l(b1, 56), shift_l(b2, 48))
    value = bit_or(value, shift_l(b3, 40))
    value = bit_or(value, shift_l(b4, 32))
    value = bit_or(value, shift_l(b5, 24))
    value = bit_or(value, shift_l(b6, 16))
    value = bit_or(value, shift_l(b7, 8))
    bit_or(value, b8)

  fn decode_string(~self, length: i32) -> String
    if length <= 0 then:
      return empty_text()
    let storage = new_fixed_array<i32>(length)
    var index = 0
    while index < length do:
      __array_set(storage, index, self.read_u8())
      index = index + 1
    new_string(storage)

  fn decode_binary(~self, length: i32) -> Binary
    if length <= 0 then:
      return Binary { bytes: Array<i32>::with_capacity(0) }
    let ~bytes = Array<i32>::with_capacity(length)
    var index = 0
    while index < length do:
      bytes.push(self.read_u8())
      index = index + 1
    Binary { bytes: bytes }

  fn decode_array(~self, length: i32) -> Array<MsgPack>
    let capacity = if length < 0 then: 0 else: length
    let ~out = Array<MsgPack>::with_capacity(capacity)
    var index = 0
    while index < length do:
      out.push(self.decode_any())
      index = index + 1
    out

  fn decode_map(~self, length: i32) -> Dict<String, MsgPack>
    let ~out = Dict<String, MsgPack>::init()
    var index = 0
    while index < length do:
      let key = self.decode_any()
      let value = self.decode_any()
      key.match(decoded_key)
        String:
          out.set(key: decoded_key, value: value)
        else:
          void
      index = index + 1
    out

  fn decode_integer(~self, prefix: i32) -> MsgPack
    if prefix < 128 then:
      return make_i32(prefix)
    if prefix >= 224 then:
      return make_i32(prefix - 256)
    if prefix == 204 then:
      return make_i32(self.read_u8())
    if prefix == 205 then:
      return make_i32(self.read_u16())
    if prefix == 206 then:
      let value = self.read_u32()
      if value < 0 then:
        let extended = extend_i32_u(value)
        return make_i64(extended)
      return make_i32(value)
    if prefix == 207 then:
      return make_i64(self.read_u64())
    if prefix == 208 then:
      return make_i32(self.read_u8() - 256)
    if prefix == 209 then:
      let value = self.read_u16()
      if value >= 32768 then:
        return make_i32(value - 65536)
      return make_i32(value)
    if prefix == 210 then:
      return make_i32(self.read_u32())
    if prefix == 211 then:
      return make_i64(self.read_u64())
    make_i32(0)

  fn decode_any(~self) -> MsgPack
    let prefix = self.read_u8()
    if self.ok == false then:
      return make_null()
    if prefix == 192 then:
      return make_null()
    if prefix == 194 then:
      return make_bool(false)
    if prefix == 195 then:
      return make_bool(true)
    if prefix >= 160 and prefix < 192 then:
      let len = prefix - 160
      return make_string(self.decode_string(len))
    if prefix >= 144 and prefix < 160 then:
      return make_array(self.decode_array(prefix - 144))
    if prefix >= 128 and prefix < 144 then:
      return make_map(self.decode_map(prefix - 128))
    if prefix == 217 then:
      return make_string(self.decode_string(self.read_u8()))
    if prefix == 218 then:
      return make_string(self.decode_string(self.read_u16()))
    if prefix == 219 then:
      return make_string(self.decode_string(self.read_u32()))
    if prefix == 220 then:
      return make_array(self.decode_array(self.read_u16()))
    if prefix == 221 then:
      return make_array(self.decode_array(self.read_u32()))
    if prefix == 222 then:
      return make_map(self.decode_map(self.read_u16()))
    if prefix == 223 then:
      return make_map(self.decode_map(self.read_u32()))
    if prefix == 196 then:
      return make_binary(self.decode_binary(self.read_u8()))
    if prefix == 197 then:
      return make_binary(self.decode_binary(self.read_u16()))
    if prefix == 198 then:
      return make_binary(self.decode_binary(self.read_u32()))
    if prefix == 202 then:
      let raw = self.read_u32()
      return make_f32(reinterpret_i32_to_f32(raw))
    if prefix == 203 then:
      let raw = self.read_u64()
      return F64 { value: reinterpret_i64_to_f64(raw) }
    self.decode_integer(prefix)

@intrinsic(name: "__shift_l")
fn shift_l(value: i32, bits: i32): () -> i32 __shift_l(value, bits)

@intrinsic(name: "__shift_l")
fn shift_l(value: i64, bits: i32): () -> i64 __shift_l(value, bits)

@intrinsic(name: "__shift_ru")
fn shift_ru(value: i32, bits: i32): () -> i32 __shift_ru(value, bits)

@intrinsic(name: "__shift_ru")
fn shift_ru(value: i64, bits: i32): () -> i64 __shift_ru(value, bits)

@intrinsic(name: "__bit_and")
fn bit_and(value: i32, mask: i32): () -> i32 __bit_and(value, mask)

@intrinsic(name: "__bit_or")
fn bit_or(value: i32, other: i32): () -> i32 __bit_or(value, other)

@intrinsic(name: "__bit_or")
fn bit_or(value: i64, other: i64): () -> i64 __bit_or(value, other)

@intrinsic(name: "__i32_wrap_i64")
fn wrap_i64(value: i64): () -> i32 __i32_wrap_i64(value)

@intrinsic(name: "__i64_extend_u")
fn extend_i32_u(value: i32): () -> i64 __i64_extend_u(value)

@intrinsic(name: "__i64_extend_s")
fn extend_i32_s(value: i32): () -> i64 __i64_extend_s(value)

@intrinsic(name: "__reinterpret_f32_to_i32")
fn reinterpret_f32_to_i32(value: f32): () -> i32 __reinterpret_f32_to_i32(value)

@intrinsic(name: "__reinterpret_i32_to_f32")
fn reinterpret_i32_to_f32(value: i32): () -> f32 __reinterpret_i32_to_f32(value)

@intrinsic(name: "__f32_demote_f64")
fn demote_f64(value: f64): () -> f32 __f32_demote_f64(value)

@intrinsic(name: "__f64_promote_f32")
fn promote_f32(value: f32): () -> f64 __f64_promote_f32(value)

@intrinsic(name: "__reinterpret_f64_to_i64")
fn reinterpret_f64_to_i64(value: f64): () -> i64 __reinterpret_f64_to_i64(value)

@intrinsic(name: "__reinterpret_i64_to_f64")
fn reinterpret_i64_to_f64(value: i64): () -> f64 __reinterpret_i64_to_f64(value)
