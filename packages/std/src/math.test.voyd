use std::test::assertions::all

test "max and min choose expected values":
  assert(max(4, 9), eq: 9)
  assert(max(-2, -7), eq: -2)
  assert(min(4, 9), eq: 4)
  assert(min(-2, -7), eq: -7)

test "mod_euclid i32 returns euclidean remainder":
  match(mod_euclid(-1, 4))
    Ok<i32> { value }:
      assert(value, eq: 3)
    Err<MathError>:
      assert(false, eq: true)

  match(mod_euclid(14, 4))
    Ok<i32> { value }:
      assert(value, eq: 2)
    Err<MathError>:
      assert(false, eq: true)

test "mod_euclid i32 rejects non-positive modulus":
  match(mod_euclid(5, 0))
    Ok<i32>:
      assert(false, eq: true)
    Err<MathError> { error }:
      assert(error.code, eq: 1)

  match(mod_euclid(5, -3))
    Ok<i32>:
      assert(false, eq: true)
    Err<MathError> { error }:
      assert(error.code, eq: 1)

test "mod_euclid i64 returns euclidean remainder":
  match(mod_euclid(i64_from_i32(-1), i64_from_i32(4)))
    Ok<i64> { value }:
      assert(value, eq: i64_from_i32(3))
    Err<MathError>:
      assert(false, eq: true)

  match(mod_euclid(i64_from_i32(14), i64_from_i32(4)))
    Ok<i64> { value }:
      assert(value, eq: i64_from_i32(2))
    Err<MathError>:
      assert(false, eq: true)

test "mod_euclid i64 rejects non-positive modulus":
  match(mod_euclid(i64_from_i32(5), i64_from_i32(0)))
    Ok<i64>:
      assert(false, eq: true)
    Err<MathError> { error }:
      assert(error.code, eq: 1)

  match(mod_euclid(i64_from_i32(5), i64_from_i32(-3)))
    Ok<i64>:
      assert(false, eq: true)
    Err<MathError> { error }:
      assert(error.code, eq: 1)

test "div_rem i32 returns quotient and remainder":
  let pair = div_rem(13, 5)
  assert(pair.0, eq: 2)
  assert(pair.1, eq: 3)

test "div_rem i64 returns quotient and remainder":
  let pair = div_rem(i64_from_i32(13), i64_from_i32(5))
  assert(pair.0, eq: i64_from_i32(2))
  assert(pair.1, eq: i64_from_i32(3))

test "next_power_of_two handles base and rounding cases":
  match(next_power_of_two(-10))
    Ok<i32> { value }:
      assert(value, eq: 1)
    Err<MathError>:
      assert(false, eq: true)

  match(next_power_of_two(1))
    Ok<i32> { value }:
      assert(value, eq: 1)
    Err<MathError>:
      assert(false, eq: true)

  match(next_power_of_two(3))
    Ok<i32> { value }:
      assert(value, eq: 4)
    Err<MathError>:
      assert(false, eq: true)

  match(next_power_of_two(1073741824))
    Ok<i32> { value }:
      assert(value, eq: 1073741824)
    Err<MathError>:
      assert(false, eq: true)

test "next_power_of_two rejects overflow":
  match(next_power_of_two(1073741825))
    Ok<i32>:
      assert(false, eq: true)
    Err<MathError> { error }:
      assert(error.code, eq: 2)

  match(next_power_of_two(2147483647))
    Ok<i32>:
      assert(false, eq: true)
    Err<MathError> { error }:
      assert(error.code, eq: 2)

test "clamp and between support positional and labeled overloads":
  assert(clamp(7, 1, 5), eq: 5)
  assert(clamp(2, min: 5, max: 1), eq: 2)
  assert(clamp(0, min: 1, max: 5), eq: 1)

  assert(between(3, 1, 5), eq: true)
  assert(between(6, min: 1, max: 5), eq: false)
  assert(between(3, min: 5, max: 1), eq: true)

test "rem_euclid aliases mod_euclid":
  match(rem_euclid(-1, 4))
    Ok<i32> { value }:
      assert(value, eq: 3)
    Err<MathError>:
      assert(false, eq: true)

  match(rem_euclid(i64_from_i32(-1), i64_from_i32(4)))
    Ok<i64> { value }:
      assert(value, eq: i64_from_i32(3))
    Err<MathError>:
      assert(false, eq: true)

test "checked_div_rem returns values and rejects invalid cases":
  match(checked_div_rem(13, 5))
    Ok<(i32, i32)> { value }:
      assert(value.0, eq: 2)
      assert(value.1, eq: 3)
    Err<MathError>:
      assert(false, eq: true)

  match(checked_div_rem(13, by: 5))
    Ok<(i32, i32)> { value }:
      assert(value.0, eq: 2)
      assert(value.1, eq: 3)
    Err<MathError>:
      assert(false, eq: true)

  match(checked_div_rem(4, 0))
    Ok<(i32, i32)>:
      assert(false, eq: true)
    Err<MathError> { error }:
      assert(error.code, eq: 3)

  match(checked_div_rem(-2147483647 - 1, -1))
    Ok<(i32, i32)>:
      assert(false, eq: true)
    Err<MathError> { error }:
      assert(error.code, eq: 2)

  match(checked_div_rem(i64_from_i32(4), i64_from_i32(0)))
    Ok<(i64, i64)>:
      assert(false, eq: true)
    Err<MathError> { error }:
      assert(error.code, eq: 3)

test "power of two helpers work for i32 and i64":
  assert(is_power_of_two(1), eq: true)
  assert(is_power_of_two(8), eq: true)
  assert(is_power_of_two(6), eq: false)
  assert(is_power_of_two(-2), eq: false)

  match(prev_power_of_two(1))
    Ok<i32> { value }:
      assert(value, eq: 1)
    Err<MathError>:
      assert(false, eq: true)

  match(prev_power_of_two(19))
    Ok<i32> { value }:
      assert(value, eq: 16)
    Err<MathError>:
      assert(false, eq: true)

  match(prev_power_of_two(0))
    Ok<i32>:
      assert(false, eq: true)
    Err<MathError> { error }:
      assert(error.code, eq: 1)

  assert(is_power_of_two(i64_from_i32(16)), eq: true)
  assert(is_power_of_two(i64_from_i32(18)), eq: false)

  match(prev_power_of_two(i64_from_i32(33)))
    Ok<i64> { value }:
      assert(value, eq: i64_from_i32(32))
    Err<MathError>:
      assert(false, eq: true)

test "abs supports ints and floats":
  match(abs(9))
    Ok<i32> { value }:
      assert(value, eq: 9)
    Err<MathError>:
      assert(false, eq: true)

  match(abs(-9))
    Ok<i32> { value }:
      assert(value, eq: 9)
    Err<MathError>:
      assert(false, eq: true)

  match(abs(-2147483647 - 1))
    Ok<i32>:
      assert(false, eq: true)
    Err<MathError> { error }:
      assert(error.code, eq: 2)

  match(abs(i64_from_i32(-9)))
    Ok<i64> { value }:
      assert(value, eq: i64_from_i32(9))
    Err<MathError>:
      assert(false, eq: true)

  assert(abs(-2.5), eq: 2.5)
  assert(f64_from_f32(abs(f32_from_f64(-3.5))), eq: 3.5)

test "signum supports ints and floats including nan":
  assert(signum(-9), eq: -1)
  assert(signum(0), eq: 0)
  assert(signum(9), eq: 1)

  assert(signum(i64_from_i32(-9)), eq: i64_from_i32(-1))
  assert(signum(i64_from_i32(0)), eq: i64_from_i32(0))
  assert(signum(i64_from_i32(9)), eq: i64_from_i32(1))

  assert(signum(-2.5), eq: -1.0)
  assert(signum(0.0), eq: 0.0)
  assert(signum(2.5), eq: 1.0)
  assert(f64_from_f32(signum(f32_from_f64(-2.5))), eq: -1.0)

  let nan = 0.0 / 0.0
  assert(is_nan(signum(nan)), eq: true)

test "nan finite and infinite helpers work for f64 and f32":
  let finite = 12.5
  let inf = 1.0 / 0.0
  let nan = 0.0 / 0.0

  assert(is_finite(finite), eq: true)
  assert(is_infinite(finite), eq: false)
  assert(is_nan(finite), eq: false)

  assert(is_finite(inf), eq: false)
  assert(is_infinite(inf), eq: true)
  assert(is_nan(inf), eq: false)

  assert(is_finite(nan), eq: false)
  assert(is_infinite(nan), eq: false)
  assert(is_nan(nan), eq: true)

  let finite32 = f32_from_f64(3.5)
  let inf32 = f32_from_f64(1.0 / 0.0)
  let nan32 = f32_from_f64(0.0 / 0.0)
  assert(is_finite(finite32), eq: true)
  assert(is_infinite(inf32), eq: true)
  assert(is_nan(nan32), eq: true)

test "next_multiple_of rounds up and rejects invalid input":
  match(next_multiple_of(10, 3))
    Ok<i32> { value }:
      assert(value, eq: 12)
    Err<MathError>:
      assert(false, eq: true)

  match(next_multiple_of(12, factor: 3))
    Ok<i32> { value }:
      assert(value, eq: 12)
    Err<MathError>:
      assert(false, eq: true)

  match(next_multiple_of(-10, 3))
    Ok<i32> { value }:
      assert(value, eq: -9)
    Err<MathError>:
      assert(false, eq: true)

  match(next_multiple_of(7, 0))
    Ok<i32>:
      assert(false, eq: true)
    Err<MathError> { error }:
      assert(error.code, eq: 1)

  match(next_multiple_of(2147483647, 2))
    Ok<i32>:
      assert(false, eq: true)
    Err<MathError> { error }:
      assert(error.code, eq: 2)

  match(next_multiple_of(i64_from_i32(10), i64_from_i32(4)))
    Ok<i64> { value }:
      assert(value, eq: i64_from_i32(12))
    Err<MathError>:
      assert(false, eq: true)

@intrinsic(name: "__f32_demote_f64")
fn f32_from_f64(value: f64): () -> f32 __f32_demote_f64(value)

@intrinsic(name: "__f64_promote_f32")
fn f64_from_f32(value: f32): () -> f64 __f64_promote_f32(value)

fn i64_from_i32(value: i32): () -> i64 __i64_extend_s(value)
