use std::error::HostError
use std::msgpack::MsgPack
use std::msgpack::self as msgpack
use std::optional::types::all
use std::result::types::all
use std::string::type::{ String, StringSlice }
use std::test::assertions::all
use std::test::host_dto::self as host_dto_test

test "env get resolves same-name wrapper and decodes strings":
  let result = get_with_payload(string_payload("voyd".as_slice()))
  match(result)
    Some<String> { value }:
      assert(value.equals("voyd"), eq: true)
    None:
      assert(false, eq: true)

test "env get helpers parse bool and int":
  let bool_result = get_bool_with_payload(string_payload("TRUE".as_slice()))
  match(bool_result)
    Some<bool> { value }:
      assert(value, eq: true)
    None:
      assert(false, eq: true)

  let int_result = get_int_with_payload(string_payload("42".as_slice()))
  match(int_result)
    Some<i32> { value }:
      assert(value, eq: 42)
    None:
      assert(false, eq: true)

test "env set decodes host errors":
  let result = set_with_payload(host_dto_test::host_error_payload(code: 9, message: "denied"))
  match(result)
    Err<HostError> { error }:
      assert(error.code, eq: 9)
      assert(error.message.equals("denied"), eq: true)
    Ok<Unit>:
      assert(false, eq: true)

fn get_with_payload(payload: MsgPack): () -> Option<String>
  try
    get(key: "APP_NAME".as_slice())
  Env::get(tail, _key):
    tail(payload)
  Env::set(tail, _payload):
    tail(host_dto_test::host_error_payload(code: -1, message: "unused"))

fn get_bool_with_payload(payload: MsgPack): () -> Option<bool>
  try
    get_bool(key: "ENABLED".as_slice())
  Env::get(tail, _key):
    tail(payload)
  Env::set(tail, _payload):
    tail(host_dto_test::host_error_payload(code: -1, message: "unused"))

fn get_int_with_payload(payload: MsgPack): () -> Option<i32>
  try
    get_int(key: "PORT".as_slice())
  Env::get(tail, _key):
    tail(payload)
  Env::set(tail, _payload):
    tail(host_dto_test::host_error_payload(code: -1, message: "unused"))

fn set_with_payload(payload: MsgPack): () -> Result<Unit, HostError>
  try
    set(key: "PORT".as_slice(), value: "8080".as_slice())
  Env::get(tail, _key):
    tail(msgpack::make_null())
  Env::set(tail, _payload):
    tail(payload)

fn string_payload(value: StringSlice): () -> MsgPack
  msgpack::make_string(value.to_string())
