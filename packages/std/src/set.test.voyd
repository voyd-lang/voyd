use std::optional::types::all
use std::string::type::{ new_string }
use std::test::assertions::all
use std::traits::sequence::Sequence

fn accepts_sequence({ values: Sequence<String> }) -> bool
  true

test "set insert contains remove clear":
  let ~values = Set<String>::init()
  assert(values.is_empty(), eq: true)

  assert(values.insert("a"), eq: true)
  assert(values.insert("a"), eq: false)
  assert(values.insert("b"), eq: true)
  assert(values.len(), eq: 2)
  assert(values.contains("a"), eq: true)
  assert(values.contains("z"), eq: false)

  assert(values.remove("a"), eq: true)
  assert(values.remove("a"), eq: false)
  assert(values.contains("a"), eq: false)

  values.clear()
  assert(values.len(), eq: 0)
  assert(values.is_empty(), eq: true)

test "set values returns iterable keys":
  let ~values = Set<String>::init()
  values.insert("left")
  values.insert("right")

  assert(accepts_sequence(values: values.values()), eq: true)

  let ~iter = values.values().iter()
  var count = 0
  var has_left = false
  var has_right = false
  while true do:
    match(iter.next())
      Some<String> { value }:
        count = count + 1
        if value.equals("left"):
          has_left = true
        if value.equals("right"):
          has_right = true
      None:
        break

  assert(count, eq: 2)
  assert(has_left, eq: true)
  assert(has_right, eq: true)
