use std::bytes::ByteBuffer
use std::msgpack::self as msgpack
use std::test::assertions::all

test "fill_bytes calls host op and fills via fallback":
  let ~buf = ByteBuffer::init()
  let ~requested_lengths = Array<i32>::init()

  try
    fill_bytes(buf, 3)
  Random::fill_bytes(tail, requested):
    requested_lengths.push(requested)
    tail(msgpack::make_null())
  Random::next_i64(tail):
    tail(i64_from_i32(1))
  Random::next_u64(tail):
    tail(i64_from_i32(0))

  let bytes = buf.as_bytes().to_array()
  assert(optional_i32_or(requested_lengths.get(0), -1), eq: 3)
  assert(optional_i32_or(bytes.get(0), -1), eq: 1)
  assert(optional_i32_or(bytes.get(1), -1), eq: 1)
  assert(optional_i32_or(bytes.get(2), -1), eq: 1)

test "random_i32 defaults to full i32 domain":
  let value = random_i32_from_seed(i64_from_i32(7))
  assert(value, eq: 7)

test "random_i32 handles spans larger than i32":
  let value = random_i32_from_seed_with_range({
    seed: i64_from_i32(2147483647),
    range: Range<i32> {
      start: Some<i32> { value: -1 },
      end: Some<i32> { value: 2147483647 },
      include_end: false
    }
  })

  assert(value, eq: 2147483646)

test "random_i32 includes i32 max for inclusive upper bounds":
  let value = random_i32_from_seed_with_range({
    seed: i64_from_i32(1),
    range: Range<i32> {
      start: Some<i32> { value: 2147483646 },
      end: Some<i32> { value: 2147483647 },
      include_end: true
    }
  })

  assert(value, eq: 2147483647)

test "random_i64 defaults to full i64 domain":
  let seed = i64_from_i32(1234)
  let value = random_i64_from_seed(seed)
  assert(value, eq: seed)

test "random_i64 supports range overload":
  let value = random_i64_from_seed_with_range({
    seed: i64_from_i32(2147483647),
    range: Range<i64> {
      start: Some<i64> { value: i64_from_i32(-1) },
      end: Some<i64> { value: i64_from_i32(2147483647) },
      include_end: false
    }
  })

  assert(value, eq: i64_from_i32(2147483646))

test "random_i64 includes i32 max for inclusive upper bounds":
  let value = random_i64_from_seed_with_range({
    seed: i64_from_i32(1),
    range: Range<i64> {
      start: Some<i64> { value: i64_from_i32(2147483646) },
      end: Some<i64> { value: i64_from_i32(2147483647) },
      include_end: true
    }
  })

  assert(value, eq: i64_from_i32(2147483647))

test "next_u64 forwards host bits":
  let seed = i64_from_i32(-5)
  let value = next_u64_from_seed(seed)
  assert(value.bits, eq: seed)

test "random_f64 defaults to unit interval":
  let value = random_f64_from_seed(half_unit_seed_i64())
  assert(value, eq: 0.5)
  assert(value >= 0.0, eq: true)
  assert(value < 1.0, eq: true)

test "random_f64 supports range overload":
  let value = random_f64_from_seed_with_range({
    seed: half_unit_seed_i64(),
    range: Range<f64> {
      start: Some<f64> { value: 10.0 },
      end: Some<f64> { value: 20.0 },
      include_end: false
    }
  })

  assert(value, eq: 15.0)

test "random_f64 applies inclusive range end":
  let value = random_f64_from_seed_with_range({
    seed: half_unit_seed_i64(),
    range: Range<f64> {
      start: Some<f64> { value: 2.0 },
      end: Some<f64> { value: 4.0 },
      include_end: true
    }
  })

  assert(value, eq: 3.5)

test "random_f32 defaults to unit interval":
  let value = random_f32_from_seed(half_unit_seed_i64())
  assert(f64_from_f32(value), eq: 0.5)
  assert(f64_from_f32(value) >= 0.0, eq: true)
  assert(f64_from_f32(value) < 1.0, eq: true)

test "random_f32 supports range overload":
  let value = random_f32_from_seed_with_range({
    seed: half_unit_seed_i64(),
    range: Range<f32> {
      start: Some<f32> { value: f32_from_f64(2.0) },
      end: Some<f32> { value: f32_from_f64(4.0) },
      include_end: true
    }
  })

  assert(f64_from_f32(value), eq: 3.5)

test "local_rng uses deterministic sequence for a seed":
  let ~left = LocalRng::seeded(i64_from_i32(42))
  let ~right = LocalRng::seeded(i64_from_i32(42))
  let int_range = Range<i32> {
    start: Some<i32> { value: 10 },
    end: Some<i32> { value: 20 },
    include_end: false
  }

  assert(left.next_u64().bits, eq: right.next_u64().bits)
  assert(left.next_i64(), eq: right.next_i64())
  assert(left.random_f64(), eq: right.random_f64())
  assert(left.random_i32(int_range), eq: right.random_i32(int_range))

test "local_rng seeded_from_host consumes one host seed":
  let ~calls = Array<i32>::init()
  let ~unit_values = Array<f64>::init()
  let ~ranged_values = Array<f64>::init()

  try
    let ~rng = LocalRng::seeded_from_host()
    let unit = rng.random_f64()
    let ranged = rng.random_f64(
      Range<f64> {
        start: Some<f64> { value: 10.0 },
        end: Some<f64> { value: 20.0 },
        include_end: false
      }
    )
    unit_values.push(unit)
    ranged_values.push(ranged)
  Random::next_u64(tail):
    calls.push(1)
    tail(i64_from_i32(99))
  Random::next_i64(tail):
    calls.push(2)
    tail(i64_from_i32(0))
  Random::fill_bytes(tail, _len):
    calls.push(3)
    tail(msgpack::make_null())

  let unit = optional_f64_or(unit_values.get(0), -1.0)
  let ranged = optional_f64_or(ranged_values.get(0), -1.0)
  assert(unit >= 0.0, eq: true)
  assert(unit < 1.0, eq: true)
  assert(ranged >= 10.0, eq: true)
  assert(ranged < 20.0, eq: true)
  assert(optional_i32_or(calls.get(0), -1), eq: 1)
  assert(calls.len(), eq: 1)

fn random_i32_from_seed(seed: i64) -> i32
  try
    random_i32()
  Random::fill_bytes(tail, _len):
    tail(msgpack::make_null())
  Random::next_i64(tail):
    tail(seed)
  Random::next_u64(tail):
    tail(i64_from_i32(0))

fn random_i32_from_seed_with_range({ seed: i64, range: Range<i32> }) -> i32
  try
    random_i32(range)
  Random::fill_bytes(tail, _len):
    tail(msgpack::make_null())
  Random::next_i64(tail):
    tail(seed)
  Random::next_u64(tail):
    tail(i64_from_i32(0))

fn random_i64_from_seed(seed: i64) -> i64
  try
    random_i64()
  Random::fill_bytes(tail, _len):
    tail(msgpack::make_null())
  Random::next_i64(tail):
    tail(seed)
  Random::next_u64(tail):
    tail(i64_from_i32(0))

fn random_i64_from_seed_with_range({ seed: i64, range: Range<i64> }) -> i64
  try
    random_i64(range)
  Random::fill_bytes(tail, _len):
    tail(msgpack::make_null())
  Random::next_i64(tail):
    tail(seed)
  Random::next_u64(tail):
    tail(i64_from_i32(0))

fn random_f64_from_seed(seed: i64) -> f64
  try
    random_f64()
  Random::fill_bytes(tail, _len):
    tail(msgpack::make_null())
  Random::next_u64(tail):
    tail(seed)
  Random::next_i64(tail):
    tail(seed)

fn random_f64_from_seed_with_range({ seed: i64, range: Range<f64> }) -> f64
  try
    random_f64(range)
  Random::fill_bytes(tail, _len):
    tail(msgpack::make_null())
  Random::next_u64(tail):
    tail(seed)
  Random::next_i64(tail):
    tail(seed)

fn random_f32_from_seed(seed: i64) -> f32
  try
    random_f32()
  Random::fill_bytes(tail, _len):
    tail(msgpack::make_null())
  Random::next_u64(tail):
    tail(seed)
  Random::next_i64(tail):
    tail(seed)

fn random_f32_from_seed_with_range({ seed: i64, range: Range<f32> }) -> f32
  try
    random_f32(range)
  Random::fill_bytes(tail, _len):
    tail(msgpack::make_null())
  Random::next_u64(tail):
    tail(seed)
  Random::next_i64(tail):
    tail(seed)

fn next_u64_from_seed(seed: i64) -> U64Bits
  try
    next_u64()
  Random::fill_bytes(tail, _len):
    tail(msgpack::make_null())
  Random::next_i64(tail):
    tail(i64_from_i32(0))
  Random::next_u64(tail):
    tail(seed)

fn optional_i32_or(value: Option<i32>, fallback: i32): () -> i32
  match(value)
    Some<i32> { value: present }:
      present
    None:
      fallback

fn optional_f64_or(value: Option<f64>, fallback: f64): () -> f64
  match(value)
    Some<f64> { value: present }:
      present
    None:
      fallback

fn i64_from_i32(value: i32): () -> i64 __i64_extend_s(value)

fn half_unit_seed_i64() -> i64
  pow2_i64(52)

fn pow2_i64(exp: i32): () -> i64
  var out = i64_from_i32(1)
  var index = 0
  while index < exp do:
    out = out + out
    index = index + 1
  out

@intrinsic(name: "__f64_promote_f32")
fn f64_from_f32(value: f32): () -> f64 __f64_promote_f32(value)

@intrinsic(name: "__f32_demote_f64")
fn f32_from_f64(value: f64): () -> f32 __f32_demote_f64(value)
