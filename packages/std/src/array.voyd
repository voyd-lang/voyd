use std::fixed_array::fns::{ new_fixed_array }
use std::iterator::all
use std::optional::all
use std::math::all
use std::subscript::{ Range, SubscriptRead, SubscriptWrite }
use std::traits::ord::{ Ordering, less, equal, greater }

pub obj Array<T> {
  pri storage: FixedArray<T>,
  pri count: i32,
  pri owners: ArrayOwners
}

pub obj ArrayPop<T> {
  array: Array<T>,
  value?: T
}

impl<T> Array<T>
  api fn init() -> Array<T>
    Array<T> { storage: make_storage<T>(4), count: 0, owners: new_array_owners() }

  api fn with_capacity(size: i32) -> Array<T>
    let capacity = if size > 0 then: size else: 0
    Array<T> { storage: make_storage<T>(capacity), count: 0, owners: new_array_owners() }

  api fn from(source: FixedArray<T>) -> Optional<Array<T>>
    new_array<T>({ from: source })

  // Produces a shallow copy; writes clone storage before mutation.
  api fn copied(self, add_capacity?: i32) -> Array<T>
    let additional = add_capacity?.max(0) ?? 0
    let required = self.count + additional
    let current_capacity = __array_len(self.storage)
    if required > current_capacity:
      let next_capacity = growth_capacity(current_capacity, required)
      let next_raw = new_fixed_array<T>(next_capacity)
      __array_copy(next_raw, {
        from: self.storage,
        to_index: 0,
        from_index: 0,
        count: self.count
      })
      return Array<T> { storage: next_raw, count: self.count, owners: new_array_owners() }

    let ~owners = self.owners
    owners.retain()
    Array<T> { storage: self.storage, count: self.count, owners: self.owners }

  api fn len(self) -> i32
    self.count

  api fn capacity(self) -> i32
    __array_len(self.storage)

  api fn is_empty(self) -> bool
    self.count == 0

  api fn first(self) -> Optional<T>
    self.get(0)

  api fn last(self) -> Optional<T>
    self.get(-1)

  api fn get(self, { at index: i32 }) -> Option<T>
    self.get(index)

  api fn get(self, index: i32) -> Optional<T>
    let computed_index = compute_index(index, self.count)
    if computed_index < 0 or computed_index >= self.count:
      return none<T>()
    some(__array_get(self.storage, computed_index))

  api fn at(self, { at index: i32 }) -> T
    let computed_index = compute_index(index, self.count)
    if computed_index < 0 or computed_index >= self.count then:
      return trap_out_of_bounds(self.storage)
    __array_get(self.storage, computed_index)

  api fn slice(self, { range: Range }) -> Array<T>
    let start = normalize_range_start(range, self.count)
    let end = normalize_range_end_exclusive(range, self.count)
    self.slice(from: start, to: end)

  api fn slice(self, { from start: i32, to end: i32 }) -> Array<T>
    let computed_start = clamp_slice_index(start, self.count)
    let computed_end = clamp_slice_index(end, self.count)
    if computed_start >= computed_end:
      return Array<T>::with_capacity(0)

    let next_count = computed_end - computed_start
    let next_raw = new_fixed_array<T>(next_count)
    __array_copy(next_raw, {
      from: self.storage,
      to_index: 0,
      from_index: computed_start,
      count: next_count
    })
    Array<T> { storage: next_raw, count: next_count, owners: new_array_owners() }

  api fn map<O>(self, f: (v: T) -> O) -> Array<O>
    if self.count == 0:
      return Array<O>::with_capacity(0)

    let next_raw = new_fixed_array<O>(self.count)
    var index = 0
    while index < self.count:
      let value = __array_get(self.storage, index)
      __array_set(next_raw, index, f(value))
      index = index + 1

    Array<O> { storage: next_raw, count: self.count, owners: new_array_owners() }

  api fn map<O>(self, { map f: (value: T) -> O }) -> Array<O>
    self.map(f)

  api fn filter(self, pred: (v: T) -> bool) -> Array<T>
    let initial_capacity = if self.count > 0 then: self.count else: 0
    let ~out = Array<T>::with_capacity(initial_capacity)
    var index = 0
    while index < self.count:
      let value = __array_get(self.storage, index)
      if pred(value):
        out.push(value)
      index = index + 1
    out

  api fn filter(self, { where pred: (value: T) -> bool }) -> Array<T>
    self.filter(pred)

  api fn each(self, { do f: (value: T) -> void }) -> void
    var index = 0
    while index < self.count do:
      f(__array_get(self.storage, index))
      index = index + 1

  api fn flat_map<O>(self, f: (v: T) -> Array<O>) -> Array<O>
    let ~out = Array<O>::with_capacity(0)
    var index = 0
    while index < self.count:
      out.extend(f(__array_get(self.storage, index)))
      index = index + 1
    out

  api fn flat_map<O>(self, { map f: (value: T) -> Sequence<O> }) -> Array<O>
    let ~out = Array<O>::with_capacity(0)
    var index = 0
    while index < self.count do:
      let ~iter = f(__array_get(self.storage, index)).iter()
      while true do:
        match(iter.next())
          Some<O> { value }:
            out.push(value)
          None:
            break
      index = index + 1
    out

  api fn reduce<O>(self, initial: O, { step: (acc: O, v: T) -> O }) -> O
    var acc = initial
    var index = 0
    while index < self.count:
      let value = __array_get(self.storage, index)
      acc = step(acc, value)
      index = index + 1
    acc

  api fn reduce<O>(self, { initial: O, combine: (acc: O, value: T) -> O }) -> O
    self.reduce(initial, step: combine)

  api fn find(self, pred: (v: T) -> bool) -> Optional<T>
    var index = 0
    while index < self.count:
      let value = __array_get(self.storage, index)
      if pred(value):
        return Some<T> { value: value }
      index = index + 1
    None {}

  api fn find(self, { where pred: (value: T) -> bool }) -> Option<T>
    self.find(pred)

  api fn any(self, pred: (v: T) -> bool) -> bool
    var index = 0
    while index < self.count:
      if pred(__array_get(self.storage, index)):
        return true
      index = index + 1
    false

  api fn any(self, { where pred: (value: T) -> bool }) -> bool
    self.any(pred)

  api fn all(self, pred: (v: T) -> bool) -> bool
    var index = 0
    while index < self.count:
      if not pred(__array_get(self.storage, index)):
        return false
      index = index + 1
    true

  api fn all(self, { where pred: (value: T) -> bool }) -> bool
    self.all(pred)

  fn find_index_raw(self, value: T) -> i32
    var index = 0
    while index < self.count:
      if __array_get(self.storage, index) == value:
        return index
      index = index + 1
    -1

  fn find_index_where_raw(self, pred: (v: T) -> bool) -> i32
    var index = 0
    while index < self.count:
      if pred(__array_get(self.storage, index)):
        return index
      index = index + 1
    -1

  api fn contains(self, value: T) -> bool
    self.find_index_raw(value) >= 0

  api fn contains(self, { value: T }) -> bool
    self.contains(value)

  api fn contains(self, { where pred: (value: T) -> bool }) -> bool
    self.any(pred)

  api fn find_index(self, { value: T }) -> Option<i32>
    let index = self.find_index_raw(value)
    if index < 0 then:
      return None {}
    Some<i32> { value: index }

  api fn find_index(self, value: T) -> i32
    self.find_index_raw(value)

  api fn find_index(self, { where pred: (value: T) -> bool }) -> Option<i32>
    let index = self.find_index_where_raw(pred)
    if index < 0 then:
      return None {}
    Some<i32> { value: index }

  api fn find_index_where(self, pred: (v: T) -> bool) -> i32
    self.find_index_where_raw(pred)

  api fn sorted(self, compare: (left: T, right: T) -> i32) -> Array<T>
    let ~copy = self.copied()
    copy.sort(compare)
    copy

  api fn sorted(self) -> Array<T>
    self.sorted(
      (left: T, right: T) -> i32 =>
        default_compare_i32(left, right)
    )

  api fn sorted(self, { by compare: (left: T, right: T) -> Ordering }) -> Array<T>
    let ~copy = self.copied()
    copy.sort(by: compare)
    copy

  api fn reversed(self) -> Array<T>
    let ~copy = self.copied()
    copy.reverse()
    copy

  api fn to_fixed_array(self) -> FixedArray<T>
    let next_raw = new_fixed_array<T>(self.count)
    __array_copy(next_raw, {
      from: self.storage,
      to_index: 0,
      from_index: 0,
      count: self.count
    })
    next_raw

  api fn raw_storage(self) -> FixedArray<T>
    self.to_fixed_array()

  api fn enumerate(self) -> Array<(i32, T)>
    let next_raw = new_fixed_array<(i32, T)>(self.count)
    var index = 0
    while index < self.count:
      __array_set(next_raw, index, (index, __array_get(self.storage, index)))
      index = index + 1

    Array<(i32, T)> { storage: next_raw, count: self.count, owners: new_array_owners() }

  api fn concat(self, other: Array<T>) -> Array<T>
    self.extended(other)

  api fn take(self, n: i32) -> Array<T>
    if n <= 0 then:
      return Array<T>::with_capacity(0)
    let end = if n < self.count then: n else: self.count
    self.slice(from: 0, to: end)

  api fn take(self, { n: i32 }) -> Array<T>
    self.take(n)

  api fn drop(self, n: i32) -> Array<T>
    if n <= 0 then:
      return self.slice(from: 0, to: self.count)
    if n >= self.count then:
      return Array<T>::with_capacity(0)
    self.slice(from: n, to: self.count)

  api fn drop(self, { n: i32 }) -> Array<T>
    self.drop(n)

  api fn partition(self, pred: (v: T) -> bool) -> (Array<T>, Array<T>)
    let ~left = Array<T>::with_capacity(self.count)
    let ~right = Array<T>::with_capacity(self.count)
    var index = 0
    while index < self.count:
      let value = __array_get(self.storage, index)
      if pred(value):
        left.push(value)
      else:
        right.push(value)
      index = index + 1
    (left, right)

  api fn partition(self, { where pred: (value: T) -> bool }) -> (Array<T>, Array<T>)
    self.partition(pred)

  api fn chunk(self, { of size: i32 }) -> Array<Array<T>>
    if size <= 0 then:
      return Array<Array<T>>::with_capacity(0)
    if self.count == 0 then:
      return Array<Array<T>>::with_capacity(0)
    let ~out = Array<Array<T>>::with_capacity((self.count + size - 1) / size)
    var index = 0
    while index < self.count:
      let end = min(index + size, self.count)
      out.push(self.slice(from: index, to: end))
      index = index + size
    out

  api fn window(self, size: i32) -> Array<Array<T>>
    if size <= 0 then:
      return Array<Array<T>>::with_capacity(0)
    if size > self.count then:
      return Array<Array<T>>::with_capacity(0)
    let count = self.count - size + 1
    let ~out = Array<Array<T>>::with_capacity(count)
    var index = 0
    while index < count:
      out.push(self.slice(from: index, to: index + size))
      index = index + 1
    out

  api fn window(self, { size: i32 }) -> Array<Array<T>>
    self.window(size)

  api fn zip<U>(self, other: Array<U>) -> Array<(T, U)>
    let count = min(self.count, other.count)
    let next_raw = new_fixed_array<(T, U)>(count)
    var index = 0
    while index < count:
      __array_set(
        next_raw,
        index,
        (__array_get(self.storage, index), __array_get(other.storage, index))
      )
      index = index + 1
    Array<(T, U)> { storage: next_raw, count: count, owners: new_array_owners() }

  api fn zip<U>(self, { other: Sequence<U> }) -> Array<(T, U)>
    let ~out = Array<(T, U)>::with_capacity(self.count)
    let ~iter = other.iter()
    var index = 0
    while index < self.count do:
      match(iter.next())
        Some<U> { value: right }:
          out.push((__array_get(self.storage, index), right))
          index = index + 1
        None:
          break
    out

  api fn fold(self, combine: (left: T, right: T) -> T) -> Optional<T>
    if self.count == 0:
      return None {}

    var index = 1
    var acc = __array_get(self.storage, 0)
    while index < self.count:
      acc = combine(acc, __array_get(self.storage, index))
      index = index + 1
    Some<T> { value: acc }

  api fn fold(self, { combine: (left: T, right: T) -> T }) -> Option<T>
    self.fold(combine)

  api fn sort(~self, compare: (left: T, right: T) -> i32) -> void
    if self.count < 2:
      return void

    self.ensure_unique(self.count)
    var index = 1
    while index < self.count:
      let value = __array_get(self.storage, index)
      var cursor = index - 1
      while cursor >= 0 do:
        let shifted = __array_get(self.storage, cursor)
        if compare(shifted, value) <= 0 then:
          break
        __array_set(self.storage, cursor + 1, shifted)
        cursor = cursor - 1
      __array_set(self.storage, cursor + 1, value)
      index = index + 1

  api fn sort(~self) -> void
    self.sort(
      (left: T, right: T) -> i32 =>
        default_compare_i32(left, right)
    )

  api fn sort(~self, { by compare: (left: T, right: T) -> Ordering }) -> void
    if self.count < 2:
      return void

    self.ensure_unique(self.count)
    var index = 1
    while index < self.count:
      let value = __array_get(self.storage, index)
      var cursor = index - 1
      while cursor >= 0 do:
        let shifted = __array_get(self.storage, cursor)
        if ordering_to_i32(compare(shifted, value)) <= 0 then:
          break
        __array_set(self.storage, cursor + 1, shifted)
        cursor = cursor - 1
      __array_set(self.storage, cursor + 1, value)
      index = index + 1

  api fn reverse(~self) -> void
    if self.count < 2:
      return void

    self.ensure_unique(self.count)
    var left = 0
    var right = self.count - 1
    while left < right do:
      let left_value = __array_get(self.storage, left)
      let right_value = __array_get(self.storage, right)
      __array_set(self.storage, left, right_value)
      __array_set(self.storage, right, left_value)
      left = left + 1
      right = right - 1

  api fn clear(~self) -> void
    if self.count == 0:
      return void

    self.ensure_unique(self.count)
    self.count = 0

  api fn truncate(~self, { len: i32 }) -> void
    if len >= self.count then:
      return void
    if len <= 0 then:
      self.clear()
      return void
    self.ensure_unique(self.count)
    self.count = len

  api fn reserve(~self, additional: i32) -> void
    if additional <= 0:
      return void

    let required = self.count + additional
    self.ensure_unique(required)

  api fn reserve(~self, { additional: i32 }) -> void
    if additional <= 0:
      return void

    let required = self.count + additional
    self.ensure_unique(required)

  api fn push(~self, value: T) -> void
    let required = self.count + 1
    self.ensure_unique(required)
    __array_set(self.storage, self.count, value)
    self.count = required

  api fn push(~self, { value: T }) -> void
    let required = self.count + 1
    self.ensure_unique(required)
    __array_set(self.storage, self.count, value)
    self.count = required

  api fn pop(~self) -> Optional<T>
    if self.count == 0:
      return None {}

    self.ensure_unique(self.count)
    let last_index = self.count - 1
    let value = __array_get(self.storage, last_index)
    self.count = last_index
    Some<T> { value: value }

  api fn insert(~self, value: T, { at index: i32 }) -> void
    let insert_index = clamp_insert_index(index, self.count)
    let ~items = Array<T>::with_capacity(1)
    items.push(value)
    self.splice(at: insert_index, removing: 0, inserting: items)
    void

  api fn insert(~self, { value: T, at index: i32 }) -> void
    let insert_index = clamp_insert_index(index, self.count)
    let ~items = Array<T>::with_capacity(1)
    items.push(value)
    self.splice(at: insert_index, removing: 0, inserting: items)
    void

  api fn remove(~self, index: i32) -> Optional<T>
    let computed_index = compute_index(index, self.count)
    if computed_index < 0 or computed_index >= self.count:
      return None {}

    let removed = self.splice(
      at: computed_index,
      removing: 1,
      inserting: Array<T>::with_capacity(0)
    )
    removed.first()

  api fn remove(~self, { at index: i32 }) -> T
    let computed_index = compute_index(index, self.count)
    if computed_index < 0 or computed_index >= self.count then:
      return trap_out_of_bounds(self.storage)

    let removed = self.splice(
      at: computed_index,
      removing: 1,
      inserting: Array<T>::with_capacity(0)
    )
    match(removed.first())
      Some<T> { value }:
        value
      None:
        trap_out_of_bounds(self.storage)

  api fn extend(~self, other: Array<T>) -> void
    if other.count == 0:
      return void

    self.ensure_unique(self.count + other.count)
    let source = other.to_fixed_array()
    __array_copy(self.storage, {
      from: source,
      to_index: self.count,
      from_index: 0,
      count: other.count
    })
    self.count = self.count + other.count

  api fn extend(~self, { items: Sequence<T> }) -> void
    let ~iter = items.iter()
    while true do:
      match(iter.next())
        Some<T> { value }:
          self.push(value)
        None:
          break

  api fn splice(~self, { at start: i32, removing remove_count: i32, inserting items: Array<T> }) -> Array<T>
    let clamped_start = clamp_insert_index(start, self.count)
    let safe_delete_count =
      if remove_count < 0 then: 0 else: remove_count
    let available = self.count - clamped_start
    let effective_delete_count =
      if safe_delete_count > available then: available else: safe_delete_count

    let removed = self.slice(from: clamped_start, to: clamped_start + effective_delete_count)
    let insert_items = items.to_fixed_array()
    let insert_count = items.count

    let next_count = self.count - effective_delete_count + insert_count
    let current_capacity = self.capacity()
    let next_capacity =
      if next_count > current_capacity:
        growth_capacity(current_capacity, next_count)
      else:
        current_capacity

    let next_raw = new_fixed_array<T>(next_capacity)

    __array_copy(next_raw, {
      from: self.storage,
      to_index: 0,
      from_index: 0,
      count: clamped_start
    })

    __array_copy(next_raw, {
      from: insert_items,
      to_index: clamped_start,
      from_index: 0,
      count: insert_count
    })

    __array_copy(next_raw, {
      from: self.storage,
      to_index: clamped_start + insert_count,
      from_index: clamped_start + effective_delete_count,
      count: self.count - clamped_start - effective_delete_count
    })
    self.replace_storage(next_raw)
    self.count = next_count
    removed

  api fn replace(~self, index: i32, { with element: T }) -> bool
    let computed_index = compute_index(index, self.count)
    if computed_index < 0 or computed_index >= self.count:
      return false

    self.ensure_unique(self.count)
    __array_set(self.storage, computed_index, element)
    true

  api fn cleared(self) -> Array<T>
    let ~copy = self.copied()
    copy.clear()
    copy

  api fn reserved(self, additional: i32) -> Array<T>
    let ~copy = self.copied(additional)
    copy.reserve(additional)
    copy

  api fn pushed(self, value: T) -> Array<T>
    let ~copy = self.copied(1)
    copy.push(value: value)
    copy

  api fn popped(self) -> ArrayPop<T>
    let ~copy = self.copied()
    let value = copy.pop()
    ArrayPop<T> { array: copy, value }

  api fn inserted(self, value: T, { at index: i32 }) -> Array<T>
    let ~copy = self.copied(1)
    copy.insert(value, at: index)
    copy

  api fn removed(self, index: i32) -> Array<T>
    let ~copy = self.copied()
    copy.remove(index)
    copy

  api fn extended(self, other: Array<T>) -> Array<T>
    let ~copy = self.copied(other.count)
    copy.extend(other)
    copy

  api fn spliced(self, { at start: i32, removing remove_count: i32, inserting items: Array<T> }) -> Array<T>
    let ~copy = self.copied(items.count)
    copy.splice(at: start, removing: remove_count, inserting: items)
    copy

  fn ensure_unique(~self, required: i32) -> void
    let current_capacity = self.capacity()
    if required <= current_capacity and not self.owners.is_shared() then:
      return void

    let next_capacity =
      if required > current_capacity then:
        growth_capacity(current_capacity, required)
      else:
        current_capacity

    let next_raw = new_fixed_array<T>(next_capacity)
    __array_copy(next_raw, {
      from: self.storage,
      to_index: 0,
      from_index: 0,
      count: self.count
    })
    self.replace_storage(next_raw)

  fn replace_storage(~self, next_raw: FixedArray<T>) -> void
    self.release_owner()
    self.storage = next_raw
    self.owners = new_array_owners()

  fn release_owner(~self) -> void
    let ~owners = self.owners
    owners.release()

obj ArrayOwners {
  refs: i32
}

impl ArrayOwners
  fn init() -> ArrayOwners
    ArrayOwners { refs: 1 }

  fn retain(~self) -> void
    self.refs = self.refs + 1

  fn release(~self) -> void
    if self.refs <= 1 then:
      return void
    self.refs = self.refs - 1

  fn is_shared(self) -> bool
    self.refs > 1

fn compute_index(index: i32, length: i32) -> i32
  if index < 0 then: length + index else: index

fn clamp_slice_index(index: i32, length: i32) -> i32
  let computed = compute_index(index, length)
  if
    computed < 0: 0
    computed > length: length
    else: computed

fn clamp_insert_index(index: i32, length: i32) -> i32
  let computed = compute_index(index, length)
  if
    computed < 0: 0
    computed > length: length
    else: computed

fn growth_capacity(current_capacity: i32, required: i32) -> i32
  if required <= 0 then:
    if current_capacity > 0 then:
      return current_capacity
    return 0

  let base = if current_capacity > 0 then: current_capacity else: 4
  var next_capacity = base
  while next_capacity < required:
    next_capacity = next_capacity * 2
  next_capacity

fn trap_out_of_bounds<T>(source: FixedArray<T>) -> T
  __array_get(source, __array_len(source))

fn make_storage<T>(capacity: i32) -> FixedArray<T>
  let safe_capacity = if capacity > 0 then: capacity else: 0
  new_fixed_array<T>(safe_capacity)

fn default_compare_i32<T>(left: T, right: T) -> i32
  if left < right then:
    return -1
  if left > right then:
    return 1
  0

fn ordering_to_i32(value: Ordering) -> i32
  match(value)
    less:
      -1
    equal:
      0
    greater:
      1

fn new_array_owners() -> ArrayOwners
  ArrayOwners::init()

fn has_null_entries<T>(source: FixedArray<T>) -> bool
  let length = __array_len(source)
  var index = 0
  while index < length do:
    if ref_is_null(__array_get(source, index)) then:
      return true
    index = index + 1
  false

@intrinsic(name: "__ref_is_null")
fn ref_is_null<T>(value: T) -> bool
  __ref_is_null(value)

obj ArrayIterator<T> {
  array: Array<T>,
  index: i32
}

impl<T> Sequence<T> for Array<T>
  api fn iter(self) -> Iterator<T>
    ArrayIterator<T> { array: self, index: 0 }

impl<T> Iterator<T> for ArrayIterator<T>
  api fn next(~self) -> Option<T>
    if self.index >= self.array.len() then:
      return None {}
    let value = self.array.get(self.index)
    self.index = self.index + 1
    value

impl<T> SubscriptRead<i32, Optional<T>> for Array<T>
  api fn subscript_get(self, index: i32) -> Optional<T>
    self.get(index)

impl<T> SubscriptRead<Range, Array<T>> for Array<T>
  api fn subscript_get(self, range: Range) -> Array<T>
    let start = normalize_range_start(range, self.count)
    let end = normalize_range_end_exclusive(range, self.count)
    self.slice(from: start, to: end)

impl<T> SubscriptWrite<i32, T> for Array<T>
  api fn subscript_set(~self, index: i32, value: T) -> void
    let replaced = self.replace(index, with: value)
    if replaced then:
      return void
    __array_set(self.storage, self.capacity(), value)
    void

pub fn new_array<T>({ from source: FixedArray<T> }) -> Optional<Array<T>>
  if has_null_entries(source) then:
    None {}
  else:
    Some<Array<T>> {
      value: Array<T> { storage: source, count: __array_len(source), owners: new_array_owners() }
    }

pub fn new_array_unchecked<T>({ from source: FixedArray<T> }) -> Array<T>
  Array<T> { storage: source, count: __array_len(source), owners: new_array_owners() }

fn normalize_range_start(range: Range, length: i32) -> i32
  match(range.start)
    Some<i32> { value }:
      clamp_slice_index(value, length)
    None:
      0

fn normalize_range_end_exclusive(range: Range, length: i32) -> i32
  match(range.end)
    Some<i32> { value }:
      let clamped = clamp_slice_index(value, length)
      if not range.include_end then:
        return clamped
      if clamped >= length then:
        return length
      clamped + 1
    None:
      length
