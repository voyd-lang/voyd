use std::fixed_array::fns::{ new_fixed_array }
use std::iterator::all
use std::optional::all
use std::math::all

pub obj Array<T> {
  pri storage: FixedArray<T>,
  pri count: i32,
  pri owners: ArrayOwners
}

pub obj ArrayPop<T> {
  array: Array<T>,
  value?: T
}

impl<T> Array<T>
  api fn init() -> Array<T>
    Array<T>::new()

  api fn new() -> Array<T>
    Array<T> { storage: make_storage<T>(4), count: 0, owners: new_array_owners() }

  api fn with_capacity(size: i32) -> Array<T>
    let capacity = if size > 0 then: size else: 0
    Array<T> { storage: make_storage<T>(capacity), count: 0, owners: new_array_owners() }

  api fn from(source: FixedArray<T>) -> Optional<Array<T>>
    new_array<T>({ from: source })

  // Produces a shallow copy; writes clone storage before mutation.
  api fn copied(self, add_capacity?: i32) -> Array<T>
    let additional = add_capacity?.max(0) ?? 0
    let required = self.count + additional
    let current_capacity = __array_len(self.storage)
    if required > current_capacity:
      let next_capacity = growth_capacity(current_capacity, required)
      let next_raw = new_fixed_array<T>(next_capacity)
      __array_copy(next_raw, {
        from: self.storage,
        to_index: 0,
        from_index: 0,
        count: self.count
      })
      return Array<T> { storage: next_raw, count: self.count, owners: new_array_owners() }

    let ~owners = self.owners
    owners.retain()
    Array<T> { storage: self.storage, count: self.count, owners: self.owners }

  api fn length(self) -> i32
    self.count

  api fn capacity(self) -> i32
    __array_len(self.storage)

  api fn is_empty(self) -> bool
    self.count == 0

  api fn first(self) -> Optional<T>
    self.get(0)

  api fn last(self) -> Optional<T>
    self.get(-1)

  api fn get(self, index: i32) -> Optional<T>
    let computed_index = compute_index(index, self.count)
    if computed_index < 0 or computed_index >= self.count:
      return none<T>()
    some(__array_get(self.storage, computed_index))

  api fn slice(self, { from start: i32, to end: i32 }) -> Array<T>
    let computed_start = clamp_slice_index(start, self.count)
    let computed_end = clamp_slice_index(end, self.count)
    if computed_start >= computed_end:
      return Array<T>::with_capacity(0)

    let next_count = computed_end - computed_start
    let next_raw = new_fixed_array<T>(next_count)
    __array_copy(next_raw, {
      from: self.storage,
      to_index: 0,
      from_index: computed_start,
      count: next_count
    })
    Array<T> { storage: next_raw, count: next_count, owners: new_array_owners() }

  api fn map<O>(self, f: (v: T) -> O): () -> Array<O>
    if self.count == 0:
      return Array<O>::with_capacity(0)

    let next_raw = new_fixed_array<O>(self.count)
    var index = 0
    while index < self.count:
      let value = __array_get(self.storage, index)
      __array_set(next_raw, index, f(value))
      index = index + 1

    Array<O> { storage: next_raw, count: self.count, owners: new_array_owners() }

  api fn filter(self, pred: (v: T) -> bool): () -> Array<T>
    let initial_capacity = if self.count > 0 then: self.count else: 0
    var out = Array<T>::with_capacity(initial_capacity)
    var index = 0
    while index < self.count:
      let value = __array_get(self.storage, index)
      if pred(value):
        out = out.pushed(value)
      index = index + 1
    out

  api fn reduce<O>(self, initial: O, { step: (acc: O, v: T) -> O }): () -> O
    var acc = initial
    var index = 0
    while index < self.count:
      let value = __array_get(self.storage, index)
      acc = step(acc, value)
      index = index + 1
    acc

  api fn find(self, pred: (v: T) -> bool): () -> Optional<T>
    var index = 0
    while index < self.count:
      let value = __array_get(self.storage, index)
      if pred(value):
        return Some<T> { value: value }
      index = index + 1
    None {}

  api fn some(self, pred: (v: T) -> bool): () -> bool
    var index = 0
    while index < self.count:
      if pred(__array_get(self.storage, index)):
        return true
      index = index + 1
    false

  api fn every(self, pred: (v: T) -> bool): () -> bool
    var index = 0
    while index < self.count:
      if not pred(__array_get(self.storage, index)):
        return false
      index = index + 1
    true

  api fn index_of(self, value: T) -> i32
    var index = 0
    while index < self.count:
      if __array_get(self.storage, index) == value:
        return index
      index = index + 1
    -1

  api fn contains(self, value: T) -> bool
    self.index_of(value) >= 0

  api fn sorted(self, compare: (left: T, right: T) -> i32): () -> Array<T>
    let ~copy = self.copied()
    copy.sort(compare)
    copy

  api fn to_fixed_array(self) -> FixedArray<T>
    let next_raw = new_fixed_array<T>(self.count)
    __array_copy(next_raw, {
      from: self.storage,
      to_index: 0,
      from_index: 0,
      count: self.count
    })
    next_raw

  api fn raw_storage(self) -> FixedArray<T>
    self.to_fixed_array()

  api fn enumerate(self) -> Array<(i32, T)>
    let next_raw = new_fixed_array<(i32, T)>(self.count)
    var index = 0
    while index < self.count:
      __array_set(next_raw, index, (index, __array_get(self.storage, index)))
      index = index + 1

    Array<(i32, T)> { storage: next_raw, count: self.count, owners: new_array_owners() }

  api fn concat(self, other: Array<T>) -> Array<T>
    self.extended(other)

  api fn sort(~self, compare: (left: T, right: T) -> i32): () -> void
    if self.count < 2:
      return void

    self.ensure_unique(self.count)
    var index = 1
    while index < self.count:
      let value = __array_get(self.storage, index)
      var cursor = index - 1
      while cursor >= 0 do:
        let shifted = __array_get(self.storage, cursor)
        if compare(shifted, value) <= 0 then:
          break
        __array_set(self.storage, cursor + 1, shifted)
        cursor = cursor - 1
      __array_set(self.storage, cursor + 1, value)
      index = index + 1

  api fn clear(~self) -> void
    if self.count == 0:
      return void

    self.ensure_unique(self.count)
    self.count = 0

  api fn reserve(~self, additional: i32) -> void
    if additional <= 0:
      return void

    let required = self.count + additional
    self.ensure_unique(required)

  api fn push(~self, value: T) -> void
    let required = self.count + 1
    self.ensure_unique(required)
    __array_set(self.storage, self.count, value)
    self.count = required

  api fn pop(~self) -> Optional<T>
    if self.count == 0:
      return None {}

    self.ensure_unique(self.count)
    let last_index = self.count - 1
    let value = __array_get(self.storage, last_index)
    self.count = last_index
    Some<T> { value: value }

  api fn insert(~self, value: T, { at index: i32 }) -> void
    let insert_index = clamp_insert_index(index, self.count)
    let ~items = Array<T>::with_capacity(1)
    items.push(value)
    self.splice(at: insert_index, removing: 0, inserting: items)
    void

  api fn remove(~self, index: i32) -> Optional<T>
    let computed_index = compute_index(index, self.count)
    if computed_index < 0 or computed_index >= self.count:
      return None {}

    let removed = self.splice(
      at: computed_index,
      removing: 1,
      inserting: Array<T>::with_capacity(0)
    )
    removed.first()

  api fn extend(~self, other: Array<T>) -> void
    if other.count == 0:
      return void

    self.ensure_unique(self.count + other.count)
    let source = other.to_fixed_array()
    __array_copy(self.storage, {
      from: source,
      to_index: self.count,
      from_index: 0,
      count: other.count
    })
    self.count = self.count + other.count

  api fn splice(~self, { at start: i32, removing remove_count: i32, inserting items: Array<T> }) -> Array<T>
    let clamped_start = clamp_insert_index(start, self.count)
    let safe_delete_count =
      if remove_count < 0 then: 0 else: remove_count
    let available = self.count - clamped_start
    let effective_delete_count =
      if safe_delete_count > available then: available else: safe_delete_count

    let removed = self.slice(from: clamped_start, to: clamped_start + effective_delete_count)
    let insert_items = items.to_fixed_array()
    let insert_count = items.count

    let next_count = self.count - effective_delete_count + insert_count
    let current_capacity = self.capacity()
    let next_capacity =
      if next_count > current_capacity:
        growth_capacity(current_capacity, next_count)
      else:
        current_capacity

    let next_raw = new_fixed_array<T>(next_capacity)

    __array_copy(next_raw, {
      from: self.storage,
      to_index: 0,
      from_index: 0,
      count: clamped_start
    })

    __array_copy(next_raw, {
      from: insert_items,
      to_index: clamped_start,
      from_index: 0,
      count: insert_count
    })

    __array_copy(next_raw, {
      from: self.storage,
      to_index: clamped_start + insert_count,
      from_index: clamped_start + effective_delete_count,
      count: self.count - clamped_start - effective_delete_count
    })
    self.replace_storage(next_raw)
    self.count = next_count
    removed

  api fn replace(~self, index: i32, { with element: T }) -> bool
    let computed_index = compute_index(index, self.count)
    if computed_index < 0 or computed_index >= self.count:
      return false

    self.ensure_unique(self.count)
    __array_set(self.storage, computed_index, element)
    true

  api fn cleared(self) -> Array<T>
    let ~copy = self.copied()
    copy.clear()
    copy

  api fn reserved(self, additional: i32) -> Array<T>
    let ~copy = self.copied(additional)
    copy.reserve(additional)
    copy

  api fn pushed(self, value: T) -> Array<T>
    let ~copy = self.copied(1)
    copy.push(value)
    copy

  api fn popped(self) -> ArrayPop<T>
    let ~copy = self.copied()
    let value = copy.pop()
    ArrayPop<T> { array: copy, value }

  api fn inserted(self, value: T, { at index: i32 }) -> Array<T>
    let ~copy = self.copied(1)
    copy.insert(value, at: index)
    copy

  api fn removed(self, index: i32) -> Array<T>
    let ~copy = self.copied()
    copy.remove(index)
    copy

  api fn extended(self, other: Array<T>) -> Array<T>
    let ~copy = self.copied(other.count)
    copy.extend(other)
    copy

  api fn spliced(self, { at start: i32, removing remove_count: i32, inserting items: Array<T> }) -> Array<T>
    let ~copy = self.copied(items.count)
    copy.splice(at: start, removing: remove_count, inserting: items)
    copy

  fn ensure_unique(~self, required: i32) -> void
    let current_capacity = self.capacity()
    if required <= current_capacity and not self.owners.is_shared() then:
      return void

    let next_capacity =
      if required > current_capacity then:
        growth_capacity(current_capacity, required)
      else:
        current_capacity

    let next_raw = new_fixed_array<T>(next_capacity)
    __array_copy(next_raw, {
      from: self.storage,
      to_index: 0,
      from_index: 0,
      count: self.count
    })
    self.replace_storage(next_raw)

  fn replace_storage(~self, next_raw: FixedArray<T>) -> void
    self.release_owner()
    self.storage = next_raw
    self.owners = new_array_owners()

  fn release_owner(~self) -> void
    let ~owners = self.owners
    owners.release()

obj ArrayOwners {
  refs: i32
}

impl ArrayOwners
  fn init() -> ArrayOwners
    ArrayOwners { refs: 1 }

  fn retain(~self) -> void
    self.refs = self.refs + 1

  fn release(~self) -> void
    if self.refs <= 1 then:
      return void
    self.refs = self.refs - 1

  fn is_shared(self) -> bool
    self.refs > 1

fn compute_index(index: i32, length: i32) -> i32
  if index < 0 then: length + index else: index

fn clamp_slice_index(index: i32, length: i32) -> i32
  let computed = compute_index(index, length)
  if
    computed < 0: 0
    computed > length: length
    else: computed

fn clamp_insert_index(index: i32, length: i32) -> i32
  let computed = compute_index(index, length)
  if
    computed < 0: 0
    computed > length: length
    else: computed

fn growth_capacity(current_capacity: i32, required: i32) -> i32
  if required <= 0 then:
    if current_capacity > 0 then:
      return current_capacity
    return 0

  let base = if current_capacity > 0 then: current_capacity else: 4
  var next_capacity = base
  while next_capacity < required:
    next_capacity = next_capacity * 2
  next_capacity

fn make_storage<T>(capacity: i32) -> FixedArray<T>
  let safe_capacity = if capacity > 0 then: capacity else: 0
  new_fixed_array<T>(safe_capacity)

fn new_array_owners() -> ArrayOwners
  ArrayOwners::init()

fn has_null_entries<T>(source: FixedArray<T>) -> bool
  let length = __array_len(source)
  var index = 0
  while index < length do:
    if ref_is_null(__array_get(source, index)) then:
      return true
    index = index + 1
  false

@intrinsic(name: "__ref_is_null")
fn ref_is_null<T>(value: T) -> bool
  __ref_is_null(value)

obj ArrayIterator<T> {
  array: Array<T>,
  index: i32
}

impl<T> Iterable<T> for Array<T>
  api fn iterate(self) -> Iterator<T>
    ArrayIterator<T> { array: self, index: 0 }

impl<T> Iterator<T> for ArrayIterator<T>
  api fn next(~self) -> Option<T>
    if self.index >= self.array.length() then:
      return None {}
    let value = self.array.get(self.index)
    self.index = self.index + 1
    value

pub fn new_array<T>({ from source: FixedArray<T> }) -> Optional<Array<T>>
  if has_null_entries(source) then:
    None {}
  else:
    Some<Array<T>> {
      value: Array<T> { storage: source, count: __array_len(source), owners: new_array_owners() }
    }

pub fn new_array_unchecked<T>({ from source: FixedArray<T> }) -> Array<T>
  Array<T> { storage: source, count: __array_len(source), owners: new_array_owners() }
