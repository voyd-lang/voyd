use std::array::Array
use std::fixed_array::fns::{ new_fixed_array }
use std::optional::types::all
use std::string::type::{ String, new_string }
use std::subscript::{ SubscriptRead, SubscriptWrite }
use std::test::assertions::all

pub obj DictEntry<T> {
  api key: String,
  api value: T
}

pub obj Dict<T> {
  buckets: FixedArray<Array<DictEntry<T>>>,
  count: i32
}

obj BucketSetResult<T> {
  api bucket: Array<DictEntry<T>>,
  api inserted: bool
}

obj BucketDeleteResult<T> {
  api bucket: Array<DictEntry<T>>,
  api deleted: bool
}

obj EachStats {
  count: i32,
  sum: i32,
  has_a: bool
}

pub fn new_dict<T>(): () -> Dict<T>
  Dict<T>::new()

impl<T> Dict<T>
  api fn new(): () -> Dict<T>
    let buckets = new_buckets<T>(16)
    Dict<T> { buckets: buckets, count: 0 }

  api fn with_capacity(capacity: i32): () -> Dict<T>
    let target = if capacity > 0 then: capacity else: 0
    let min_bucket_count = 16
    let desired_bucket_count = next_power_of_two(target * 2)
    let bucket_count =
      if desired_bucket_count > min_bucket_count then:
        desired_bucket_count
      else:
        min_bucket_count

    let buckets = new_buckets<T>(bucket_count)
    Dict<T> { buckets: buckets, count: 0 }

  api fn len(self): () -> i32
    self.count

  api fn is_empty(self): () -> bool
    self.count == 0

  api fn contains_key(self, key: String): () -> bool
    if self.count == 0 then:
      return false

    let bucket_count = __array_len(self.buckets)
    let bucket_index = bucket_index_for_key(bucket_count, key)
    let bucket = __array_get(self.buckets, bucket_index)
    find_entry_index_in_bucket(bucket, key) >= 0

  api fn get(self, key: String): () -> Optional<T>
    if self.count == 0 then:
      return None {}

    let bucket_count = __array_len(self.buckets)
    let bucket_index = bucket_index_for_key(bucket_count, key)
    let bucket = __array_get(self.buckets, bucket_index)
    let entry_index = find_entry_index_in_bucket(bucket, key)
    if entry_index < 0 then:
      return None {}

    let entry = __array_get(bucket.raw_storage(), entry_index)
    Some<T> { value: entry.value }

  api fn get_or(self, key: String, default: T): () -> T
    match(self.get(key))
      Some<T> { value }:
        value
      None:
        default

  api fn get_or_else(self, key: String, default: () -> T) -> T
    match(self.get(key))
      Some<T> { value }:
        value
      None:
        default()

  api fn set(~self, key: String, value: T) -> void
    let next = self.with_set(key, value)
    self.buckets = next.buckets
    self.count = next.count

  api fn insert(~self, key: String, value: T) -> Optional<T>
    let previous = self.get(key)
    self.set(key, value)
    previous

  api fn remove(~self, key: String) -> Optional<T>
    let previous = self.get(key)
    let next = self.with_deleted(key)
    self.buckets = next.buckets
    self.count = next.count
    previous

  api fn clear(~self) -> void
    let next = self.with_cleared()
    self.buckets = next.buckets
    self.count = next.count

  api fn merged(self, other: Dict<T>): () -> Dict<T>
    if other.count == 0 then:
      return self

    var out = self
    let bucket_count = __array_len(other.buckets)
    var bucket_index = 0
    while bucket_index < bucket_count do:
      let bucket = __array_get(other.buckets, bucket_index)
      let storage = bucket.raw_storage()
      let len = bucket.len()
      var index = 0
      while index < len do:
        let entry = __array_get(storage, index)
        out = out.with_set(entry.key, entry.value)
        index = index + 1
      bucket_index = bucket_index + 1
    out

  api fn merge(~self, other: Dict<T>) -> void
    let next = self.merged(other)
    self.buckets = next.buckets
    self.count = next.count

  fn with_set(self, key: String, value: T) -> Dict<T>
    let bucket_count = __array_len(self.buckets)
    let bucket_index = bucket_index_for_key(bucket_count, key)
    let bucket = __array_get(self.buckets, bucket_index)
    let result = set_in_bucket(bucket, key, value)

    __array_set(self.buckets, bucket_index, result.bucket)
    let count = if result.inserted then: self.count + 1 else: self.count
    let next = Dict<T> { buckets: self.buckets, count: count }
    maybe_grow(next)

  fn with_deleted(self, key: String) -> Dict<T>
    if self.count == 0 then:
      return self

    let bucket_count = __array_len(self.buckets)
    let bucket_index = bucket_index_for_key(bucket_count, key)
    let bucket = __array_get(self.buckets, bucket_index)
    let result = delete_from_bucket(bucket, key)
    if result.deleted then:
      __array_set(self.buckets, bucket_index, result.bucket)
      return Dict<T> { buckets: self.buckets, count: self.count - 1 }
    self

  fn with_cleared(self) -> Dict<T>
    if self.count == 0 then:
      return self

    let bucket_count = __array_len(self.buckets)
    let buckets = new_buckets<T>(bucket_count)
    Dict<T> { buckets: buckets, count: 0 }

  api fn entries(self): () -> Array<DictEntry<T>>
    if self.count == 0 then:
      return Array<DictEntry<T>>::with_capacity(0)

    var out = Array<DictEntry<T>>::with_capacity(self.count)
    let bucket_count = __array_len(self.buckets)
    var bucket_index = 0
    while bucket_index < bucket_count do:
      let bucket = __array_get(self.buckets, bucket_index)
      out = out.extended(bucket)
      bucket_index = bucket_index + 1
    out

  api fn keys(self): () -> Array<String>
    if self.count == 0 then:
      return Array<String>::with_capacity(0)

    let ~out = Array<String>::with_capacity(self.count)
    let bucket_count = __array_len(self.buckets)
    var bucket_index = 0
    while bucket_index < bucket_count do:
      let bucket = __array_get(self.buckets, bucket_index)
      let storage = bucket.raw_storage()
      let len = bucket.len()
      var index = 0
      while index < len do:
        let entry = __array_get(storage, index)
        out.push(entry.key)
        index = index + 1
      bucket_index = bucket_index + 1
    out

  api fn values(self): () -> Array<T>
    if self.count == 0 then:
      return Array<T>::with_capacity(0)

    let ~out = Array<T>::with_capacity(self.count)
    let bucket_count = __array_len(self.buckets)
    var bucket_index = 0
    while bucket_index < bucket_count do:
      let bucket = __array_get(self.buckets, bucket_index)
      let storage = bucket.raw_storage()
      let len = bucket.len()
      var index = 0
      while index < len do:
        let entry = __array_get(storage, index)
        out.push(entry.value)
        index = index + 1
      bucket_index = bucket_index + 1
    out

  api fn each(self, f: (key: String, value: T) -> void) -> void
    if self.count == 0 then:
      return void

    let bucket_count = __array_len(self.buckets)
    var bucket_index = 0
    while bucket_index < bucket_count do:
      let bucket = __array_get(self.buckets, bucket_index)
      let storage = bucket.raw_storage()
      let len = bucket.len()
      var index = 0
      while index < len do:
        let entry = __array_get(storage, index)
        f(entry.key, entry.value)
        index = index + 1
      bucket_index = bucket_index + 1

  api fn map_values<U>(self, f: (value: T) -> U) -> Dict<U>
    if self.count == 0 then:
      return Dict<U>::new()

    var out = Dict<U>::with_capacity(self.count)
    let bucket_count = __array_len(self.buckets)
    var bucket_index = 0
    while bucket_index < bucket_count do:
      let bucket = __array_get(self.buckets, bucket_index)
      let storage = bucket.raw_storage()
      let len = bucket.len()
      var index = 0
      while index < len do:
        let entry = __array_get(storage, index)
        out = out.with_set(entry.key, f(entry.value))
        index = index + 1
      bucket_index = bucket_index + 1
    out

  api fn filter(self, pred: (key: String, value: T) -> bool) -> Dict<T>
    if self.count == 0 then:
      return self

    var out = Dict<T>::with_capacity(self.count)
    let bucket_count = __array_len(self.buckets)
    var bucket_index = 0
    while bucket_index < bucket_count do:
      let bucket = __array_get(self.buckets, bucket_index)
      let storage = bucket.raw_storage()
      let len = bucket.len()
      var index = 0
      while index < len do:
        let entry = __array_get(storage, index)
        if pred(entry.key, entry.value) then:
          out = out.with_set(entry.key, entry.value)
        index = index + 1
      bucket_index = bucket_index + 1
    out

impl<T> SubscriptRead<String, Optional<T>> for Dict<T>
  api fn subscript_get(self, key: String) -> Optional<T>
    self.get(key)

impl<T> SubscriptWrite<String, T> for Dict<T>
  api fn subscript_set(~self, key: String, value: T) -> void
    self.set(key, value)

fn new_buckets<T>(bucket_count: i32) -> FixedArray<Array<DictEntry<T>>>
  let safe_bucket_count = if bucket_count > 0 then: bucket_count else: 1
  let buckets = new_fixed_array<Array<DictEntry<T>>>(safe_bucket_count)
  var index = 0
  while index < safe_bucket_count do:
    __array_set(buckets, index, Array<DictEntry<T>>::new())
    index = index + 1
  buckets

fn maybe_grow<T>(map: Dict<T>) -> Dict<T>
  let bucket_count = __array_len(map.buckets)
  if should_grow(map.count, bucket_count) then:
    let next_bucket_count = bucket_count * 2
    return rehash_to_bucket_count(map, next_bucket_count)
  map

fn should_grow(count: i32, bucket_count: i32) -> bool
  if bucket_count <= 0 then:
    return true
  (count * 4) > (bucket_count * 3)

fn rehash_to_bucket_count<T>(map: Dict<T>, bucket_count: i32) -> Dict<T>
  let next_bucket_count = if bucket_count > 0 then: bucket_count else: 1
  let next_buckets = new_buckets<T>(next_bucket_count)

  let previous_bucket_count = __array_len(map.buckets)
  var bucket_index = 0
  while bucket_index < previous_bucket_count do:
    let bucket = __array_get(map.buckets, bucket_index)
    insert_bucket_entries(next_buckets, next_bucket_count, bucket)
    bucket_index = bucket_index + 1

  Dict<T> { buckets: next_buckets, count: map.count }

fn insert_bucket_entries<T>(
  buckets: FixedArray<Array<DictEntry<T>>>,
  bucket_count: i32,
  bucket: Array<DictEntry<T>>
) -> void
  let storage = bucket.raw_storage()
  let len = bucket.len()
  var index = 0
  while index < len do:
    let entry = __array_get(storage, index)
    insert_entry(buckets, bucket_count, entry)
    index = index + 1

fn insert_entry<T>(
  buckets: FixedArray<Array<DictEntry<T>>>,
  bucket_count: i32,
  entry: DictEntry<T>
) -> FixedArray<Array<DictEntry<T>>>
  let bucket_index = bucket_index_for_key(bucket_count, entry.key)
  let bucket = __array_get(buckets, bucket_index)
  let next_bucket = bucket.pushed(entry)
  __array_set(buckets, bucket_index, next_bucket)

fn find_entry_index_in_bucket<T>(bucket: Array<DictEntry<T>>, key: String) -> i32
  let storage = bucket.raw_storage()
  let len = bucket.len()
  var index = 0
  while index < len do:
    let entry = __array_get(storage, index)
    if entry.key.equals(key) then:
      return index
    index = index + 1
  -1

fn set_in_bucket<T>(bucket: Array<DictEntry<T>>, key: String, value: T) -> BucketSetResult<T>
  let index = find_entry_index_in_bucket(bucket, key)
  let entry = DictEntry<T> { key: key, value: value }

  if index < 0 then:
    let next_bucket = bucket.pushed(entry)
    return BucketSetResult<T> { bucket: next_bucket, inserted: true }

  let ~next_bucket = bucket.copied()
  next_bucket.replace(index, with: entry)
  BucketSetResult<T> { bucket: next_bucket, inserted: false }

fn delete_from_bucket<T>(bucket: Array<DictEntry<T>>, key: String) -> BucketDeleteResult<T>
  let index = find_entry_index_in_bucket(bucket, key)
  if index < 0 then:
    return BucketDeleteResult<T> { bucket: bucket, deleted: false }

  let next_bucket = bucket.removed(index)
  BucketDeleteResult<T> { bucket: next_bucket, deleted: true }

fn bucket_index_for_key(bucket_count: i32, key: String) -> i32
  let safe_bucket_count = if bucket_count > 0 then: bucket_count else: 1
  mod_i32(key.hash_i32(), safe_bucket_count)

fn mod_i32(value: i32, modulus: i32) -> i32
  if modulus <= 0 then:
    return 0

  let div = value / modulus
  let rem = value - div * modulus
  if rem < 0 then: rem + modulus else: rem

fn next_power_of_two(value: i32) -> i32
  let start = if value > 1 then: value else: 1
  var out = 1
  while out < start do:
    out = out * 2
  out

fn make_test_key(index: i32) -> String
  let a = index / 26
  let b = index - a * 26
  var bytes = new_fixed_array<i32>(2)
  bytes = __array_set(bytes, 0, 97 + a)
  bytes = __array_set(bytes, 1, 97 + b)
  new_string(bytes)

test "dict new is empty":
  let map = Dict<i32>::new()
  assert(map.len(), eq: 0)
  assert(map.is_empty(), eq: true)
  assert(map.contains_key("missing"), eq: false)

  let missing = map.get("missing")
  match(missing)
    Some<i32>:
      assert(false)
    None:
      assert(true)

test "dict set and get roundtrip":
  let ~map = Dict<i32>::new()
  map.set("a", 1)
  map.set("b", 2)
  assert(map.len(), eq: 2)
  assert(map.contains_key("a"), eq: true)

  match(map.get("b"))
    Some<i32> { value }:
      assert(value, eq: 2)
    None:
      assert(false)

test "dict subscript read and write":
  let ~map = Dict<i32>::new()
  map["a"] = 1
  map["b"] = 3

  match(map["a"])
    Some<i32> { value }:
      assert(value, eq: 1)
    None:
      assert(false)

  match(map["b"])
    Some<i32> { value }:
      assert(value, eq: 3)
    None:
      assert(false)

test "dict set overwrites without growing size":
  let ~map = Dict<i32>::new()
  map.set("a", 1)
  map.set("a", 9)
  assert(map.len(), eq: 1)
  match(map.get("a"))
    Some<i32> { value }:
      assert(value, eq: 9)
    None:
      assert(false)

test "dict remove removes key":
  let ~map = Dict<i32>::new()
  map.set("a", 1)
  assert(map.len(), eq: 1)
  map.remove("a")
  assert(map.len(), eq: 0)
  assert(map.contains_key("a"), eq: false)

test "dict clear removes all entries":
  let ~map = Dict<i32>::new()
  map.set("a", 1)
  map.set("b", 2)
  map.clear()
  assert(map.len(), eq: 0)
  assert(map.contains_key("a"), eq: false)

test "dict entries keys and values match size":
  let ~map = Dict<i32>::new()
  map.set("a", 1)
  map.set("b", 2)
  map.set("c", 3)

  let keys = map.keys()
  let values = map.values()
  let entries = map.entries()
  assert(keys.len(), eq: 3)
  assert(values.len(), eq: 3)
  assert(entries.len(), eq: 3)

  assert(map.contains_key("a"), eq: true)
  assert(values.contains(2), eq: true)

test "dict get_or and get_or_else":
  let ~map = Dict<i32>::new()
  map.set("a", 4)
  assert(map.get_or("a", 0), eq: 4)
  assert(map.get_or("missing", 9), eq: 9)
  assert(map.get_or_else("missing", () -> i32 => 11), eq: 11)

test "dict with_capacity supports inserts":
  let ~map = Dict<i32>::with_capacity(40)
  var index = 0
  while index < 40 do:
    map.set(make_test_key(index), index)
    index = index + 1
  assert(map.len(), eq: 40)
  assert(map.get_or(make_test_key(10), -1), eq: 10)

test "dict each visits all entries":
  let ~map = Dict<i32>::new()
  map.set("a", 1)
  map.set("b", 2)
  map.set("c", 3)
  let ~stats = EachStats { count: 0, sum: 0, has_a: false }
  map.each((key: String, value: i32) -> void =>
    stats.count = stats.count + 1
    stats.sum = stats.sum + value
    if key.equals("a") then:
      stats.has_a = true
    void
  )
  assert(stats.count, eq: map.len())
  assert(stats.sum, eq: 6)
  assert(stats.has_a, eq: true)

test "dict merged overwrites keys":
  let ~a = Dict<i32>::new()
  a.set("k1", 1)
  a.set("k2", 2)
  let ~b = Dict<i32>::new()
  b.set("k2", 9)
  b.set("k3", 3)
  let merged = a.merged(b)
  assert(merged.len(), eq: 3)
  assert(merged.get_or("k1", -1), eq: 1)
  assert(merged.get_or("k2", -1), eq: 9)
  assert(merged.get_or("k3", -1), eq: 3)

test "dict map_values transforms values":
  let ~map = Dict<i32>::new()
  map.set("a", 2)
  map.set("b", 4)
  let doubled = map.map_values<i32>((v: i32) -> i32 => v * 2)
  assert(doubled.len(), eq: 2)
  assert(doubled.get_or("a", -1), eq: 4)
  assert(doubled.get_or("b", -1), eq: 8)

test "dict filter removes entries":
  let ~map = Dict<i32>::new()
  map.set("a", 1)
  map.set("b", 2)
  map.set("c", 3)
  let filtered = map.filter((_k: String, v: i32) -> bool => v >= 2)
  assert(filtered.len(), eq: 2)
  assert(filtered.contains_key("a"), eq: false)
  assert(filtered.contains_key("b"), eq: true)
  assert(filtered.contains_key("c"), eq: true)

test "dict grows and preserves entries":
  let ~map = Dict<i32>::new()
  var index = 0
  while index < 80 do:
    map.set(make_test_key(index), index)
    index = index + 1
  assert(map.len(), eq: 80)
  assert(map.get_or(make_test_key(0), -1), eq: 0)
  assert(map.get_or(make_test_key(50), -1), eq: 50)
  assert(map.get_or(make_test_key(79), -1), eq: 79)

test "dict handles bucket collisions":
  let bucket_count = 16
  var found = false
  var key1 = make_test_key(0)
  var key2 = make_test_key(1)
  var a = 0
  while a < 200 do:
    let candidate1 = make_test_key(a)
    let index1 = bucket_index_for_key(bucket_count, candidate1)
    var b = a + 1
    while b < 200 do:
      let candidate2 = make_test_key(b)
      let index2 = bucket_index_for_key(bucket_count, candidate2)
      if index1 == index2 then:
        key1 = candidate1
        key2 = candidate2
        found = true
        b = 200
      else:
        b = b + 1
    if found then:
      a = 200
    else:
      a = a + 1

  assert(found, eq: true)
  let ~map = Dict<i32>::new()
  map.set(key1, 1)
  map.set(key2, 2)
  assert(map.len(), eq: 2)
  assert(map.get_or(key1, 0), eq: 1)
  assert(map.get_or(key2, 0), eq: 2)
