//! Environment variable access backed by host process APIs.
//!
//! `std::env` exposes typed reads for string/boolean/integer values plus a host-backed
//! mutation API for setting variables.

use std::error::HostError
use std::host_dto::HostDto
use std::msgpack::MsgPack
use std::msgpack::self as msgpack
use std::optional::types::all
use std::result::types::all
use std::string::type::{ ParseIntError, String, StringSlice, new_string }

/// Host environment effect used by `std::env`.
///
/// Operations in this effect mirror host process environment APIs and exchange
/// MessagePack payloads for typed decoding in this module.
@effect(id: "voyd.std.env")
pub eff Env
  /// Reads an environment variable value.
  ///
  /// `key` is a MessagePack string.
  /// Returns a MessagePack string when present, otherwise `null`.
  get(tail, key: MsgPack) -> MsgPack
  /// Sets an environment variable.
  ///
  /// `payload` contains `{ key, value }`.
  /// Returns `{ ok: true }` on success or `{ ok: false, code, message }` on failure.
  set(tail, payload: MsgPack) -> MsgPack

/// Reads an environment variable as a string, returning `None` when the key is missing.
pub fn get(key: String): Env -> Option<String>
  decode_optional_string(Env::get(msgpack::make_string(key)))

pub fn get(key: StringSlice): Env -> Option<String>
  get(key.to_string())

/// Reads an environment variable and parses it as a boolean.
pub fn get_boolean(key: String): Env -> Option<bool>
  match(get(key))
    Some<String> { value }:
      parse_env_bool(value)
    None:
      None {}

pub fn get_boolean(key: StringSlice): Env -> Option<bool>
  get_boolean(key.to_string())

/// Compatibility alias for `get_boolean`.
pub fn get_bool(key: String): Env -> Option<bool>
  get_boolean(key)

/// Compatibility alias for `get_boolean`.
pub fn get_bool(key: StringSlice): Env -> Option<bool>
  get_boolean(key)

/// Reads an environment variable and parses it as a 32-bit integer.
pub fn get_integer(key: String): Env -> Option<i32>
  match(get(key))
    Some<String> { value }:
      match(value.parse_int())
        Ok<i32> { value: parsed }:
          Some<i32> { value: parsed }
        Err<ParseIntError>:
          None {}
    None:
      None {}

pub fn get_integer(key: StringSlice): Env -> Option<i32>
  get_integer(key.to_string())

/// Compatibility alias for `get_integer`.
pub fn get_int(key: String): Env -> Option<i32>
  get_integer(key)

/// Compatibility alias for `get_integer`.
pub fn get_int(key: StringSlice): Env -> Option<i32>
  get_integer(key)

/// Sets an environment variable to the provided string value.
pub fn set(key: String, value: String): Env -> Result<Unit, HostError>
  decode_host_void_result(Env::set(encode_set_payload(key, value)))

pub fn set(key: StringSlice, value: StringSlice): Env -> Result<Unit, HostError>
  set(key.to_string(), value.to_string())

fn parse_env_bool(value: String): () -> Option<bool>
  let normalized = value.lowered()
  if normalized.equals("true") or normalized.equals("1"):
    return Some<bool> { value: true }
  if normalized.equals("false") or normalized.equals("0"):
    return Some<bool> { value: false }
  None {}

fn decode_optional_string(payload: MsgPack): () -> Option<String>
  payload.match(active)
    String:
      Some<String> { value: active }
    else:
      None {}

fn encode_set_payload(key: String, value: String): () -> MsgPack
  HostDto::init()
    .set("key", msgpack::make_string(key))
    .set("value", msgpack::make_string(value))
    .pack()

fn decode_host_void_result(payload: MsgPack): () -> Result<Unit, HostError>
  let decoded = HostDto::unpack(payload)
  if decoded.read_bool("ok"):
    return Ok<Unit> { value: Unit {} }

  Err<HostError> {
    error: HostError {
      code: decoded.read_i32("code"),
      message: decoded.read_string("message")
    }
  }
