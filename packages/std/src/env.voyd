use std::dict::Dict
use std::error::HostError
use std::msgpack::MsgPack
use std::msgpack::self as msgpack
use std::optional::types::all
use std::result::types::all
use std::string::type::{ ParseIntError, String, StringSlice, new_string }

@effect(id: "std::env::Env")
pub eff Env
  get(tail, key: MsgPack) -> MsgPack
  set(tail, payload: MsgPack) -> MsgPack

pub fn get({ key: StringSlice }): Env -> Option<String>
  decode_optional_string(Env::get(msgpack::make_string(key.to_string())))

pub fn get_bool({ key: StringSlice }): Env -> Option<bool>
  match(get(key: key))
    Some<String> { value }:
      parse_env_bool(value)
    None:
      None {}

pub fn get_int({ key: StringSlice }): Env -> Option<i32>
  match(get(key: key))
    Some<String> { value }:
      match(value.parse_int())
        Ok<i32> { value: parsed }:
          Some<i32> { value: parsed }
        Err<ParseIntError>:
          None {}
    None:
      None {}

pub fn set({ key: StringSlice, value: StringSlice }): Env -> Result<Unit, HostError>
  decode_host_void_result(Env::set(encode_set_payload(
    key: key.to_string(),
    value: value.to_string()
  )))

fn parse_env_bool(value: String): () -> Option<bool>
  let normalized = value.lowered()
  if normalized.equals("true") or normalized.equals("1") then:
    return Some<bool> { value: true }
  if normalized.equals("false") or normalized.equals("0") then:
    return Some<bool> { value: false }
  None {}

fn decode_optional_string(payload: MsgPack): () -> Option<String>
  payload.match(active)
    String:
      Some<String> { value: active }
    else:
      None {}

fn encode_set_payload({ key: String, value: String }): () -> MsgPack
  let ~payload = Dict<String, MsgPack>::init()
  payload.set(key: "key", value: msgpack::make_string(key))
  payload.set(key: "value", value: msgpack::make_string(value))
  msgpack::make_map(payload)

fn decode_host_void_result(payload: MsgPack): () -> Result<Unit, HostError>
  let decoded = msgpack::unpack_map(payload)
  if read_bool(decoded, "ok") then:
    return Ok<Unit> { value: Unit {} }

  Err<HostError> {
    error: HostError {
      code: read_i32(decoded, "code"),
      message: read_string(decoded, "message")
    }
  }

fn read_bool(map: Dict<String, MsgPack>, key: String): () -> bool
  msgpack::unpack_bool(read_msgpack(map, key))

fn read_i32(map: Dict<String, MsgPack>, key: String): () -> i32
  msgpack::unpack_i32(read_msgpack(map, key))

fn read_string(map: Dict<String, MsgPack>, key: String): () -> String
  msgpack::unpack_string(read_msgpack(map, key))

fn read_msgpack(map: Dict<String, MsgPack>, key: String): () -> MsgPack
  match(map.get(key: key))
    Some<MsgPack> { value }:
      value
    None:
      msgpack::make_null()
