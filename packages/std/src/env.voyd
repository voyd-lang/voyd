use std::error::HostError
use std::host_dto::HostDto
use std::msgpack::MsgPack
use std::msgpack::self as msgpack
use std::optional::types::all
use std::result::types::all
use std::string::type::{ ParseIntError, String, StringSlice, new_string }

@effect(id: "std::env::Env")
pub eff Env
  get(tail, key: MsgPack) -> MsgPack
  set(tail, payload: MsgPack) -> MsgPack

pub fn get({ key: StringSlice }): Env -> Option<String>
  decode_optional_string(Env::get(msgpack::make_string(key.to_string())))

pub fn get_bool({ key: StringSlice }): Env -> Option<bool>
  match(get(key: key))
    Some<String> { value }:
      parse_env_bool(value)
    None:
      None {}

pub fn get_int({ key: StringSlice }): Env -> Option<i32>
  match(get(key: key))
    Some<String> { value }:
      match(value.parse_int())
        Ok<i32> { value: parsed }:
          Some<i32> { value: parsed }
        Err<ParseIntError>:
          None {}
    None:
      None {}

pub fn set({ key: StringSlice, value: StringSlice }): Env -> Result<Unit, HostError>
  decode_host_void_result(Env::set(encode_set_payload(
    key: key.to_string(),
    value: value.to_string()
  )))

fn parse_env_bool(value: String): () -> Option<bool>
  let normalized = value.lowered()
  if normalized.equals("true") or normalized.equals("1") then:
    return Some<bool> { value: true }
  if normalized.equals("false") or normalized.equals("0") then:
    return Some<bool> { value: false }
  None {}

fn decode_optional_string(payload: MsgPack): () -> Option<String>
  payload.match(active)
    String:
      Some<String> { value: active }
    else:
      None {}

fn encode_set_payload({ key: String, value: String }): () -> MsgPack
  HostDto::init()
    .set("key", msgpack::make_string(key))
    .set("value", msgpack::make_string(value))
    .pack()

fn decode_host_void_result(payload: MsgPack): () -> Result<Unit, HostError>
  let decoded = HostDto::unpack(payload)
  if decoded.read_bool("ok") then:
    return Ok<Unit> { value: Unit {} }

  Err<HostError> {
    error: HostError {
      code: decoded.read_i32("code"),
      message: decoded.read_string("message")
    }
  }
