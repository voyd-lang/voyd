//! Time primitives and scheduling helpers backed by the host `Time` effect.
//! Includes monotonic timing (`Instant`), wall-clock timing (`SystemTime`),
//! duration utilities, and timer-based callbacks.

use std::error::HostError
use std::host_dto::HostDto
use std::msgpack::MsgPack
use std::msgpack::self as msgpack
use std::result::types::all
use std::string::type::new_string

/// Represents a millisecond-based time span.
pub obj Duration {
  millis: i64
}

impl Duration
  /// Constructs a duration from milliseconds.
  api fn from_millis(ms: i64) -> Duration
    Duration { millis: ms }

  /// Constructs a duration from seconds.
  api fn from_secs(s: i64) -> Duration
    Duration { millis: s * extend_i32_s(1000) }

  /// Returns the duration in milliseconds.
  api fn as_millis(self) -> i64
    self.millis

  /// Returns the duration in seconds.
  api fn as_secs(self) -> i64
    self.millis / extend_i32_s(1000)

/// Monotonic timestamp that is suitable for elapsed-time measurement.
pub obj Instant {
  monotonic_millis: i64
}

impl Instant
  /// Captures the current time value.
  api fn now(): Time -> Instant
    Instant { monotonic_millis: Time::monotonic_now_millis() }

  /// Returns the duration since this instant was captured.
  api fn elapsed(self): Time -> Duration
    let now = Time::monotonic_now_millis()
    Duration::from_millis(now - self.monotonic_millis)

/// Wall-clock timestamp represented as milliseconds from the Unix epoch.
pub obj SystemTime {
  unix_millis_value: i64
}

impl SystemTime
  /// Captures the current time value.
  api fn now(): Time -> SystemTime
    SystemTime { unix_millis_value: Time::system_now_millis() }

  /// Returns milliseconds since the Unix epoch.
  api fn unix_millis(self) -> i64
    self.unix_millis_value

/// Host-provided time and timer operations.
///
/// `std::time` encodes timer commands as MessagePack payloads and decodes host
/// responses into typed success/error values.
@effect(id: "voyd.std.time")
pub eff Time
  /// Returns a monotonic millisecond timestamp suitable for elapsed-time math.
  monotonic_now_millis(tail) -> i64
  /// Returns wall-clock milliseconds since Unix epoch.
  system_now_millis(tail) -> i64
  /// Suspends execution for `ms` milliseconds.
  ///
  /// Returns `{ ok: true }` on success or `{ ok: false, code, message }` on failure.
  sleep_millis(tail, ms: i64) -> MsgPack
  /// Creates a one-shot timer that fires once after `ms` milliseconds.
  ///
  /// Returns `{ ok: true }` or an error DTO.
  set_timeout_millis(tail, ms: i64) -> MsgPack
  /// Creates a repeating timer using `ms` as the interval.
  ///
  /// Returns `{ ok: true, value: timer_id }` or an error DTO.
  set_interval_millis(tail, ms: i64) -> MsgPack
  /// Clears a timer created by `set_timeout_millis` or `set_interval_millis`.
  ///
  /// `timer_id` must be the host-provided timer identifier.
  clear_timer(tail, timer_id: i64) -> MsgPack

/// Suspends execution for the provided millisecond count.
/// Example: `time::sleep(250)`.
pub fn sleep(ms: i64): Time -> Result<Unit, HostError>
  decode_host_void_result(Time::sleep_millis(ms))

/// Suspends execution for the provided duration.
/// Example: `time::sleep(Duration::from_secs(1))`.
pub fn sleep(duration: Duration): Time -> Result<Unit, HostError>
  sleep(duration.as_millis())

/// Schedules and runs a callback once after the provided duration.
/// Example: `time::on_timeout(Duration::from_millis(100), || do_work())`.
pub fn on_timeout(duration: Duration, callback: () -> void): Time -> Result<Unit, HostError>
  let scheduled = decode_host_void_result(
    Time::set_timeout_millis(duration.as_millis())
  )
  match(scheduled)
    Err<HostError> { error }:
      Err<HostError> { error: error }
    Ok<Unit>:
      callback()
      Ok<Unit> { value: Unit {} }

/// Runs a callback repeatedly at the provided interval.
/// The callback runs after each successful interval wait.
/// Example: `time::on_interval(Duration::from_secs(1), || tick())`.
pub fn on_interval(interval: Duration, callback: () -> void): Time -> Result<Unit, HostError>
  while true do:
    let timer_result = decode_timer_id_result(
      Time::set_interval_millis(interval.as_millis())
    )
    match(timer_result)
      Err<HostError> { error }:
        return Err<HostError> { error: error }
      Ok<i64> { value: timer_id }:
        let sleep_result = decode_host_void_result(
          Time::sleep_millis(interval.as_millis())
        )
        match(sleep_result)
          Err<HostError> { error }:
            let sleep_error = error
            let clear_result = decode_host_void_result(Time::clear_timer(timer_id))
            match(clear_result)
              Err<HostError> { error }:
                return Err<HostError> { error: error }
              Ok<Unit>:
                return Err<HostError> { error: sleep_error }
          Ok<Unit>:
            void
        let clear_result = decode_host_void_result(Time::clear_timer(timer_id))
        match(clear_result)
          Err<HostError> { error }:
            return Err<HostError> { error: error }
          Ok<Unit>:
            callback()
  Ok<Unit> { value: Unit {} }

fn decode_host_void_result(payload: MsgPack): () -> Result<Unit, HostError>
  let decoded = HostDto::unpack(payload)
  if decoded.read_bool("ok"):
    return Ok<Unit> { value: Unit {} }
  Err<HostError> {
    error: HostError {
      code: decoded.read_i32("code"),
      message: decoded.read_string("message")
    }
  }

fn decode_timer_id_result(payload: MsgPack): () -> Result<i64, HostError>
  let decoded = HostDto::unpack(payload)
  if decoded.read_bool("ok"):
    return Ok<i64> {
      value: msgpack::unpack_i64(decoded.read_msgpack("value"))
    }
  Err<HostError> {
    error: HostError {
      code: decoded.read_i32("code"),
      message: decoded.read_string("message")
    }
  }

fn extend_i32_s(value: i32): () -> i64 __i64_extend_s(value)
