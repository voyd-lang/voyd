use std::error::HostError
use std::host_dto::HostDto
use std::msgpack::MsgPack
use std::result::types::all
use std::string::type::new_string

pub obj Duration {
  millis: i64
}

impl Duration
  /// Constructs a duration from milliseconds.
  api fn from_millis({ ms: i64 }) -> Duration
    Duration { millis: ms }

  /// Constructs a duration from seconds.
  api fn from_secs({ s: i64 }) -> Duration
    Duration { millis: s * extend_i32_s(1000) }

  /// Returns the duration in milliseconds.
  api fn as_millis(self) -> i64
    self.millis

  /// Returns the duration in seconds.
  api fn as_secs(self) -> i64
    self.millis / extend_i32_s(1000)

pub obj Instant {
  monotonic_millis: i64
}

impl Instant
  /// Captures the current time value.
  api fn now(): Time -> Instant
    Instant { monotonic_millis: Time::monotonic_now_millis() }

  /// Returns the duration since this instant was captured.
  api fn elapsed(self): Time -> Duration
    let now = Time::monotonic_now_millis()
    Duration::from_millis(ms: now - self.monotonic_millis)

pub obj SystemTime {
  unix_millis_value: i64
}

impl SystemTime
  /// Captures the current time value.
  api fn now(): Time -> SystemTime
    SystemTime { unix_millis_value: Time::system_now_millis() }

  /// Returns milliseconds since the Unix epoch.
  api fn unix_millis(self) -> i64
    self.unix_millis_value

@effect(id: "std::time::Time")
pub eff Time
  monotonic_now_millis(tail) -> i64
  system_now_millis(tail) -> i64
  sleep_millis(tail, ms: i64) -> MsgPack

/// Suspends execution for the provided millisecond count.
pub fn sleep_millis({ ms: i64 }): Time -> Result<Unit, HostError>
  decode_host_void_result(Time::sleep_millis(ms))

/// Suspends execution for the provided duration.
pub fn sleep({ duration: Duration }): Time -> Result<Unit, HostError>
  sleep_millis(ms: duration.as_millis())

fn decode_host_void_result(payload: MsgPack): () -> Result<Unit, HostError>
  let decoded = HostDto::unpack(payload)
  if decoded.read_bool("ok") then:
    return Ok<Unit> { value: Unit {} }
  Err<HostError> {
    error: HostError {
      code: decoded.read_i32("code"),
      message: decoded.read_string("message")
    }
  }

fn extend_i32_s(value: i32): () -> i64 __i64_extend_s(value)
