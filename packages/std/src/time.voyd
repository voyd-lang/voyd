use std::error::HostError
use std::host_dto::HostDto
use std::msgpack::MsgPack
use std::msgpack::self as msgpack
use std::result::types::all
use std::string::type::new_string

pub obj Duration {
  millis: i64
}

impl Duration
  /// Constructs a duration from milliseconds.
  api fn from_millis({ ms: i64 }) -> Duration
    Duration { millis: ms }

  /// Constructs a duration from seconds.
  api fn from_secs({ s: i64 }) -> Duration
    Duration { millis: s * extend_i32_s(1000) }

  /// Returns the duration in milliseconds.
  api fn as_millis(self) -> i64
    self.millis

  /// Returns the duration in seconds.
  api fn as_secs(self) -> i64
    self.millis / extend_i32_s(1000)

pub obj Instant {
  monotonic_millis: i64
}

impl Instant
  /// Captures the current time value.
  api fn now(): Time -> Instant
    Instant { monotonic_millis: Time::monotonic_now_millis() }

  /// Returns the duration since this instant was captured.
  api fn elapsed(self): Time -> Duration
    let now = Time::monotonic_now_millis()
    Duration::from_millis(ms: now - self.monotonic_millis)

pub obj SystemTime {
  unix_millis_value: i64
}

impl SystemTime
  /// Captures the current time value.
  api fn now(): Time -> SystemTime
    SystemTime { unix_millis_value: Time::system_now_millis() }

  /// Returns milliseconds since the Unix epoch.
  api fn unix_millis(self) -> i64
    self.unix_millis_value

@effect(id: "std::time::Time")
pub eff Time
  monotonic_now_millis(tail) -> i64
  system_now_millis(tail) -> i64
  sleep_millis(tail, ms: i64) -> MsgPack
  set_timeout_millis(tail, ms: i64) -> MsgPack
  set_interval_millis(tail, ms: i64) -> MsgPack
  clear_timer(tail, timer_id: i64) -> MsgPack

/// Suspends execution for the provided millisecond count.
pub fn sleep({ ms: i64 }): Time -> Result<Unit, HostError>
  decode_host_void_result(Time::sleep_millis(ms))

/// Suspends execution for the provided duration.
pub fn sleep({ duration: Duration }): Time -> Result<Unit, HostError>
  sleep(ms: duration.as_millis())

/// Schedules and runs a callback once after the provided duration.
pub fn on_timeout({ duration: Duration, callback: () -> void }): Time -> Result<Unit, HostError>
  let scheduled = decode_host_void_result(
    Time::set_timeout_millis(duration.as_millis())
  )
  match(scheduled)
    Err<HostError> { error }:
      Err<HostError> { error: error }
    Ok<Unit>:
      callback()
      Ok<Unit> { value: Unit {} }

/// Runs a callback repeatedly at the provided interval.
pub fn on_interval({ interval: Duration, callback: () -> void }): Time -> Result<Unit, HostError>
  while true do:
    let timer_result = decode_timer_id_result(
      Time::set_interval_millis(interval.as_millis())
    )
    match(timer_result)
      Err<HostError> { error }:
        return Err<HostError> { error: error }
      Ok<i64> { value: timer_id }:
        let sleep_result = decode_host_void_result(
          Time::sleep_millis(interval.as_millis())
        )
        match(sleep_result)
          Err<HostError> { error }:
            let sleep_error = error
            let clear_result = decode_host_void_result(Time::clear_timer(timer_id))
            match(clear_result)
              Err<HostError> { error }:
                return Err<HostError> { error: error }
              Ok<Unit>:
                return Err<HostError> { error: sleep_error }
          Ok<Unit>:
            void
        let clear_result = decode_host_void_result(Time::clear_timer(timer_id))
        match(clear_result)
          Err<HostError> { error }:
            return Err<HostError> { error: error }
          Ok<Unit>:
            callback()
  Ok<Unit> { value: Unit {} }

fn decode_host_void_result(payload: MsgPack): () -> Result<Unit, HostError>
  let decoded = HostDto::unpack(payload)
  if decoded.read_bool("ok"):
    return Ok<Unit> { value: Unit {} }
  Err<HostError> {
    error: HostError {
      code: decoded.read_i32("code"),
      message: decoded.read_string("message")
    }
  }

fn decode_timer_id_result(payload: MsgPack): () -> Result<i64, HostError>
  let decoded = HostDto::unpack(payload)
  if decoded.read_bool("ok"):
    return Ok<i64> {
      value: msgpack::unpack_i64(decoded.read_msgpack("value"))
    }
  Err<HostError> {
    error: HostError {
      code: decoded.read_i32("code"),
      message: decoded.read_string("message")
    }
  }

fn extend_i32_s(value: i32): () -> i64 __i64_extend_s(value)
