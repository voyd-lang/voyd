//! Virtual DOM helpers.
//!
//! Utilities for constructing VX element payloads encoded as MsgPack maps.

use std::array::Array
use std::dict::{ Dict, DictKey }
use std::msgpack::MsgPack
use std::msgpack::self as msgpack
use std::optional::types::all
use std::string::type::{ String, new_string }

/// Creates a virtual DOM element payload for renderer consumption.
///
/// The returned value is a MsgPack map with `name`, `children`, and optional `attributes`.
pub fn create_element({
  /// Element tag or component identifier.
  name: String,
  /// Optional list of two-item key/value MsgPack pairs.
  attributes?: Array<Array<MsgPack>>,
  /// Ordered child node payloads.
  children: Array<MsgPack>
}) -> MsgPack
  let ~element = Dict<String, MsgPack>::init()
  element.set(key: "name", value: name)
  element.set(key: "children", value: children)
  if attributes is Some:
    let attrs = attributes_to_map(attributes.value)
    element.set(key: "attributes", value: msgpack::make_map(attrs))
  msgpack::make_map(element)

fn attributes_to_map(attributes: Array<Array<MsgPack>>): () -> Dict<String, MsgPack>
  let ~acc = Dict<String, MsgPack>::init()
  var index = 0
  while index < attributes.len() do:
    match(attributes.get(index))
      Some<Array<MsgPack>> { value: pair }:
        match(pair.get(0))
          Some<MsgPack> { value: key }:
            match(pair.get(1))
              Some<MsgPack> { value: value }:
                acc.set(key: msgpack::unpack_string(key), value: value)
              None:
                void
          None:
            void
      None:
        void
    index = index + 1
  acc
