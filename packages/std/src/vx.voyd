use std::array::Array
use std::dict::{ Dict, DictKey }
use std::msgpack::MsgPack
use std::msgpack::self as msgpack
use std::optional::types::all
use std::string::type::{ String, new_string }

/// Creates a virtual DOM element value for rendering.
pub fn create_element({
  name: String,
  attributes?: Array<Array<MsgPack>>,
  children: Array<MsgPack>
}) -> MsgPack
  let ~element = Dict<String, MsgPack>::init()
  element.set(key: "name", value: name)
  element.set(key: "children", value: children)
  if attributes is Some:
    let attrs = attributes_to_map(attributes.value)
    element.set(key: "attributes", value: msgpack::make_map(attrs))
  msgpack::make_map(element)

fn attributes_to_map(attributes: Array<Array<MsgPack>>): () -> Dict<String, MsgPack>
  let ~acc = Dict<String, MsgPack>::init()
  var index = 0
  while index < attributes.len() do:
    match(attributes.get(index))
      Some<Array<MsgPack>> { value: pair }:
        match(pair.get(0))
          Some<MsgPack> { value: key }:
            match(pair.get(1))
              Some<MsgPack> { value: value }:
                acc.set(key: msgpack::unpack_string(key), value: value)
              None:
                void
          None:
            void
      None:
        void
    index = index + 1
  acc
