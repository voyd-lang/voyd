
use std::result::types::all

pub obj MathError {
  /// Machine-readable error code.
  api code: i32
}

/// Returns the larger of two values.
pub fn max<T>(a: T, b: T) -> T
  if a > b then: a else: b

/// Returns the smaller of two values.
pub fn min<T>(a: T, b: T) -> T
  if a < b then: a else: b

/// Returns `value` clamped between `min` and `max` (inclusive).
pub fn clamp(value: i32, min: i32, max: i32) -> i32
  let lower = if min < max then: min else: max
  let upper = if min > max then: min else: max
  if
    value < lower: lower
    value > upper: upper
    else: value

/// Returns `value` clamped between `min` and `max` (inclusive).
pub fn clamp(value: i32, { min lower: i32, max upper: i32 }) -> i32
  clamp(value, lower, upper)

/// Returns `value` clamped between `min` and `max` (inclusive).
pub fn clamp(value: i64, min: i64, max: i64) -> i64
  let lower = if min < max then: min else: max
  let upper = if min > max then: min else: max
  if
    value < lower: lower
    value > upper: upper
    else: value

/// Returns `value` clamped between `min` and `max` (inclusive).
pub fn clamp(value: i64, { min lower: i64, max upper: i64 }) -> i64
  clamp(value, lower, upper)

/// Returns `value` clamped between `min` and `max` (inclusive).
pub fn clamp(value: f32, min: f32, max: f32) -> f32
  let lower = if min < max then: min else: max
  let upper = if min > max then: min else: max
  if
    value < lower: lower
    value > upper: upper
    else: value

/// Returns `value` clamped between `min` and `max` (inclusive).
pub fn clamp(value: f32, { min lower: f32, max upper: f32 }) -> f32
  clamp(value, lower, upper)

/// Returns `value` clamped between `min` and `max` (inclusive).
pub fn clamp(value: f64, min: f64, max: f64) -> f64
  let lower = if min < max then: min else: max
  let upper = if min > max then: min else: max
  if
    value < lower: lower
    value > upper: upper
    else: value

/// Returns `value` clamped between `min` and `max` (inclusive).
pub fn clamp(value: f64, { min lower: f64, max upper: f64 }) -> f64
  clamp(value, lower, upper)

/// Returns true when `value` is within `min..=max`.
pub fn between(value: i32, min: i32, max: i32) -> bool
  let lower = if min < max then: min else: max
  let upper = if min > max then: min else: max
  value >= lower and value <= upper

/// Returns true when `value` is within `min..=max`.
pub fn between(value: i32, { min lower: i32, max upper: i32 }) -> bool
  between(value, lower, upper)

/// Returns true when `value` is within `min..=max`.
pub fn between(value: i64, min: i64, max: i64) -> bool
  let lower = if min < max then: min else: max
  let upper = if min > max then: min else: max
  value >= lower and value <= upper

/// Returns true when `value` is within `min..=max`.
pub fn between(value: i64, { min lower: i64, max upper: i64 }) -> bool
  between(value, lower, upper)

/// Returns true when `value` is within `min..=max`.
pub fn between(value: f32, min: f32, max: f32) -> bool
  let lower = if min < max then: min else: max
  let upper = if min > max then: min else: max
  value >= lower and value <= upper

/// Returns true when `value` is within `min..=max`.
pub fn between(value: f32, { min lower: f32, max upper: f32 }) -> bool
  between(value, lower, upper)

/// Returns true when `value` is within `min..=max`.
pub fn between(value: f64, min: f64, max: f64) -> bool
  let lower = if min < max then: min else: max
  let upper = if min > max then: min else: max
  value >= lower and value <= upper

/// Returns true when `value` is within `min..=max`.
pub fn between(value: f64, { min lower: f64, max upper: f64 }) -> bool
  between(value, lower, upper)

/// Returns the Euclidean remainder for 32-bit integers.
pub fn mod_euclid(value: i32, modulus: i32) -> Result<i32, MathError>
  if modulus <= 0 then:
    return math_error(code: 1)

  let remainder = value % modulus
  Ok<i32> {
    value: if remainder < 0 then: remainder + modulus else: remainder
  }

/// Returns the Euclidean remainder for 64-bit integers.
pub fn mod_euclid(value: i64, modulus: i64) -> Result<i64, MathError>
  if modulus <= extend_i32_s(0) then:
    return math_error(code: 1)

  let remainder = value % modulus
  Ok<i64> {
    value: if remainder < extend_i32_s(0) then: remainder + modulus else: remainder
  }

/// Returns the Euclidean remainder for 32-bit integers.
pub fn rem_euclid(value: i32, modulus: i32) -> Result<i32, MathError>
  mod_euclid(value, modulus)

/// Returns the Euclidean remainder for 64-bit integers.
pub fn rem_euclid(value: i64, modulus: i64) -> Result<i64, MathError>
  mod_euclid(value, modulus)

/// Returns quotient and remainder for 32-bit integers.
pub fn div_rem(value: i32, divisor: i32) -> (i32, i32)
  (value / divisor, value % divisor)

/// Returns quotient and remainder for 64-bit integers.
pub fn div_rem(value: i64, divisor: i64) -> (i64, i64)
  (value / divisor, value % divisor)

/// Returns quotient and remainder, rejecting divide-by-zero and signed overflow.
pub fn checked_div_rem(value: i32, divisor: i32) -> Result<(i32, i32), MathError>
  if divisor == 0 then:
    return math_error(code: 3)
  if divisor == -1 then:
    if value < 0 then:
      let flipped = 0 - value
      if flipped < 0 then:
        return math_error(code: 2)
  Ok<(i32, i32)> { value: (value / divisor, value % divisor) }

/// Returns quotient and remainder, rejecting divide-by-zero and signed overflow.
pub fn checked_div_rem(value: i32, { by divisor: i32 }) -> Result<(i32, i32), MathError>
  checked_div_rem(value, divisor)

/// Returns quotient and remainder, rejecting divide-by-zero and signed overflow.
pub fn checked_div_rem(value: i64, divisor: i64) -> Result<(i64, i64), MathError>
  if divisor == extend_i32_s(0) then:
    return math_error(code: 3)
  if divisor == extend_i32_s(-1) then:
    if value < extend_i32_s(0) then:
      let flipped = extend_i32_s(0) - value
      if flipped < extend_i32_s(0) then:
        return math_error(code: 2)
  Ok<(i64, i64)> { value: (value / divisor, value % divisor) }

/// Returns quotient and remainder, rejecting divide-by-zero and signed overflow.
pub fn checked_div_rem(value: i64, { by divisor: i64 }) -> Result<(i64, i64), MathError>
  checked_div_rem(value, divisor)

/// Returns the next power of two for a 32-bit integer.
pub fn next_power_of_two(value: i32) -> Result<i32, MathError>
  let start = if value > 1 then: value else: 1
  var out = 1
  while out < start do:
    if out > 1073741823 then:
      return math_error(code: 2)
    out = out * 2
  Ok<i32> { value: out }

/// Returns true when `value` is a power of two.
pub fn is_power_of_two(value: i32) -> bool
  if value <= 0 then:
    return false
  bit_and_i32(value, value - 1) == 0

/// Returns true when `value` is a power of two.
pub fn is_power_of_two(value: i64) -> bool
  if value <= extend_i32_s(0) then:
    return false
  bit_and_i64(value, value - extend_i32_s(1)) == extend_i32_s(0)

/// Returns the greatest power of two less than or equal to `value`.
pub fn prev_power_of_two(value: i32) -> Result<i32, MathError>
  if value <= 0 then:
    return math_error(code: 1)
  var out = 1
  while out <= (value / 2) do:
    out = out * 2
  Ok<i32> { value: out }

/// Returns the greatest power of two less than or equal to `value`.
pub fn prev_power_of_two(value: i64) -> Result<i64, MathError>
  if value <= extend_i32_s(0) then:
    return math_error(code: 1)
  var out = extend_i32_s(1)
  while out <= (value / extend_i32_s(2)) do:
    out = out * extend_i32_s(2)
  Ok<i64> { value: out }

/// Returns the absolute value, rejecting signed overflow.
pub fn abs(value: i32) -> Result<i32, MathError>
  if value >= 0 then:
    return Ok<i32> { value }
  let out = 0 - value
  if out < 0 then:
    return math_error(code: 2)
  Ok<i32> { value: out }

/// Returns the absolute value, rejecting signed overflow.
pub fn abs(value: i64) -> Result<i64, MathError>
  if value >= extend_i32_s(0) then:
    return Ok<i64> { value }
  let out = extend_i32_s(0) - value
  if out < extend_i32_s(0) then:
    return math_error(code: 2)
  Ok<i64> { value: out }

/// Returns the absolute value.
pub fn abs(value: f64) -> f64
  if value < 0.0 then: 0.0 - value else: value

/// Returns the absolute value.
pub fn abs(value: f32) -> f32
  demote_f64(abs(promote_f32(value)))

/// Returns the sign of `value` as `-1`, `0`, or `1`.
pub fn signum(value: i32) -> i32
  if
    value < 0: -1
    value > 0: 1
    else: 0

/// Returns the sign of `value` as `-1`, `0`, or `1`.
pub fn signum(value: i64) -> i64
  if
    value < extend_i32_s(0): extend_i32_s(-1)
    value > extend_i32_s(0): extend_i32_s(1)
    else: extend_i32_s(0)

/// Returns the sign of `value` as `-1`, `0`, or `1`, preserving `NaN`.
pub fn signum(value: f64) -> f64
  if value != value then:
    return value
  if
    value < 0.0: -1.0
    value > 0.0: 1.0
    else: 0.0

/// Returns the sign of `value` as `-1`, `0`, or `1`, preserving `NaN`.
pub fn signum(value: f32) -> f32
  demote_f64(signum(promote_f32(value)))

/// Returns true when `value` is `NaN`.
pub fn is_nan(value: f64) -> bool
  value != value

/// Returns true when `value` is `NaN`.
pub fn is_nan(value: f32) -> bool
  is_nan(promote_f32(value))

/// Returns true when `value` is finite.
pub fn is_finite(value: f64) -> bool
  let gap = value - value
  gap == 0.0

/// Returns true when `value` is finite.
pub fn is_finite(value: f32) -> bool
  is_finite(promote_f32(value))

/// Returns true when `value` is infinite.
pub fn is_infinite(value: f64) -> bool
  not is_nan(value) and not is_finite(value)

/// Returns true when `value` is infinite.
pub fn is_infinite(value: f32) -> bool
  is_infinite(promote_f32(value))

/// Returns the smallest multiple of `factor` that is greater than or equal to `value`.
pub fn next_multiple_of(value: i32, factor: i32) -> Result<i32, MathError>
  if factor <= 0 then:
    return math_error(code: 1)

  match(mod_euclid(value, factor))
    Ok<i32> { value: rem }:
      if rem == 0 then:
        return Ok<i32> { value }
      let delta = factor - rem
      let next = value + delta
      if next < value then:
        return math_error(code: 2)
      Ok<i32> { value: next }
    Err<MathError> { error }:
      Err<MathError> { error }

/// Returns the smallest multiple of `factor` that is greater than or equal to `value`.
pub fn next_multiple_of(value: i32, { factor: i32 }) -> Result<i32, MathError>
  next_multiple_of(value, factor)

/// Returns the smallest multiple of `factor` that is greater than or equal to `value`.
pub fn next_multiple_of(value: i64, factor: i64) -> Result<i64, MathError>
  if factor <= extend_i32_s(0) then:
    return math_error(code: 1)

  match(mod_euclid(value, factor))
    Ok<i64> { value: rem }:
      if rem == extend_i32_s(0) then:
        return Ok<i64> { value }
      let delta = factor - rem
      let next = value + delta
      if next < value then:
        return math_error(code: 2)
      Ok<i64> { value: next }
    Err<MathError> { error }:
      Err<MathError> { error }

/// Returns the smallest multiple of `factor` that is greater than or equal to `value`.
pub fn next_multiple_of(value: i64, { factor: i64 }) -> Result<i64, MathError>
  next_multiple_of(value, factor)

fn math_error<T>({ code: i32 }) -> Result<T, MathError>
  Err<MathError> { error: MathError { code } }

@intrinsic(name: "__f32_demote_f64")
fn demote_f64(value: f64): () -> f32 __f32_demote_f64(value)

@intrinsic(name: "__f64_promote_f32")
fn promote_f32(value: f32): () -> f64 __f64_promote_f32(value)

@intrinsic(name: "__bit_and")
fn bit_and_i32(left: i32, right: i32): () -> i32 __bit_and(left, right)

@intrinsic(name: "__bit_and")
fn bit_and_i64(left: i64, right: i64): () -> i64 __bit_and(left, right)

fn extend_i32_s(value: i32): () -> i64 __i64_extend_s(value)
