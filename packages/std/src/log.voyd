//! Structured logging primitives backed by a host logging sink.
//!
//! `std::log` exposes level-specific helpers and typed field values for structured
//! payloads. Messages and fields are encoded as MessagePack maps/arrays.

use std::array::Array
use std::dict::Dict
use std::msgpack::MsgPack
use std::msgpack::self as msgpack
use std::optional::types::all
use std::string::{ String, StringSlice }
use std::string::type::new_string

pub obj LogTrace {}
pub obj LogDebug {}
pub obj LogInfo {}
pub obj LogWarn {}
pub obj LogError {}

pub type LogLevel = LogTrace | LogDebug | LogInfo | LogWarn | LogError

pub obj LogString {
  /// String field payload.
  api value: String
}

pub obj LogInt {
  /// Integer field payload.
  api value: i64
}

pub obj LogFloat {
  /// Floating-point field payload.
  api value: f64
}

pub obj LogBool {
  /// Boolean field payload.
  api value: bool
}

pub type LogFieldValue = LogString | LogInt | LogFloat | LogBool

pub obj LogField {
  /// Associated key for this entry.
  api key: String,
  /// Log field payload.
  api value: LogFieldValue
}

pub type LogFields = Array<LogField>

/// Host logging effect used by `std::log`.
///
/// `std::log` converts typed log-level and field values into a MessagePack map
/// consumed by the host log sink.
@effect(id: "std::log::Log")
pub eff Log
  /// Emits one structured log event.
  ///
  /// `payload` is a map with:
  /// - `level`: one of `trace|debug|info|warn|error`
  /// - `message`: log message string
  /// - `fields`: array of `{ key, value }` entries or null
  emit(tail, payload: MsgPack) -> void

/// Emits a trace-level log message.
pub fn trace(message: StringSlice): Log -> void
  Log::emit(log_emit_payload(LogTrace {}, message.to_string(), None {}))

/// Emits a trace-level log message.
pub fn trace(message: String): Log -> void
  trace(message.as_slice())

/// Emits a trace-level log message.
pub fn trace(message: StringSlice, fields: LogFields): Log -> void
  Log::emit(log_emit_payload(LogTrace {}, message.to_string(), Some<LogFields> { value: fields }))

/// Emits a trace-level log message.
pub fn trace(message: String, fields: LogFields): Log -> void
  trace(message.as_slice(), fields)

/// Emits a debug-level log message.
pub fn debug(message: StringSlice): Log -> void
  Log::emit(log_emit_payload(LogDebug {}, message.to_string(), None {}))

/// Emits a debug-level log message.
pub fn debug(message: String): Log -> void
  debug(message.as_slice())

/// Emits a debug-level log message.
pub fn debug(message: StringSlice, fields: LogFields): Log -> void
  Log::emit(log_emit_payload(LogDebug {}, message.to_string(), Some<LogFields> { value: fields }))

/// Emits a debug-level log message.
pub fn debug(message: String, fields: LogFields): Log -> void
  debug(message.as_slice(), fields)

/// Emits an info-level log message.
pub fn info(message: StringSlice): Log -> void
  Log::emit(log_emit_payload(LogInfo {}, message.to_string(), None {}))

/// Emits an info-level log message.
pub fn info(message: String): Log -> void
  info(message.as_slice())

/// Emits an info-level log message.
pub fn info(message: StringSlice, fields: LogFields): Log -> void
  Log::emit(log_emit_payload(LogInfo {}, message.to_string(), Some<LogFields> { value: fields }))

/// Emits an info-level log message.
pub fn info(message: String, fields: LogFields): Log -> void
  info(message.as_slice(), fields)

/// Emits a warning-level log message.
pub fn warn(message: StringSlice): Log -> void
  Log::emit(log_emit_payload(LogWarn {}, message.to_string(), None {}))

/// Emits a warning-level log message.
pub fn warn(message: String): Log -> void
  warn(message.as_slice())

/// Emits a warning-level log message.
pub fn warn(message: StringSlice, fields: LogFields): Log -> void
  Log::emit(log_emit_payload(LogWarn {}, message.to_string(), Some<LogFields> { value: fields }))

/// Emits a warning-level log message.
pub fn warn(message: String, fields: LogFields): Log -> void
  warn(message.as_slice(), fields)

/// Emits an error-level log message.
pub fn error(message: StringSlice): Log -> void
  Log::emit(log_emit_payload(LogError {}, message.to_string(), None {}))

/// Emits an error-level log message.
pub fn error(message: String): Log -> void
  error(message.as_slice())

/// Emits an error-level log message.
pub fn error(message: StringSlice, fields: LogFields): Log -> void
  Log::emit(log_emit_payload(LogError {}, message.to_string(), Some<LogFields> { value: fields }))

/// Emits an error-level log message.
pub fn error(message: String, fields: LogFields): Log -> void
  error(message.as_slice(), fields)

fn log_emit_payload(level: LogLevel, message: String, fields: Option<LogFields>): () -> MsgPack
  let ~payload = Dict<String, MsgPack>::init()
  payload.set("level", log_level_to_msgpack(level))
  payload.set("message", msgpack::make_string(message))
  payload.set("fields", log_fields_to_msgpack(fields))
  msgpack::make_map(payload)

fn log_level_to_msgpack(level: LogLevel): () -> MsgPack
  level.match(active)
    LogTrace:
      msgpack::make_string("trace")
    LogDebug:
      msgpack::make_string("debug")
    LogInfo:
      msgpack::make_string("info")
    LogWarn:
      msgpack::make_string("warn")
    LogError:
      msgpack::make_string("error")

fn log_fields_to_msgpack(fields: Option<LogFields>): () -> MsgPack
  match(fields)
    Some<LogFields> { value: field_values }:
      let ~encoded = Array<MsgPack>::with_capacity(field_values.len())
      var index = 0
      while index < field_values.len() do:
        match(field_values.get(index))
          Some<LogField> { value: field }:
            encoded.push(log_field_to_msgpack(field))
          None:
            void
        index = index + 1
      msgpack::make_array(encoded)
    None:
      msgpack::make_null()

fn log_field_to_msgpack(field: LogField): () -> MsgPack
  let ~entry = Dict<String, MsgPack>::init()
  entry.set("key", msgpack::make_string(field.key))
  entry.set("value", log_field_value_to_msgpack(field.value))
  msgpack::make_map(entry)

fn log_field_value_to_msgpack(value: LogFieldValue): () -> MsgPack
  value.match(active)
    LogString:
      msgpack::make_string(active.value)
    LogInt:
      msgpack::make_i64(active.value)
    LogFloat:
      msgpack::make_f64(active.value)
    LogBool:
      msgpack::make_bool(active.value)
