use std::array::Array
use std::bytes::{ ByteBuffer, Bytes }
use std::error::{ HostError, IoError }
use std::host_dto::HostDto
use std::math::{ MathError, mod_euclid }
use std::msgpack::MsgPack
use std::msgpack::self as msgpack
use std::optional::all
use std::result::types::all
use std::string::type::{ String, StringSlice, new_string }

pub obj InputRequest {
  /// Optional prompt shown before reading input.
  api prompt?: String
}

impl InputRequest
  /// Builds a read request.
  api fn init({ prompt?: StringSlice }) -> InputRequest
    InputRequest { prompt: prompt?.to_string() }

@effect(id: "std::input::Input")
pub eff Input
  read_line(tail, payload: MsgPack) -> MsgPack
  read_bytes_op(tail, payload: MsgPack) -> MsgPack
  is_tty_op(tail) -> bool

/// Reads a line from stdin (or host prompt source).
pub fn read_line(): Input -> Result<Option<String>, HostError>
  read_line(request: InputRequest::init())

/// Reads a line using a prompt.
pub fn read_line({ prompt: StringSlice }): Input -> Result<Option<String>, HostError>
  read_line(request: InputRequest::init(prompt: prompt))

/// Reads a line using an explicit request value.
pub fn read_line({ request: InputRequest }): Input -> Result<Option<String>, HostError>
  decode_read_line_result(Input::read_line(encode_read_line_payload(request)))

/// Reads up to `max_bytes` raw bytes from stdin.
pub fn read_bytes({ max_bytes: i32 }): Input -> Result<Option<Bytes>, IoError>
  decode_read_bytes_result(Input::read_bytes_op(encode_read_bytes_payload(max_bytes)))

/// Returns true when stdin is attached to an interactive terminal.
pub fn is_tty(): Input -> bool
  Input::is_tty_op()

fn encode_read_line_payload(request: InputRequest): () -> MsgPack
  match(request.prompt)
    Some<String> { value }:
      HostDto::init()
        .set("prompt", msgpack::make_string(value))
        .pack()
    None:
      HostDto::init()
        .set("prompt", msgpack::make_null())
        .pack()

fn decode_read_line_result(payload: MsgPack): () -> Result<Option<String>, HostError>
  let decoded = HostDto::unpack(payload)
  if decoded.read_bool("ok") == false:
    return Err<HostError> { error: decode_host_error(decoded) }

  Ok<Option<String>> {
    value: decode_optional_string(decoded.read_msgpack("value"))
  }

fn decode_optional_string(payload: MsgPack): () -> Option<String>
  payload.match(active)
    String:
      Some<String> { value: active }
    else:
      None {}

fn encode_read_bytes_payload(max_bytes: i32): () -> MsgPack
  HostDto::init()
    .set("max_bytes", msgpack::make_i32(max_bytes))
    .pack()

fn decode_read_bytes_result(payload: MsgPack): () -> Result<Option<Bytes>, IoError>
  let decoded = HostDto::unpack(payload)
  if decoded.read_bool("ok") == false then:
    return Err<IoError> { error: decode_io_error(decoded) }

  Ok<Option<Bytes>> { value: decode_optional_bytes(decoded.read_msgpack("value")) }

fn decode_optional_bytes(payload: MsgPack): () -> Option<Bytes>
  payload.match(active)
    Array:
      Some<Bytes> { value: decode_bytes_array(active) }
    else:
      None {}

fn decode_bytes_array(source: Array<MsgPack>): () -> Bytes
  let ~buffer = ByteBuffer::with_capacity(bytes: source.len())
  var index = 0
  while index < source.len() do:
    match(source.get(index))
      Some<MsgPack> { value }:
        buffer.push(value: normalize_byte(msgpack::unpack_i32(value)))
      None:
        void
    index = index + 1
  buffer.as_bytes()

fn normalize_byte(value: i32): () -> i32
  match(mod_euclid(value, 256))
    Ok<i32> { value }:
      value
    Err<MathError>:
      0

fn decode_io_error(payload: HostDto): () -> IoError
  IoError {
    code: payload.read_i32("code"),
    message: payload.read_string("message")
  }

fn decode_host_error(payload: HostDto): () -> HostError
  HostError {
    code: payload.read_i32("code"),
    message: payload.read_string("message")
  }
