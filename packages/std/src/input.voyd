//! Standard input helpers backed by host-provided input streams.
//!
//! `std::input` supports line-based reads, raw byte reads, and terminal detection.
//! Host interactions are encoded as MessagePack DTOs and decoded into typed results.

use std::array::Array
use std::bytes::{ ByteBuffer, Bytes }
use std::error::{ HostError, IoError }
use std::host_dto::HostDto
use std::math::{ MathError, mod_euclid }
use std::msgpack::MsgPack
use std::msgpack::self as msgpack
use std::optional::all
use std::result::types::all
use std::string::type::{ String, StringSlice, new_string }

pub obj InputRequest {
  /// Optional prompt shown before reading input.
  api prompt?: String
}

impl InputRequest
  /// Builds a read request.
  api fn init(prompt?: StringSlice) -> InputRequest
    input_request_with_prompt(prompt?.to_string())

  /// Builds a read request.
  api fn init(prompt: String) -> InputRequest
    InputRequest::init(prompt.as_slice())

/// Host input effect used by `std::input`.
///
/// Operations in this effect map host stdin facilities into typed MessagePack
/// DTOs consumed by this module.
@effect(id: "voyd.std.input")
pub eff Input
  /// Reads one line using the provided payload.
  ///
  /// `payload` may include a `prompt` field (`string` or `null`).
  /// Returns `{ ok, value }` where `value` is a string or null, or an error DTO.
  read_line(tail, payload: MsgPack) -> MsgPack
  /// Reads up to `max_bytes` bytes from standard input.
  ///
  /// `payload` contains `{ max_bytes }`.
  /// Returns `{ ok, value }` where `value` is a byte array or null, or an error DTO.
  read_bytes_op(tail, payload: MsgPack) -> MsgPack
  /// Reports whether stdin is attached to an interactive terminal.
  is_tty_op(tail) -> bool

/// Reads a line from stdin (or host prompt source).
///
/// Returns `Ok(None)` at end-of-input.
pub fn read_line(): Input -> Result<Option<String>, HostError>
  read_line(InputRequest::init())

/// Reads a line using a prompt.
///
/// Example:
/// `let next = input::read_line("> ".as_slice())`
pub fn read_line(prompt: StringSlice): Input -> Result<Option<String>, HostError>
  read_line(InputRequest::init(prompt))

/// Reads a line using a prompt.
pub fn read_line(prompt: String): Input -> Result<Option<String>, HostError>
  read_line(prompt.as_slice())

/// Reads a line using an explicit request value.
pub fn read_line(request: InputRequest): Input -> Result<Option<String>, HostError>
  decode_read_line_result(Input::read_line(encode_read_line_payload(request)))

/// Reads up to `max_bytes` raw bytes from stdin.
///
/// Returns `Ok(None)` when no more bytes are available.
pub fn read_bytes(max_bytes: i32): Input -> Result<Option<Bytes>, IoError>
  decode_read_bytes_result(Input::read_bytes_op(encode_read_bytes_payload(max_bytes)))

/// Returns true when stdin is attached to an interactive terminal.
pub fn is_tty(): Input -> bool
  Input::is_tty_op()

fn input_request_with_prompt(prompt?: String): () -> InputRequest
  InputRequest { prompt }

fn encode_read_line_payload(request: InputRequest): () -> MsgPack
  match(request.prompt)
    Some<String> { value }:
      HostDto::init()
        .set("prompt", msgpack::make_string(value))
        .pack()
    None:
      HostDto::init()
        .set("prompt", msgpack::make_null())
        .pack()

fn decode_read_line_result(payload: MsgPack): () -> Result<Option<String>, HostError>
  let decoded = HostDto::unpack(payload)
  if decoded.read_bool("ok") == false:
    return Err<HostError> { error: decode_host_error(decoded) }

  Ok<Option<String>> {
    value: decode_optional_string(decoded.read_msgpack("value"))
  }

fn decode_optional_string(payload: MsgPack): () -> Option<String>
  payload.match(active)
    String:
      Some<String> { value: active }
    else:
      None {}

fn encode_read_bytes_payload(max_bytes: i32): () -> MsgPack
  HostDto::init()
    .set("max_bytes", msgpack::make_i32(max_bytes))
    .pack()

fn decode_read_bytes_result(payload: MsgPack): () -> Result<Option<Bytes>, IoError>
  let decoded = HostDto::unpack(payload)
  if decoded.read_bool("ok") == false then:
    return Err<IoError> { error: decode_io_error(decoded) }

  Ok<Option<Bytes>> { value: decode_optional_bytes(decoded.read_msgpack("value")) }

fn decode_optional_bytes(payload: MsgPack): () -> Option<Bytes>
  payload.match(active)
    Array:
      Some<Bytes> { value: decode_bytes_array(active) }
    else:
      None {}

fn decode_bytes_array(source: Array<MsgPack>): () -> Bytes
  let ~buffer = ByteBuffer::with_capacity(source.len())
  var index = 0
  while index < source.len() do:
    match(source.get(index))
      Some<MsgPack> { value }:
        buffer.push(normalize_byte(msgpack::unpack_i32(value)))
      None:
        void
    index = index + 1
  buffer.as_bytes()

fn normalize_byte(value: i32): () -> i32
  match(mod_euclid(value, 256))
    Ok<i32> { value }:
      value
    Err<MathError>:
      0

fn decode_io_error(payload: HostDto): () -> IoError
  IoError {
    code: payload.read_i32("code"),
    message: payload.read_string("message")
  }

fn decode_host_error(payload: HostDto): () -> HostError
  HostError {
    code: payload.read_i32("code"),
    message: payload.read_string("message")
  }
