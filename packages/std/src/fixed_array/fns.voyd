//! Low-level helpers for `FixedArray` allocation and indexed operations.
//! Negative indices are normalized from the end (`-1` addresses the last element).

use std::optional::types::all

/// Allocates a fixed-size array.
///
/// Parameter:
/// - `size`: Requested array length. Caller is responsible for passing a valid size.
pub fn new_fixed_array<T>(size: i32): () -> FixedArray<T>
  __array_new<T>(size)

/// Returns the number of stored elements.
pub fn length<T>(arr: FixedArray<T>): () -> i32
  __array_len(arr)

/// Returns true when no values are stored.
pub fn is_empty<T>(arr: FixedArray<T>): () -> bool
  arr.length<T>() == 0

/// Returns the element at `index`, or `None` when out of bounds.
///
/// Negative indices are supported (`-1` addresses the last element).
pub fn get<T>(arr: FixedArray<T>, index: i32): () -> Optional<T>
  let len = arr.length<T>()
  let idx = normalize_index(index, len)

  if idx < 0:
    return None {}
  if idx >= len:
    return None {}

  let value = __array_get(arr, idx)
  if ref_is_null<T>(value):
    return None {}

  Some<T> { value: value }

/// Writes `value` at `index`.
///
/// Negative indices are supported (`-1` addresses the last element). Out-of-bounds
/// writes are ignored and return the input array unchanged.
pub fn set<T>(arr: FixedArray<T>, index: i32, value: T): () -> FixedArray<T>
  let len = arr.length<T>()
  let idx = normalize_index(index, len)

  if idx < 0:
    return arr
  if idx >= len:
    return arr

  __array_set(arr, idx, value)
  arr

/// Copies elements between fixed arrays according to the provided copy options.
///
/// Parameters:
/// - `dest_array`: Destination storage to write into.
/// - `opts.from`: Source storage to read from.
/// - `opts.to_index`: Destination start index (supports negative indices).
/// - `opts.from_index`: Source start index (supports negative indices).
/// - `opts.count`: Maximum number of elements to copy.
///
/// Out-of-bounds ranges are ignored and return `dest_array` unchanged.
pub fn copy<T>(dest_array: FixedArray<T>, opts: {
  from: FixedArray<T>,
  to_index: i32,
  from_index: i32,
  count: i32
}): () -> FixedArray<T>
  let dest_length = dest_array.length<T>()
  let from_length = opts.from.length<T>()
  let to_index = normalize_index(opts.to_index, dest_length)
  let from_index = normalize_index(opts.from_index, from_length)

  if to_index < 0:
    return dest_array
  if from_index < 0:
    return dest_array
  if to_index >= dest_length:
    return dest_array
  if from_index >= from_length:
    return dest_array
  if opts.count <= 0:
    return dest_array

  let remaining_dest = dest_length - to_index
  let remaining_from = from_length - from_index
  let max_copy = if remaining_dest < remaining_from then: remaining_dest else: remaining_from
  let count = if opts.count < max_copy then: opts.count else: max_copy

  if count <= 0:
    return dest_array

  __array_copy(dest_array, {
    from: opts.from,
    to_index: to_index,
    from_index: from_index,
    count: count
  })
  dest_array

/// Sets every position in the fixed array to the provided value.
pub fn fill<T>(arr: FixedArray<T>, value: T): () -> FixedArray<T>
  let len = arr.length<T>()
  var index = 0
  while index < len do:
    __array_set(arr, index, value)
    index = index + 1
  arr

/// Invokes a callback for each element.
pub fn each<T>(arr: FixedArray<T>, f: (v: T) -> void) -> void
  let len = arr.length<T>()
  var index = 0
  while index < len do:
    f(__array_get(arr, index))
    index = index + 1

/// Applies a transform to each element and returns a fixed array of equal length.
pub fn map<T, U>(arr: FixedArray<T>, f: (v: T) -> U) -> FixedArray<U>
  let len = arr.length<T>()
  let out = new_fixed_array<U>(len)
  var index = 0
  while index < len do:
    let value = __array_get(arr, index)
    __array_set(out, index, f(value))
    index = index + 1
  out

/// Resolves negative indices relative to fixed-array length.
fn normalize_index(index: i32, length: i32) -> i32
  if index < 0 then: length + index else: index

@intrinsic(name: "__ref_is_null")
/// Returns true when a reference slot is uninitialized/null.
fn ref_is_null<T>(value: T): () -> bool
  __ref_is_null(value)
