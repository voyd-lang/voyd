use std::optional::types::all

pub fn new_fixed_array<T>(size: i32): () -> FixedArray<T>
  __array_new<T>(size)

pub fn length<T>(arr: FixedArray<T>): () -> i32
  __array_len(arr)

pub fn is_empty<T>(arr: FixedArray<T>): () -> bool
  arr.length<T>() == 0

pub fn get<T>(arr: FixedArray<T>, index: i32): () -> Optional<T>
  let len = arr.length<T>()
  let idx = normalize_index(index, len)

  if idx < 0 then:
    return None {}
  if idx >= len then:
    return None {}

  let value = __array_get(arr, idx)
  if ref_is_null<T>(value) then:
    return None {}

  Some<T> { value: value }

pub fn set<T>(arr: FixedArray<T>, index: i32, value: T): () -> FixedArray<T>
  let len = arr.length<T>()
  let idx = normalize_index(index, len)

  if idx < 0 then:
    return arr
  if idx >= len then:
    return arr

  __array_set(arr, idx, value)
  arr

pub fn copy<T>(dest_array: FixedArray<T>, opts: {
  from: FixedArray<T>,
  to_index: i32,
  from_index: i32,
  count: i32
}): () -> FixedArray<T>
  let dest_length = dest_array.length<T>()
  let from_length = opts.from.length<T>()
  let to_index = normalize_index(opts.to_index, dest_length)
  let from_index = normalize_index(opts.from_index, from_length)

  if to_index < 0 then:
    return dest_array
  if from_index < 0 then:
    return dest_array
  if to_index >= dest_length then:
    return dest_array
  if from_index >= from_length then:
    return dest_array
  if opts.count <= 0 then:
    return dest_array

  let remaining_dest = dest_length - to_index
  let remaining_from = from_length - from_index
  let max_copy = if remaining_dest < remaining_from then: remaining_dest else: remaining_from
  let count = if opts.count < max_copy then: opts.count else: max_copy

  if count <= 0 then:
    return dest_array

  __array_copy(dest_array, {
    from: opts.from,
    to_index: to_index,
    from_index: from_index,
    count: count
  })
  dest_array

pub fn fill<T>(arr: FixedArray<T>, value: T): () -> FixedArray<T>
  let len = arr.length<T>()
  var index = 0
  while index < len do:
    __array_set(arr, index, value)
    index = index + 1
  arr

pub fn each<T>(arr: FixedArray<T>, f: (v: T) -> void) -> void
  let len = arr.length<T>()
  var index = 0
  while index < len do:
    f(__array_get(arr, index))
    index = index + 1

pub fn map<T, U>(arr: FixedArray<T>, f: (v: T) -> U) -> FixedArray<U>
  let len = arr.length<T>()
  let out = new_fixed_array<U>(len)
  var index = 0
  while index < len do:
    let value = __array_get(arr, index)
    __array_set(out, index, f(value))
    index = index + 1
  out

fn normalize_index(index: i32, length: i32) -> i32
  if index < 0 then: length + index else: index

@intrinsic(name: "__ref_is_null")
fn ref_is_null<T>(value: T): () -> bool
  __ref_is_null(value)
