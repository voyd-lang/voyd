use std::optional::types::all
use std::test::assertions::all

pub fn new_fixed_array<T>(size: i32): () -> FixedArray<T>
  __array_new<T>(size)

pub fn length<T>(arr: FixedArray<T>): () -> i32
  __array_len(arr)

pub fn is_empty<T>(arr: FixedArray<T>): () -> bool
  arr.length<T>() == 0

pub fn get<T>(arr: FixedArray<T>, index: i32): () -> Optional<T>
  let len = arr.length<T>()
  let idx = normalize_index(index, len)

  if idx < 0 then:
    return None {}
  if idx >= len then:
    return None {}

  let value = __array_get(arr, idx)
  if ref_is_null<T>(value) then:
    return None {}

  Some<T> { value: value }

pub fn set<T>(arr: FixedArray<T>, index: i32, value: T): () -> FixedArray<T>
  let len = arr.length<T>()
  let idx = normalize_index(index, len)

  if idx < 0 then:
    return arr
  if idx >= len then:
    return arr

  __array_set(arr, idx, value)
  arr

pub fn copy<T>(dest_array: FixedArray<T>, opts: {
  from: FixedArray<T>,
  to_index: i32,
  from_index: i32,
  count: i32
}): () -> FixedArray<T>
  let dest_length = dest_array.length<T>()
  let from_length = opts.from.length<T>()
  let to_index = normalize_index(opts.to_index, dest_length)
  let from_index = normalize_index(opts.from_index, from_length)

  if to_index < 0 then:
    return dest_array
  if from_index < 0 then:
    return dest_array
  if to_index >= dest_length then:
    return dest_array
  if from_index >= from_length then:
    return dest_array
  if opts.count <= 0 then:
    return dest_array

  let remaining_dest = dest_length - to_index
  let remaining_from = from_length - from_index
  let max_copy = if remaining_dest < remaining_from then: remaining_dest else: remaining_from
  let count = if opts.count < max_copy then: opts.count else: max_copy

  if count <= 0 then:
    return dest_array

  __array_copy(dest_array, {
    from: opts.from,
    to_index: to_index,
    from_index: from_index,
    count: count
  })
  dest_array

pub fn fill<T>(arr: FixedArray<T>, value: T): () -> FixedArray<T>
  let len = arr.length<T>()
  var index = 0
  while index < len do:
    __array_set(arr, index, value)
    index = index + 1
  arr

pub fn each<T>(arr: FixedArray<T>, f: (v: T) -> void): () -> void
  let len = arr.length<T>()
  var index = 0
  while index < len do:
    f(__array_get(arr, index))
    index = index + 1

pub fn map<T, U>(arr: FixedArray<T>, f: (v: T) -> U): () -> FixedArray<U>
  let len = arr.length<T>()
  let out = new_fixed_array<U>(len)
  var index = 0
  while index < len do:
    let value = __array_get(arr, index)
    __array_set(out, index, f(value))
    index = index + 1
  out

fn normalize_index(index: i32, length: i32) -> i32
  if index < 0 then: length + index else: index

@intrinsic(name: "__ref_is_null")
fn ref_is_null<T>(value: T): () -> bool
  __ref_is_null(value)

test "fixed_array get handles negative indexing":
  var arr = new_fixed_array<i32>(2)
  arr = arr.set<i32>(0, 3)
  arr = arr.set<i32>(1, 5)

  let last = arr.get<i32>(-1)
  match(last)
    Some<i32> { value }:
      assert(value, eq: 5)
    None:
      assert(false)

test "fixed_array get returns none for out-of-bounds":
  let arr = new_fixed_array<i32>(1)
  let missing = arr.get<i32>(2)
  match(missing)
    Some<i32>:
      assert(false)
    None:
      assert(true)

test "fixed_array get returns none for null refs":
  let arr = new_fixed_array<FixedArray<i32>>(1)
  let missing = arr.get<FixedArray<i32>>(0)
  match(missing)
    Some<FixedArray<i32>>:
      assert(false)
    None:
      assert(true)

test "fixed_array copy clamps to bounds":
  var dest = new_fixed_array<i32>(2)
  var src = new_fixed_array<i32>(2)
  dest = dest.set<i32>(0, 1)
  dest = dest.set<i32>(1, 2)
  src = src.set<i32>(0, 5)
  src = src.set<i32>(1, 6)

  dest = dest.copy<i32>({
    from: src,
    to_index: 0,
    from_index: 0,
    count: 5
  })

  let first = dest.get<i32>(0)
  let second = dest.get<i32>(1)

  match(first)
    Some<i32> { value }:
      match(second)
        Some<i32> { value: other }:
          assert(value + other, eq: 11)
        None:
          assert(false)
    None:
      assert(false)
