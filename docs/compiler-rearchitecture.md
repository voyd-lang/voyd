# Compiler Re-architecture Audit

## Context
- Development has stalled around an illegal WebAssembly cast generated by `Map.get`, documented in `docs/illegal-cast-root-cause.md`. The root cause is inconsistent specialization of `Some<T>` wrappers inside generics, revealing fragility in the current semantic pipeline.
- Upcoming features (algebraic effects) amplify the need for a durable type system and clearer separation between parsing, semantic analysis, and code generation.

## Current Semantic Stack
- `processSemantics` chains functional macro expansion, primitive/type initialization, entity initialization, entity resolution, and type checking on a single mutable tree (`src/semantics/index.ts:11`).
- Syntax objects double as both AST nodes and semantic artifacts. Parent/child pointers must be manually maintained, and semantic phases mutate the tree in place.
- Type information and resolution state live on the syntax nodes themselves (e.g., `Call.type`, `Identifier.type`, `Obj.fields[].type`), blurring syntactic structure with semantic facts.

## Findings

### Semantic phases rewrite the AST in place
- `resolveEntities` dispatches on every `Expr`, annotating types, registering captured variables, and even replacing nodes (`src/semantics/resolution/resolve-entities.ts:30`).
- The function is explicit that the returned tree might differ from the input (`src/semantics/resolution/resolve-entities.ts:26`). Examples include lowering array literals into constructor calls and expanding structural object arguments.
- Because transformations and semantic checks share the same tree, any later phase that re-traverses the syntax (e.g., `getExprType`) can trigger additional rewrites or resolution, making the pass order brittle.

### Type queries carry side effects
- `getExprType` is invoked throughout inference and codegen, but it mutates the tree by falling back to `resolveCall` whenever it encounters a call expression (`src/semantics/resolution/get-expr-type.ts:16`). Querying the type of an expression may therefore allocate new objects, attach attributes, or trigger generic specialization.
- Identifiers cache inferred types (`src/semantics/resolution/get-expr-type.ts:36`), so repeated queries rely on implicit mutation rather than a dedicated type table.

### Syntax objects conflate syntax, declarations, and runtime layout
- `Call` nodes hold both the callee definition and resolved return type (`src/syntax-objects/call.ts:12`), enabling passes to mutate call semantics instead of merely describing them.
- The `Obj` type simultaneously represents nominal declarations, structural literal shapes, and specialized instances. Fields store both the syntactic type expression and the resolved type (`src/syntax-objects/obj.ts:19`). Cloning an object to specialize generics copies semantic fields and implementation lists, creating further coupling.
- `TypeAlias` nodes retain resolution state (`resolvedType`, `resolutionPhase`) directly on the syntax object (`src/syntax-objects/type-alias.ts:10`), preventing reuse of the original AST for multiple instantiations.

### Generic instantiation depends on AST clones
- `resolveObjectType` duplicates objects, registers new `TypeAlias` stubs, and mutates the original definition to track `genericInstances` (`src/semantics/resolution/resolve-object-type.ts:90`). There is no central registry of instantiations; identity hinges on shared object references.
- Expected type propagation (`resolveWithExpected`) rewrites expression trees to match call expectations (`src/semantics/resolution/resolve-entities.ts:153`). It injects attributes, swaps arguments, and hoists constructors to satisfy call sites, exacerbating type drift across the tree.

### Structural vs nominal typing relies on ad-hoc mutation
- Union resolution fills `resolvedMemberTypes` arrays on the union node (`src/semantics/resolution/resolve-union.ts:9`), and intersection types stash both nominal and structural realizations on the same object. Type comparisons therefore depend on every upstream mutating pass having run in the correct order.
- Structural compatibility is evaluated against the mutated field types on `Obj` instances (`src/semantics/resolution/types-are-compatible.ts:74`), so any missed field propagation surfaces as runtime traps (e.g., the `Map.get` cast failure).

### Symbol resolution interleaves lexical scoping with rewriting
- `resolveEntities` both captures identifiers for closures and registers on-the-fly `TypeAlias` objects in impls and generics (`src/semantics/resolution/resolve-impl.ts:20`). Because scopes are stored on syntax nodes, cloning or moving nodes risks leaking symbol registrations or losing captures.
- Module registration and entity initialization happen before semantic resolution, but macros can still introduce complex forms that escape initialization, forcing later passes to defensively re-run initialization helpers.

### Impact on the illegal cast bug
- The specialized `Some<String>` vs `Some<RecType>` mismatch arises because array literals are rewritten into constructor calls using inferred element types before `Map`’s generic instantiation is fully resolved. Subsequent passes assume the nominal wrapper uses the map’s declared value type, but the stored instances retain the narrower inferred type, leading to the invalid `ref.cast` described in `docs/illegal-cast-root-cause.md`.
- Without a canonical semantic IR or type table, there is no single source of truth to reconcile the element type stored in the map with the instantiation expected at retrieval time.

## Macro Expansion Audit
- `expandFunctionalMacros` currently anchors the semantic pipeline and is responsible for macro expansion, `use` lowering, inline module declarations, and macro-time evaluation (`src/semantics/functional-macros.ts:24`).
- The pass mutates module scopes while expanding syntax (e.g., `initUse` registers imports directly on parent nodes at `src/semantics/functional-macros.ts:55`, and `initMod` inserts submodules at `:68`), so expansion order affects later resolution.
- Module phases are tracked imperatively (`expandModuleMacros` toggles `module.phase` in place at `src/semantics/functional-macros.ts:47`), which constrains re-entrancy and makes incremental rebuilds error-prone.
- Macro evaluation reuses runtime resolution (`Identifier.resolve()` inside `expandMacro` at `src/semantics/functional-macros.ts:133`), coupling macro environments to runtime scopes and preventing isolation between compile-time and runtime symbols.

## Recommended Architecture

### Guiding principles
- **Separate syntax from semantics**: keep parser-produced syntax objects immutable post-parse; build dedicated semantic IR nodes for binding, types, and effects.
- **Record facts in tables, not syntax**: introduce symbol, type, and effect tables keyed by stable node IDs. Semantic passes should be pure functions over these tables.
- **Make phase boundaries explicit**: distinguish binding, type inference, effect analysis, and lowering. Each phase should consume prior tables and produce new ones without mutating upstream artifacts.
- **Support hybrid typing and effects intentionally**: encode both nominal identities and structural shapes in the type system, and design effect typing as a first-class concern rather than an afterthought.

### Proposed pipeline
1. **Parse → AST** (existing syntax objects). Treat AST nodes as immutable except for parent pointers maintained by parsing.
2. **Macro expansion**: run a dedicated expander that consumes the parsed AST and a seed module graph, producing a fresh expanded AST plus macro metadata.
3. **Binder**: traverse the expanded AST to build a `SymbolTable`, mapping `NodeId` + `Name` → symbol definitions/scopes. Produce a scope graph and import/export graph.
4. **Type-lowering to HIR**: build a semantic High-Level IR where expressions reference symbols (`SymbolId`) instead of syntax nodes. HIR nodes include normalized constructs (e.g., desugared array/object literals) and record source spans for error reporting.
5. **Type inference & checking**: operate on HIR using a `TypeArena` storing canonical `TypeId` instances. Implement constraint solving, generic instantiation, and variance here. Record results in a `TypeTable` keyed by HIR IDs.
6. **Effect analysis**: run after typing to compute effect rows per expression. Store results in an `EffectTable` for later phases.
7. **Optimization & MIR**: lower typed HIR into a mid-level IR tailored for WebAssembly codegen, using the type/effect tables to drive calling conventions.
8. **Codegen**: translate MIR to WASM text/binary. Type/Effect tables remain as references for runtime metadata.

### Macro expansion strategy
- **Dedicated macro IR**: represent macro definitions and environments separately from runtime entities. Macro scopes draw from a `MacroModuleGraph`, avoiding mutations to runtime symbol tables during expansion.
- **Module graph integration**: seed the expander with a read-only module registry derived from parsing. `use` forms consult this graph instead of recursively resolving modules at runtime (`src/semantics/functional-macros.ts:55`), and the resulting imports are persisted for the binder.
- **Pure output**: expansion yields a new AST with consistent parent pointers and `NodeId`s, leaving the original syntax untouched. This makes macro expansion re-runnable and simplifies incremental compilation.
- **Isolated evaluation**: macro-time evaluation uses an explicit environment of macro bindings rather than `Identifier.resolve()`, preventing cross-contamination between compile-time and runtime scopes.
- **Early diagnostics**: macro expansion emits its own errors (undefined macro, invalid module reference) before binding, so later phases can assume the expanded AST respects syntactic invariants and module topology.

### Data model details
- **Node IDs**: assign every AST node a stable `NodeId`. HIR nodes retain the originating AST `NodeId` for diagnostics.
- **SymbolTable**: hierarchical scopes with explicit parents. Symbols carry metadata (kind, generics, trait/impl context). Replaces implicit `lexicon` maps on syntax objects.
- **TypeArena**: interning for types. Variants include `NominalType`, `StructuralType`, `Tuple`, `Function`, `Union`, `Intersection`, `EffectfulFunction`, etc. Each variant references other `TypeId`s rather than embedding full objects.
- **TypeTable**: maps `HIRExprId` → `TypeId`, plus `HIRSymbolId` → `TypeScheme`. Lookups are pure reads; mutation is scoped to inference.
- **EffectTable**: records effect rows (`{operations, region, rowVar}`) for each callable expression, enabling algebraic effect checking and inference.
- **Generics**: represent declared generics as `TypeScheme { params, constraints, body }`. Instantiation produces substitutions stored in the `TypeArena`. Monomorphization decisions (on-demand specialization vs. reified generics) happen during MIR lowering, informed by usage counts and FFI constraints.

### Durable type system design
- **Nominal + structural**: store both the nominal head (`NominalId`) and the structural shape in each relevant type. Structural equality operates on canonicalized shape descriptors; nominal equality relies on `NominalId`. Intersection types become pairs `(NominalId?, StructuralShape?)`.
- **Type aliases**: represent as `TypeScheme`s; aliases no longer wrap syntax nodes. Expansion is demand-driven via the `TypeArena`.
- **Unions**: maintain normalized variant sets keyed by nominal head and shape. Resolution produces canonical `UnionTypeId` entries without mutating original syntax.
- **Generics and inference**: use constraint solving with substitution maps. `infer<T>` operations produce substitution results stored per call site, eliminating the need to mutate the callee or arguments.
- **GC integration**: tie every nominal type to a layout descriptor derived from the `TypeArena`. Structural types compile to transient layouts or wrapper objects with caching keyed by structural shape hashes.

### Effect system blueprint
- Model effects as row-polymorphic sets (`{op: EffectOp, region?: RegionId}`) with an open row variable for polymorphism.
- Functions receive a `(TypeId, EffectRowId)` pair. Calls compose effect rows via unification; higher-order functions quantify over effect variables.
- Traits/impls include effect constraints, enabling the compiler to enforce that implementations don't widen declared effects.
- Effect data lives alongside type data, allowing later passes (like codegen) to pick calling conventions or stack management strategies based on effect presence (e.g., suspendable coroutines).

### Trait Implementations
- Binder: each `impl` registers in an `ImplRegistry` keyed by the implementing type’s `TypeId` and the target trait’s `TypeId`. For generic implementations (e.g., `impl<T> for Result<T, E>`), the registry stores a `TypeSchemeId` describing the impl’s type parameters, constraints, and the canonical head type so later phases can instantiate the `impl` for specific substitutions. Entries capture method symbols, associated type bindings, and declared effect constraints so downstream passes never need to reopen the AST.
- Type inference: when resolving trait bounds or method calls, the checker queries the registry and uses the `TypeArena` to instantiate trait signatures with the concrete type arguments supplied either by the calling site or by generic object instantiations. A unification step matches the target type against the `impl`’s scheme, ensuring that both generic impls and impls over generic objects (e.g., `impl<T> for Map<Key, T>`) select correctly. Incompatibilities (mismatched types, missing methods, unsatisfied constraints) surface here with precise diagnostics.
- Effect analysis: implementations inherit the trait’s effect row; the effect checker verifies that each method’s inferred row is a subsumed version of the trait requirement under the same substitution used during type inference, catching effect widening before code generation.
- Code generation: once semantics succeed, codegen consumes the registry to emit dispatch tables or metadata for dynamic trait calls. Generic impls are monomorphized or referenced according to the instantiated `TypeId`s provided by the registry, relying on the proven type/effect compatibility maintained by earlier phases.

### Recursive Types
- During binding the checker detects alias cycles (direct or indirect) and records a canonical `TypeId` for the recursive head. The alias node stores this `TypeId` and marks the definition as recursive so future lookups short-circuit through the arena instead of expanding the alias body repeatedly.
- The `TypeArena` represents self-references via `type-param-ref` placeholders inside the nominal descriptor, allowing instantiation to reuse the same `TypeId` when the recursive type is applied with concrete arguments.
- Type inference and effect checking operate on the canonical IDs, so they reason about recursive structures without cloning syntax, while codegen receives a single descriptor describing the layout needed for fixpoint types.

### Addressing the illegal cast class of bugs
- With substitutions tracked explicitly, the map initializer would record that the bucket stores `Optional<String>`, while the map’s declared type expects `Optional<RecType>`. The type checker would either reject the mismatch or trigger coercion logic before codegen, preventing untracked specialization.
- Consistent type IDs ensure downcasts compare canonical representations rather than structural mutations attached to syntax nodes.

- Detailed specifications for the `SymbolTable`, `TypeArena`, and `EffectTable` live under `docs/proposals/`. Review those documents for API definitions, terminology, and usage notes that underpin the `src_next` rewrite.

## Migration Strategy
1. **Bootstrap `src_next`**
   - Create a clean `src_next` workspace that reuses only the parser and CLI harness entry points. Wire a feature flag (`VT_NEXT=1`) so the CLI can dispatch to the new pipeline while keeping the legacy compiler intact for reference.
   - Stand up shared utilities (`NodeId`, `SymbolId`, `TypeId`, effect row IDs) inside `src_next/lib`, ensuring they do not mutate legacy syntax objects.
2. **Rebuild front-end passes in `src_next`**
   - Implement the new macro expander against parser output, emitting the expanded AST plus a module graph snapshot.
   - Build the binder on top of the proposed `SymbolTable` API, producing scope and import/export tables stored in `src_next/binder`.
3. **Introduce semantic IR and typing**
   - Lower expanded AST into HIR nodes housed in `src_next/hir`. Populate the `TypeArena` and `EffectTable` to power type inference, algebraic effect analysis, and trait resolution without touching legacy semantics.
   - Port standard-library type descriptors gradually, prioritizing dependencies needed for smoke tests (Option, Result, collections).
4. **Code generation pipeline**
   - Implement MIR lowering and WebAssembly codegen under `src_next/codegen`, reusing runtime helpers where possible. Compare emitted WAT against legacy output for selected fixtures.
5. **Bridge CLI and tests**
   - Add a CLI switch to run both compilers, defaulting to `src_next` once core language features pass. Mirror critical tests into `src_next/__tests__`, expanding coverage as features land.
   - Retire legacy compiler once `src_next` matches behaviour on the full test suite and new architecture-specific scenarios (effects, structural typing) pass.

Throughout the rewrite, keep legacy `src` read-only for reference; all new development happens in `src_next`. Use integration snapshots to verify parity and to catch regressions early.

## Next Steps
1. Validate the proposed `SymbolTable`, `TypeArena`, and `EffectTable` interfaces with the team and finalize the `src_next` project layout.
2. Implement the macro expander prototype inside `src_next` and exercise it on a handful of modules to shake out module-graph requirements.
3. Stand up the new binder using the agreed interfaces, wiring it into a thin CLI path guarded by `VT_NEXT`.
4. Define exit criteria for switching the default compiler (feature coverage, performance, diagnostics), including regression tests for the illegal cast bug and upcoming effect semantics.
